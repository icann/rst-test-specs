---
RST-Test-Plan-Schema-Version: 1.3
Version: 3.0
Last-Updated: 2023-10-02

Preamble: |
  The Test System consists of several *test plans*, each of which addresses a
  particular scenario. The test plans follow a standard structure and
  methodology derived from ISO/IEC 29119 *(formerly IEEE 829-2008)*.

  Each *test plan* includes one or more *test suites*, which in turn include
  one or more *test cases*. For a test to succeed, every test case has to pass.

  This file describes each test plan, suite and case in the RST system.

  ### 2.1. Key acronyms and terms

  RST
  : Registry System Testing. This system.

  PDT
  : Pre-Delegation Test. A test carried out prior to the delegation of a new TLD
  into the DNS root zone.

  RSP
  : Registry Service Provider. A specialist provider of critical registry
  services.

  DNS
  : Domain Name System. The internet's system of globally unique identifiers.

  TLD
  : Top-level domain. The highest level of the DNS namespace hierarchy.

  gTLD
  : generic top-level domain.

  DNSSEC
  : DNS Security Extensions.

  EPP
  : Extensible Provisioning Protocol. The protocol used by registrars to create
  and manage domain name registrations in an SRS.

  SRS
  : Shared Registry System. A TLD registry in which registrations are managed
  by one or more registrars, using EPP.

  RDDS
  : Registration Data Directory Services. A service to provide access to
  data about domain registrations to third parties.

  RDAP
  : Registration Data Access Protocol. The protocol used to deliver the RDDS.

  RDE
  : Registry Data Escrow. A system whereby the registration data stored in a
  Shared Registry System is backed up to a trusted third party.

  IDN
  : Internationalized Domain Name. A domain name that contains characters not in
  the ASCII character set.

  LGR
  : Label Generation Ruleset. The rules by which IDN domain names are validated.

  RO
  : Registry Operator. The entity which ICANN has granted the right to operate a
  gTLD.

  RA
  : Registry Agreement. The contract between a Registry Operator and ICANN.

  KSK
  : Key Signing Key. A cryptographic key which acts as the Secure Entry Point
  for a DNS zone, and which signs a DNS zone's ZSKs. A digest of this key is
  published in the parent zone (ie. the root zone for a TLD).

  ZSK
  : Zone Signing Key. A cryptographic key which signs a DNS zone's resource
  records.

Contact:
  Name: GDS Technical Services
  Organization: Internet Corporation for Assigned Names and Numbers (ICANN)
  Email: rst@icann.org

Test-Plans:
  StandardPreDelegationTest:
    Order: 1
    Name: Pre-Delegation Test
    Description: |
      The purpose of the Pre-Delegation Test is to verify that the applicant has
      met its commitment to establish registry operations in accordance with the
      technical and operational criteria described in the gTLD Applicant
      Guidebook (AGB). Each applicant will be required to complete PDT as a
      prerequisite to delegation into the root zone.

      The Pre-Delegation Test covers all critical registry services and IDNs,
      and therefore uses all test suites.
    Test-Suites:
      - StandardDNS
      - StandardDNSSEC
      - StandardEPP
      - StandardRDDS
      - StandardIDN
      - StandardRDE

  StandardRSPChangeTest:
    Order: 2
    Name: RSP Change Test
    Description: |
      A Registry Operator may apply to ICANN to change a Material Subcontracting
      Arrangement (MSA) and appoint a new Registry Services Provider. Before
      this change can be approved, the new RSP must complete Registry System
      Testing to ensure their systems comply with the technical and operational
      requirements of the Registry Agreement.

      The RSP Change Test covers all critical registry services and IDNs, and
      therefore uses all test suites.
    Test-Suites:
      - StandardDNS
      - StandardDNSSEC
      - StandardEPP
      - StandardIDN
      - StandardRDDS
      - StandardRDE

  DNSRSPChangeTest:
    Order: 3
    Name: DNS Registry Service Provider Change Test
    Description: |
      A Registry Operator may apply to ICANN to change a Material Subcontracting
      Arrangement (MSA) and appoint a new provider of authoritative DNS services
      instead of or in addition to any existing provider(s).

      Before this change can be approved, the new DNS provider must complete
      testing to ensure their systems comply with the technical and operational
      requirements of the Registry Agreement.

      The DNS RSP Change Test uses the DNS test suite only.
    Test-Suites:
      - StandardDNS
      - StandardDNSSEC

  IDNTest:
    Order: 4
    Name: Internationalized Domain Name Test
    Description: |
      A Registry Operator may apply to ICANN to amend its Registry Agreement
      to offer new scripts and/or languages for Internationalized Domain Names.

      The purpose of an IDN RST test is to verify that the Registry Operator’s
      registry system handles IDN registrations in accordance with the
      submitted policy statements and IDN tables.

      The IDN Test uses the IDN test suite only.
    Test-Suites:
      - StandardIDN

  SRSGatewayTest:
    Order: 5
    Name: SRS Gateway Test
    Description: |
      An SRS Gateway service is a Shared Registry System implementation that
      acts as a proxy between a subset of Registrars and the Registry. It uses
      a local cache to speed up EPP query commands, but forwards all EPP
      transform commands to the TLD Registry System. TLD registries need to
      deploy a proxy setup in order to operate in certain markets worldwide.

      The purpose of an SRS Gateway Test is to verify that the Registry
      Operator’s proxy setup operates in accordance with the technical and
      operational criteria for EPP systems described in the gTLD Applicant
      Guidebook (AGB). Furthermore, it must keep its own database synchronized
      with that of the TLD registry.

      The SRS Gateway Test Change Test uses the RDDS and EPP test suites.
    Test-Suites:
      - StandardSRSGateway

  MainRSPEvaluationTest:
    Order: 6
    Name: Main RSP Evaluation Test
    Description: |
      The Main RSP is responsible for the creation and maintenance of domain
      name registrations in a Shared Registration System (SRS). This encompasses
      the lifecycle of a domain name registration using domain registrars and
      protocols such as the Extensible Provisioning Protocol (EPP) and adherence
      to policies regarding the use and transparency domain name registrations
      through reporting, the Registration Data Access Protocol (RDAP), and other
      mechanisms.

    Test-Suites:
      - StandardEPP
      - LaunchExtensionAndTMCH
      - StandardIDN
      - StandardRDDS
      - StandardRDE

  DNSRSPEvaluationTest:
    Order: 7
    Name: DNS RSP Evaluation Test
    Description: |
      DNS RSPs provide primary or secondary authoritative DNS services.
      Therefore, this test plan only covers the DNS area.

      RSPs wishing to offer DNSSEC services in addition to authoritative DNS
      will also be evaluated using the DNSSEC RSP Evaluation Test below.
    Test-Suites:
      - StandardDNS

  DNSSECRSPEvaluationTest:
    Order: 8
    Name: DNSSEC RSP Evaluation Test
    Description: |
      DNSSEC RSPs provide signing of TLD zone files as a service. They do not
      provide primary or secondary authoritative DNS services.

      RSPs wishing to offer DNSSEC services in addition to authoritative DNS
      will also be evaluated using the DNSSEC RSP Evaluation Test below.
    Test-Suites:
      - StandardDNSSEC
      - DNSSECOperations

Test-Suites:
  StandardDNS:
    Order: 1
    Name: Authoritative DNS
    Description: |
      The DNS test suite validates the authoritative DNS services for the TLD
      or RSP.

      The DNS test suite is taken from the test plans that are part of the
      [Zonemaster software](https://github.com/zonemaster) (`Zonemaster::Engine`
      version v4.7.3). Test case IDs from this document can be mapped to the
      Zonemaster test IDs by removing the `dns-` prefix.

      Since Zonemaster is designed to perform testing of domain names anywhere
      in the DNS hierarchy, not all Zonemaster tests are applicable for TLDs and
      may not be listed in the test suites in this document.

      ## Testing of Anycast networks using multiple vantage points

      In order to test anycast networks without requiring RSPs to provide the
      unicast adresses of their nodes, all tests carried out over the network
      will be performed from multiple vantage points. All vantage points must
      receive the same response in order for the tests to pass.

    Test-Cases: ^dns-

  StandardDNSSEC:
    Order: 2
    Name: DNS Security Extensions (DNSSEC)
    Description: |
      The DNSSEC test suite validates the DNSSEC signing service for the TLD or
      RSP.

      The DNSSEC test suite is taken from the test plans that are part of the
      [Zonemaster software](https://github.com/zonemaster) (`Zonemaster::Engine`
      version v4.7.3). Test case IDs from this document can be mapped to the
      Zonemaster test IDs by removing the `dnssec-` prefix.

      Since Zonemaster is designed to perform testing of domain names anywhere
      in the DNS hierarchy, not all Zonemaster tests are applicable for TLDs and
      may not be listed in the test suites in this document.
    Test-Cases: ^dnssec-

  StandardRDDS:
    Order: 3
    Name: Registration Data Directory Services (RDDS)
    Description: |
      The DNSSEC test suite validates the RDDS service(s) of the TLD or RSP.

      The RDAP test suite is derived from the test specification of the [RDAP
      Conformance Tool](https://github.com/icann/rdap-conformance-tool/blob/master/doc/RDAPConformanceToolSpecifications.pdf).
      As with the DNS and DNSSEC tests, the test IDs can be mapped to the test
      IDs in this document by removing the `rdap-` prefix.

      Due to the upcoming retirement of Nicname/Whois, port-43 services are not
      tested.
    Test-Cases: ^rdap-

  StandardEPP:
    Order: 4
    Name: Extensible Provisioning Protocol (EPP)
    Description: |
      The EPP test suite validates the EPP service of the TLD or RSP.
    Test-Cases: ^epp-

  StandardRDE:
    Order: 5
    Name: Registry Data Escrow (RDE)
    Description: |
      The RDE test suite validates Registry Data Escrow deposits generated for
      the TLD or RSP.
    Test-Cases: ^rde-

  StandardIDN:
    Order: 6
    Name: Internationalized Domain Names (IDN)
    Description: |
      The RDE test suite validates the IDN table(s) for a TLD or RSP.
    Test-Cases: ^idn-

  StandardSRSGateway:
    Order: 7
    Name: SRS Gateway
    Description: |
      The SRS Gateway test suite validates the conformance of the Gateway
      registry infrastructure of a TLD or RSP, and the synchronisation between
      primary and gateway systems.
    Test-Cases: ^srsgw-

  DNSSECOperations:
    Order: 8
    Name: DNSSEC RSP - Operations
    Description: |
      This test suite verifies the ability of an RSP to carry out standard
      DNSSEC operational procedures while maintaining a chain of trust to the
      parent zone.
    Test-Cases:
      - dnssecRSP01-ZSKRollover
      - dnssecRSP02-KSKRollover
      - dnssecRSP03-AlgorithmRollover

  LaunchExtensionAndTMCH:
    Order: 9
    Name: Main RSP - Launch Extension & Trademark Clearinghouse (TMCH) Support
    Description: |
      This test suite verifies an RSP's support for the Launch Extension (RFC
      8334) and the Trademark Clearinghouse.
    Test-Cases:

Test-Cases:
  dns-address01:
    Summary: Verify that IPv4 addresse are not in private networks
    Description: |
      In order for the domain and its resources to be accessible, authoritative
      name servers must have addresses in the routable public addressing space.

      IANA is responsible for global coordination of the IP addressing system.
      Aside its address allocation activities, it maintains reserved address ranges
      for special uses. These ranges can be categorized into three types :
      [Special purpose IPv4
      addresses](https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xml),
      [Special purpose IPv6
      addresses](https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xml)
      and [Multicast reserved
      addresses](https://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml).

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Obtain the IP addresses of each name server of the domain from the parent using
         [Method4](../Methods.md) and child using [Method5](../Methods.md)

      2. If any IP address (IPv4 or IPv6) falls within any of the blocks in the below
         mentioned IANA links, the test case fails:
         * <https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml>
         * <https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml>

      ### Outcome(s)

      If one name server has one of its addresses matches a forbidden address
      block, the test fails. If all the name server addresses are outside these
      forbidden blocks, the test case succeeds.

      ### Special procedural requirements

      The registries listed in bullet 2 above must be fetched prior to testing
  dns-address02:
    Summary: Verify reverse DNS entries exist for nameserver IP addresses
    Description: |
      Some anti-spam techniques use reverse DNS lookup to allow incoming traffic.
      In order to prevent name servers to be blocked or blacklisted, DNS
      administrators should publish PTR records associated to name server
      addresses.

      [technical reference to be found]

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Obtain the glue address records  of the domain checked
         using [Method4](../Methods.md)

      2. Obtain the IP addresses of each name server of the domain checked
         using [Method5](../Methods.md)

      3. For each IP address, a recursive PTR query must be performed.

      4. If any answer of the queries performed in step 3 contains an RCODE
         other than NOERROR or if the answer does not include a PTR record,
         this test case fails.

      ### Outcome(s)

      If the test case succeeds, its result is a list of addresses with corresponding
      hostnames which are the result of the PTR queries performed.
      The result could be represented as a hash table where the keys are the IP
      addresses and the values their corresponding hostnames.
  dns-address03:
    Summary: Verify that reverse DNS entries match nameserver names
    Description: |
      Some anti-spam techniques use reverse DNS lookup to allow incoming traffic.
      In order to prevent name servers to be blocked or blacklisted, DNS
      administrators should publish PTR records associated with the name server
      addresses.

      Moreover, as mentioned in paragraph 2.1 of [RFC
      1912](https://datatracker.ietf.org/doc/html/rfc1912) when a PTR record exists, it must match the host
      name.

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Obtain the IP addresses of each name server of the domain from the child
         using [Method5](../Methods.md).
         These IP addresses can be associated to the name servers through a hash
         table where each address is a key and the name server it's unique value.
         Let's call this hash table HASH1.

      2. Obtain the reverse DNS entries associated to name servers names as described
         in test case [ADDRESS02](address02.md). Let's call its outcome HASH2 which
         consists of IP adresses as keys and hostnames as values. As multiple PTR
         records are allowed, an IP address can have several corresponding hostnames.

      3. Compare HASH2 to HASH1.

         Parse the address list of HASH1.

         For an address (a) of HASH1, take the corresponding hostname (h) in HASH1.
         If this hostname (h) is present in the hostnames list associated to this
         address (a) in HASH2, then the test succeeds for address (a).

         If the hostname (h) does not match any hostnames associated to address (a)
         in HASH2, then the test fails for address (a).

         If the test fails for one IP address, the whole test case fails.
      ### Outcome(s)

      Multiple addresses and multiple PTR records are allowed. The test
      succeeds if every name server address has one or more PTR records
      and one of these records matches the server name.
      If one address doesn't match, the whole test case fails.
    Dependencies:
      - dns-address02
  dns-connectivity01:
    Summary: Verify nameserver UDP port 53 reachability
    Description: |
      UDP is the fundamental protocol to reach a general purpose name server hosting
      a zone, "DNS servers MUST be able to service UDP [...]" ([RFC 1123], section
      6.1.3.2, page 75), also restated in [RFC 7766][RFC 7766#5], section 5.

      This Test Case will verify if the name servers of *Child Zone* are reachable over
      UDP. The name servers tested are both those in the delegation of *Child Zone* and
      those in the NS records in the *Child Zone* itself.

      Most Zonemaster Test Cases will query the name servers in the delegation or the
      name servers appointed by the NS records in the zone for the NS or SOA record,
      or both. It is crucial that problems are reported, but instead of letting several
      Test Cases report the same problems found, most Test Cases assume that this test
      case is run. Only this Test Case will report problems found in the following
      areas over UDP:

      * Name Server not responding to a query without EDNS.
      * Name Server not including SOA record of *Child Zone* in the answer section in
        the response on a SOA query for *Child Zone*.
      * Name Server not including NS record of *Child Zone* in the answer section in
        the response on an NS query for *Child Zone*.
      * Name Server not setting the AA flag in a response with SOA or NS in answer
        section.
      * Name Server responding with unexpected [RCODE Name] (any except "NoError") on
        query for SOA or NS for *Child Zone*.

      In addition, this test case will output a message if transport over IPv4 or IPv6
      has been disabled.

      ## Scope

      The only UDP port defined for DNS is port 53 ([RFC 1035][RFC 1035#4.2.1], section
      4.2.1), and that is the only port used by this and other Test Cases for DNS
      queries to the name servers.
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      ## Summary

      Message Tag                         |Level  |Arguments  | Message ID for message tag
      :-----------------------------------|:------|:----------|:------------------------------------------------------------------------------------------
      CN01_IPV4_DISABLED                  | NOTICE| ns_list   | IPv4 is disabled. No DNS queries are sent to these name servers: "{ns_list}".
      CN01_IPV6_DISABLED                  | NOTICE| ns_list   | IPv6 is disabled. No DNS queries are sent to these name servers: "{ns_list}".
      CN01_MISSING_NS_RECORD_UDP          |WARNING| ns        | Nameserver {ns} reponds to a NS query with no NS records in the answer section over UDP.
      CN01_MISSING_SOA_RECORD_UDP         |WARNING| ns        | Nameserver {ns} reponds to a SOA query with no SOA records in the answer section over UDP.
      CN01_NO_RESPONSE_NS_QUERY_UDP       |WARNING| ns        | Nameserver {ns} does not respond to NS queries over UDP.
      CN01_NO_RESPONSE_SOA_QUERY_UDP      |WARNING| ns        | Nameserver {ns} does not respond to SOA queries over UDP.
      CN01_NO_RESPONSE_UDP                |WARNING| ns        | Nameserver {ns} does not respond to any queries over UDP.
      CN01_NS_RECORD_NOT_AA_UDP           |WARNING| ns        | Nameserver {ns} does not give an authoritative response on an NS query over UDP.
      CN01_SOA_RECORD_NOT_AA_UDP          |WARNING| ns        | Nameserver {ns} does not give an authoritative response on an SOA query over UDP.
      CN01_UNEXPECTED_RCODE_NS_QUERY_UDP  |WARNING| ns, rcode | Nameserver {ns} responds with an unexpected RCODE ({rcode}) on an NS query over UDP.
      CN01_UNEXPECTED_RCODE_SOA_QUERY_UDP |WARNING| ns, rcode | Nameserver {ns} responds with an unexpected RCODE ({rcode}) on an SOA query over UDP.
      CN01_WRONG_NS_RECORD_UDP            |WARNING| ns, domain_found, domain_expected | Nameserver {ns} responds with a wrong owner name ({domain_found} instead of {domain_expected}) on NS queries over UDP.
      CN01_WRONG_SOA_RECORD_UDP           |WARNING| ns, domain_found, domain_expected | Nameserver {ns} responds with a wrong owner name ({domain_found} instead of {domain_expected}) on SOA queries over UDP.
      The value in the Level column is the default severity level of the message. The
      severity level can be changed in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].
      ## Test procedure

      In this section and unless otherwise specified below, the term "[DNS Query]"
      follows the specification for DNS queries as specified in
      [DNS Query and Response Defaults]. The handling of the DNS responses on the DNS
      queries follow, unless otherwise specified below, what is specified for
      [DNS Response] in the same specification.

      1. Create [DNS Queries][DNS Query]:
         1. Query type SOA and query name *Child Zone* ("SOA Query").
         1. Query type NS and query name *Child Zone* ("NS Query").

      2. Obtain the set of name server IP addresses using [Method4] and [Method5]
         ("Name Server IP").

      3. If IPv4 is disabled then do:
         1. Extract all name servers with IPv4 address from *Name Server IP*.
         2. If the set of IPv4 name servers is non-empty then output
            *[CN01_IPV4_DISABLED]* with the set of IPv4 name servers (names and IP
            addresses).

      4. If IPv6 is disabled then do:
         1. Extract all name servers with IPv6 address from *Name Server IP*.
         2. If the set of IPv6 name servers is non-empty then output
            *[CN01_IPV6_DISABLED]* with the set of IPv6 name servers (names and IP
            addresses).

      5. For each name server in *Name Server IP* do:

         1. Send *SOA Query* and *NS Query* to the name server and collect
            the [DNS Responses][DNS Response].
         2. If there is no DNS response on neither query, then:
            1. Output *[CN01_NO_RESPONSE_UDP]* with name and IP address of the name
               server.
            2. Go to next name server.
         3. Else:
            1. Process the response on *SOA Query*:
               1. If there is no [DNS response], then output
                  *[CN01_NO_RESPONSE_SOA_QUERY_UDP]* with name and IP address of the
                  name server.
               2. Else, if [RCODE Name] is not "NoError" then output
                  *[CN01_UNEXPECTED_RCODE_SOA_QUERY_UDP]* with [RCODE Name] and name
                  and IP address of the name server.
               3. Else, if there is no SOA record in the answer section, then
                  output *[CN01_MISSING_SOA_RECORD_UDP]* with name and IP address of
                  the name server.
               4. Else, if the SOA record has owner name other than *Child Zone*
                  then output *[CN01_WRONG_SOA_RECORD_UDP]* with name and IP address of
                  the name server, the SOA record owner name and *Child Zone*.
               5. Else, if AA flag is unset, then output *[CN01_SOA_RECORD_NOT_AA_UDP]*
                  with name and IP address of the name server.
            2. Process the response on *NS Query*:
               1. If there is no [DNS Response], then output
                  *[CN01_NO_RESPONSE_NS_QUERY_UDP]* with name and IP address of the
                  name server.
               2. Else, if [RCODE Name] is not "NoError" then output
                  *[CN01_UNEXPECTED_RCODE_NS_QUERY_UDP]* with [RCODE Name] and name and
                  IP address of the name server.
               3. Else, if there is no NS record in the answer section, then
                  output *[CN01_MISSING_NS_RECORD_UDP]* with name and IP address of the
                  name server.
               4. Else, if the NS record has owner name other than *Child Zone*
                  then output *[CN01_WRONG_NS_RECORD_UDP]* with name and IP address of
                  the name server, the NS record owner name and *Child Zone*.
               5. Else, if AA flag is unset, then output *[CN01_NS_RECORD_NOT_AA_UDP]*
                  with name and IP address of the name server.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, skip sending queries over that
      transport protocol.
  dns-connectivity02:
    Summary: Verify nameserver TCP port 53 reachability
    Description: |
      TCP is a protocol to reach a general purpose name server hosting a zone, "All
      general-purpose DNS implementations MUST support [...] TCP transport"
      ([RFC 7766][RFC 7766#5], section 5).

      This Test Case will verify if the name servers of *Child Zone* are reachable over
      TCP. The name servers tested are both those in the delegation of *Child Zone* and
      those in the NS records in the *Child Zone* itself.

      This Test Case will mimic the tests done by [Connectivity01], but over TCP
      instead:

      * Name Server responding to a query.
      * Name Server including SOA record of *Child Zone* in the answer section in the
        response on a SOA query for *Child Zone*.
      * Name Server including NS record of *Child Zone* in the answer section in the
        response on an NS query for *Child Zone*.
      * Name Server setting the AA flag in a response with SOA or NS in answer section.
      * Name Server responding with expected [RCODE Name] ("NoError") on query for SOA
        or NS for *Child Zone*.
      ## Scope

      The only TCP port defined for DNS is port 53 ([RFC 1035][RFC 1035#4.2.1], section
      4.2.1), and that is the only port used by this and other Test Cases for DNS
      queries to the name servers.

      UDP connectivity is tested by Test Case [Connectivity01].
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      ## Summary

      Message Tag                         |Level  |Arguments  | Message ID for message tag
      :-----------------------------------|:------|:----------|:---------------------------------------------------------------------------------------
      CN02_MISSING_NS_RECORD_TCP          |WARNING| ns        | Nameserver {ns} reponds to a NS query with no NS records in the answer section over TCP.
      CN02_MISSING_SOA_RECORD_TCP         |WARNING| ns        | Nameserver {ns} reponds to a SOA query with no SOA records in the answer section over TCP.
      CN02_NO_RESPONSE_NS_QUERY_TCP       |WARNING| ns        | Nameserver {ns} does not respond to NS queries over TCP.
      CN02_NO_RESPONSE_SOA_QUERY_TCP      |WARNING| ns        | Nameserver {ns} does not respond to SOA queries over TCP.
      CN02_NO_RESPONSE_TCP                |WARNING| ns        | Nameserver {ns} does not respond to any queries over TCP.
      CN02_NS_RECORD_NOT_AA_TCP           |WARNING| ns        | Nameserver {ns} does not give an authoritative response on an NS query over TCP.
      CN02_SOA_RECORD_NOT_AA_TCP          |WARNING| ns        | Nameserver {ns} does not give an authoritative response on an SOA query over TCP.
      CN02_UNEXPECTED_RCODE_NS_QUERY_TCP  |WARNING| ns, rcode | Nameserver {ns} responds with an unexpected RCODE ({rcode}) on an NS query over TCP.
      CN02_UNEXPECTED_RCODE_SOA_QUERY_TCP |WARNING| ns, rcode | Nameserver {ns} responds with an unexpected RCODE ({rcode}) on an SOA query over TCP.
      CN02_WRONG_NS_RECORD_TCP            |WARNING| ns, , domain_found, domain_expected | Nameserver {ns} responds with a wrong owner name ({domain_found} instead of {domain_expected}) on NS queries over TCP.
      CN02_WRONG_SOA_RECORD_TCP           |WARNING| ns, , domain_found, domain_expected | Nameserver {ns} responds with a wrong owner name ({domain_found} instead of {domain_expected}) on SOA queries over TCP.

      The value in the Level column is the default severity level of the message. The
      severity level can be changed in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].
      ## Test procedure

      In this section and unless otherwise specified below, the term "[DNS Query]"
      follows the specification for DNS queries as specified in
      [DNS Query and Response Defaults]. The handling of the DNS responses on the DNS
      queries follow, unless otherwise specified below, what is specified for
      [DNS Response] in the same specification.

      1. Create [DNS Queries][DNS Query]:
         1. Query type SOA and query name *Child Zone* over TCP ("SOA Query TCP").
         1. Query type NS and query name *Child Zone* over TCP ("NS Query TCP").

      2. Obtain the set of name server IP addresses using [Method4] and [Method5]
         ("Name Server IP").

      3. For each name server in *Name Server IP* do:

         1. Send *SOA Query TCP* and *NS Query TCP* to the name server and collect
            the [DNS Responses][DNS Response].
         2. If there is no DNS response on neither query, then:
            1. Output *[CN02_NO_RESPONSE_TCP]* with name and IP address of the name
               server.
            2. Go to next name server.
         3. Else:
            1. Process the response on *SOA Query TCP*:
               1. If there is no [DNS response], then output
                  *[CN02_NO_RESPONSE_SOA_QUERY_TCP]* with name and IP address of the
                  name server.
               2. Else, if [RCODE Name] is not "NoError" then output
                  *[CN02_UNEXPECTED_RCODE_SOA_QUERY_TCP]* with [RCODE Name] and name
                  and IP address of the name server.
               3. Else, if there is no SOA record in the answer section, then
                  output *[CN02_MISSING_SOA_RECORD_TCP]* with name and IP address of
                  the name server.
               4. Else, if the SOA record has owner name other than *Child Zone*
                  then output *[CN02_WRONG_SOA_RECORD_TCP]* with name and IP address of
                  the name server, the SOA record owner name and *Child Zone*.
               5. Else, if AA flag is unset, then output *[CN02_SOA_RECORD_NOT_AA_TCP]*
                  with name and IP address of the name server.
            2. Process the response on *NS Query TCP*:
               1. If there is no [DNS Response], then output
                  *[CN02_NO_RESPONSE_NS_QUERY_TCP]* with name and IP address of the
                  name server.
               2. Else, if [RCODE Name] is not "NoError" then output
                  *[CN02_UNEXPECTED_RCODE_NS_QUERY_TCP]* with [RCODE Name] and name and
                  IP address of the name server.
               3. Else, if there is no NS record in the answer section, then
                  output *[CN02_MISSING_NS_RECORD_TCP]* with name and IP address of the
                  name server.
               4. Else, if the NS record has owner name other than *Child Zone*
                  then output *[CN02_WRONG_NS_RECORD_TCP]* with name and IP address of
                  the name server, the NS record owner name and *Child Zone*.
               5. Else, if AA flag is unset, then output *[CN02_NS_RECORD_NOT_AA_TCP]*
                  with name and IP address of the name server.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, skip sending queries over that
      transport protocol.
  dns-connectivity03:
    Summary: Verify that all nameservers do not belong to the same AS
    Description: |
      The objective in this test is to verify that all IP addresses of the domain's
      authoritative name servers are announced from different ASNs (autonomous system
      number). See [RFC 1930] and [Wikipedia] for an explanation of AS (autonomous
      system).

      This test is done separately on IPv4 and IPv6, and both must match the criterion.

      [RFC 2182][RFC 2182#3.1], section 3.1, clearly specifies that distinct authoritative
      name servers for a child domain should be placed in different topological and
      geographical locations. The objective is to minimise the likelihood of a single
      failure disabling all of them.
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      * "ASN Database" - The database of ASN data to be used. Possible values
        are "RIPE" and "Cymru" (the default value).
      * "Cymru Base Name" - If the *ASN Database* is "Cymru", the default value
        is "asnlookup.zonemaster.net".
      * "Ris Whois Server" - If the *ASN Database* is "RIPE", the default value
        is "riswhois.ripe.net".
      ## Ordered description of steps to be taken to execute the test case

      1. Obtain the total set of IP addresses of the name servers for the
         *Child Zone* using [Method4] and [Method5] and split those IP addresses
         into one set of IPv4 addresses ("NS IPv4") and one set of IPv6 addresses
         ("NS IPv6"). (One of two sets may be empty.)

      2. For each IP address in the set *NS IPv4* and *NS IPv6*, respectively,
         determine the ASN set announcing the IP address using either the
         *[Cymru database]* or the *[RIPE database]* as described in separate
         sections below. Create two sets of ASN data ("NS IPv4 ASN" and
         "NS IPv6 ASN", respectively).

      3. Analyze the *NS IPv4 ASN* set:
         1. If *NS IPv4 ASN* is empty (no IPv4 address) do nothing.
         2. Else, if all IPv4 addresses are announced from one and the same ASN, output
            *[IPV4_ONE_ASN]*.
         3. Else, if all IPv4 addresses are announced from the same set of multiple
            ASNs, output *[IPV4_SAME_ASN]*.
         4. Else, output *[IPV4_DIFFERENT_ASN]*.

      4. Analyze the *NS IPv6 ASN* set:
         1. If *NS IPv6 ASN* is empty (no IPv6 address) do nothing.
         2. Else, if all IPv6 addresses are announced from one and the same ASN, output
            *[IPV6_ONE_ASN]*.
         3. Else, if all IPv6 addresses are announced from the same set of multiple
            ASNs, output *[IPV6_SAME_ASN]*.
         4. Else, output *[IPV6_DIFFERENT_ASN]*.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one
      message with the severity level ERROR or CRITICAL.

      The outcome of this Test Case is "warning" if there is at least
      one message with the severity level WARNING, but no message with
      severity level ERROR or CRITICAL.

      In other cases the outcome of this Test Case is "pass".

      Message            |Default severity level
      :------------------|:------------
      EMPTY_ASN_SET      |ERROR
      ERROR_ASN_DATABASE |ERROR
      IPV4_ONE_ASN       |WARNING
      IPV4_SAME_ASN      |NOTICE
      IPV4_DIFFERENT_ASN |INFO
      IPV6_ONE_ASN       |WARNING
      IPV6_SAME_ASN      |NOTICE
      IPV6_DIFFERENT_ASN |INFO

      ## Special procedural requirements

      This test case is dependent on one of two possible services that can provide
      ASN lookup, RIPE or Cymru. The service must be available over the network.
      ### Cymru ASN lookup

      The Cymru lookup method is described on the Team Cymru [IP to ASN Mapping]
      using DNS lookup.

      1. Prepend the *Cymru Base Name* with the label "origin" (IPv4) or
         "origin6" (IPv6). Example of expanded basenames
         ("expanded base name"):

      ```
      origin.asnlookup.zonemaster.net
      origin6.asnlookup.zonemaster.net
      ```

      2. Reverse the IP address with the same method as is used for
         reverse lookup. For description see [RFC 1035][RFC 1035#3.5], section 3.5,
         for IPv4 and [RFC 3596][RFC 3596#2.5], section 2.5, for IPv6.

      3. Prepend the *expanded base name* with the reversed IP address. For
         description see [IP to ASN Mapping].

      4. Send a DNS query for the TXT record of the full name created in step 3.

      5. If either the DNS response has RCODE "NXDOMAIN" or the DNS response
         has RCODE "NOERROR" but empty answer section, output
         *[EMPTY_ASN_SET]* and end these steps for Cymru look-up of the specific
         IP address.

      6. If there is no response (timeout) or the DNS response does not have
         the RCODE "NOERROR", output *[ERROR_ASN_DATABASE]* and
         end these steps for Cymru look-up of the specific IP address.

      8. The expected response is a non-empty string in the TXT record or
         records. See [IP to ASN Mapping] for examples.

      9. Do the following:

         1. Split the string or strings into fields.
         2. If there are multiple strings (TXT records), ignore all strings
            except for the string with the most specific subnet.
         3. Extract the ASN or ASNs.
         4. If it was not possible to extract the ASN or ASNs, output
            *[ERROR_ASN_DATABASE]* and end these steps for Cymru look-up of
            the specific IP address (the response was malformed).

      10. Create the ASN set, for the IP address, from the ASN or ASNs from
          the steps above and use it for the further processing.

      ### RIPE ASN lookup

      The RIPE ASN lookup is described on the RIPE [RISwhois] page.

      1. Construct a query string by prepending the IP adress with
         " -F -M ". Using "192.0.2.10" as an example, the query string will
         be the following (the leading space is intentional)

         ```
         " -F -M 192.0.2.10"
         ```

      2. Send the query string to the *Ris Whois Server* on port
         43 with the nicname (whois) protocol. Example of command
         line command on unix:

      ```
      whois -h riswhois.ripe.net " -F -M 192.0.2.10"
      ```

      3. Do the following:
         1. The non-empty line not prepended with "%" contains the string
            with data (no or one such line).
         2. Check if there is no string with data (empty reply). If so,
            output *[EMPTY_ASN_SET]* and end these steps for RIPE look-up
            of the specific IP address.
         3. If there is no response from the *Ris Whois Server*, output
            *[ERROR_ASN_DATABASE]* and end these steps for RIPE look-up
            of the specific IP address.
         4. The first field has the ASN or list of ASNs. Split that into ASNs.
         5. If it was not possible to extrac the ASN or ASNs, output
            *[ERROR_ASN_DATABASE]* and end these steps (the response was
            malformed).

      8. Create the ASN set, for the IP address, from the ASN or ASNs from
         the steps above and use it for the further processing.
  dns-connectivity04:
    Summary: Verify that name servers are not announced in the same IP prefix
    Description: |
      The objective in this Test Case is to verify that all IP addresses of the domain's
      authoritative name servers are announced from different IP prefixes.

      This Test is done separately on IPv4 and IPv6, and both must match the criterion.

      [RFC 2182, section 3.1][RFC 2182#3.1], clearly specifies that distinct authoritative
      name servers for a child domain should be placed in different topological and
      geographical locations. The objective is to minimise the likelihood of a single
      failure disabling all of them.

      ## Scope

      It is assumed that *Child Zone* is also tested and reported by [Connectivity01].
      This Test Case will just ignore non-responsive name servers or name servers not
      giving a correct DNS response for an authoritative name server.

      ## Inputs

      * "Child Zone" - The domain name to be tested.
      * "Prefix Database" - The database of IP Prefix data to be used. Possible values
        are "RIPE" and "Cymru" (the default value).
      * "Cymru Base Name" - If the *Prefix Database* is "Cymru", the default value
        is "asnlookup.zonemaster.net".
      * "RIS Whois Server" - If the *Prefix Database* is "RIPE", the default value
        is "riswhois.ripe.net".

      ## Summary

      Message Tag                 | Level   | Arguments                   | Message ID for message tag
      :---------------------------|:--------|:----------------------------|:------------------------------------------------------------------------------------------------
      CN04_EMPTY_PREFIX_SET       | ERROR   | ns_ip                       | Prefix database returned no information for IP address {ns_ip}.
      CN04_ERROR_PREFIX_DATABASE  | ERROR   | ns_ip                       | Prefix database error. No data to analyze for IP address {ns_ip}.
      CN04_IPV4_SAME_PREFIX       | WARNING | ns_list, ip_prefix          | The following name server(s) are announced in the same IPv4 prefix ({ip_prefix}): "{ns_list}"
      CN04_IPV4_DIFFERENT_PREFIX  | INFO    | ns_list                     | The following name server(s) are announced in unique IPv4 prefix(es): "{ns_list}"
      CN04_IPV6_SAME_PREFIX       | WARNING | ns_list, ip_prefix          | The following name server(s) are announced in the same IPv6 prefix ({ip_prefix}): "{ns_list}"
      CN04_IPV6_DIFFERENT_PREFIX  | INFO    | ns_list                     | The following name server(s) are announced in unique IPv6 prefix(es): "{ns_list}"

      The value in the Level column is the default severity level of the message. The
      severity level can be changed in the [Zonemaster-Engine Profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [Argument List].

      ## Test procedure

      1. Create the following empty sets:
         1. Name server name and IP address ("NS IPv4")
         2. Name server name and IP address ("NS IPv6")
         3. IP prefix, name server name and IP address ("IPv4 Prefix")
         4. IP prefix, name server name and IP address ("IPv6 Prefix")

      2. Obtain the set of name server names and IP addresses using [Method4]
         and [Method5] ("Name Servers").

      3. For each name server IP address in *Name Servers* do:
         1. Add IPv4 addresses with name server name to the *NS IPv4* set.
         2. Add IPv6 addresses with name server name to the *NS IPv6* set.

      4. For each IP address in *NS IPv4* and *NS IPv6* ("NS IP Address"),
         respectively, do:
         1. Determine the IP prefix in which *NS IP Address* is announced
            using *Prefix Database*. See [Prefix Lookup Methods] section below.
         2. Add found IP prefix, if any, with *NS IP Address* and name server name
            to the *IPv4 Prefix* and *IPv6 Prefix* sets, respectively.

      5. If the *IPv4 Prefix* set is non-empty, then do:
         1. For each IP prefix in the set that has two or more members, output
            *[CN04_IPV4_SAME_PREFIX]* with the prefix and list of all members
            (name server names and IP addresses) for that prefix.
         2. For all IP prefixes in the set that have exactly one member, output
            *[CN04_IPV4_DIFFERENT_PREFIX]* with the combined set of their associated
            members (name server names and IP addresses).

      6. If the *IPv6 Prefix* set is non-empty, then do:
         1. For each IP prefix in the set that has two or more members, output
            *[CN04_IPV6_SAME_PREFIX]* with the prefix and list of all members
            (name server names and IP addresses) for that prefix.
         2. For all IP prefixes in the set that have exactly one member, output
            *[CN04_IPV6_DIFFERENT_PREFIX]* with the combined set of their associated
            members (name server names and IP addresses).

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      This Test Case is dependent on one of two possible services that can provide
      ASN lookup (Cymru or RIPE RIS). The service must be available over the network.

      The *Child Zone* must be a valid name meeting
      "[Requirements and normalization of domain names in input]".

      ## Prefix lookup methods

      Use the prefix method set in *Prefix Database* in "Inputs" and refer to
      the appropriate section below.

      ### Cymru prefix lookup

      The Cymru prefix lookup is described on the Team Cymru [IP to ASN Mapping]
      using DNS lookup.

      1. Prepend the *Cymru Base Name* with the label "origin" (IPv4) or
         "origin6" (IPv6) ("Expanded Base Name"). Example of expanded basenames :

      ```
      origin.asnlookup.zonemaster.net
      origin6.asnlookup.zonemaster.net
      ```

      2. Reverse the IP address with the same method as is used for
         reverse lookup ("Reverse IP"). For description see [RFC 1035][RFC 1035#3.5],
         section 3.5, for IPv4 and [RFC 3596][RFC 3596#2.5], section 2.5, for IPv6.

      3. Prepend the *Expanded Base Name* with *Reverse IP* ("Query Name").
         See [IP to ASN Mapping] for details.

      4. Create a [DNS Query] with query type TXT and query name *Query Name*.
         ("TXT Query").

      5. [Send] *TXT Query* to the *Cymru Base Name*.

      6. If at least one of the following criteria is met, output
         *[CN04_EMPTY_PREFIX_SET]* and exit this lookup:
         1. The [DNS Response] has the [RCODE Name] NXDomain.
         2. The [DNS Response] has the [RCODE Name] NoError and an empty answer section.

      7. If at least one of the following criteria is met, output
         *[CN04_ERROR_PREFIX_DATABASE]* and exit this lookup:
         1. There is no DNS response.
         2. The [DNS Response] does not have the [RCODE Name] NoError or NXDomain.

      8. Extract the TXT record(s) from the response (see [IP to ASN Mapping]
         for examples), and do:
         1. If there are multiple strings (i.e., TXT records), ignore all strings
            except for the string with the most specific subnet.
         2. Extract and [concatenate] the IP prefix from the string.
         3. If it was not possible to extract the IP prefix (i.e., malformed response),
            output *[CN04_ERROR_PREFIX_DATABASE]* and exit this lookup.

      9. Return the IP prefix.

      ### RIPE prefix lookup

      The RIPE Prefix lookup is described on the RIPE [RISwhois] page.

      1. Create a query string by prepending the IP address with
         " -F -M " ("WHOIS String"). E.g., using IP address "192.0.2.10":

         ```
         " -F -M 192.0.2.10"
         ```

      2. Create a WHOIS query (port 43 with the nicname ((whois)) protocol)
         using the *WHOIS String* ("WHOIS Query"). E.g., on Linux:

      ```
      whois -h riswhois.ripe.net " -F -M 192.0.2.10"
      ```

      3. [Send] *WHOIS Query* to the *RIS Whois Server*.

      4. If there is no response, output *[CN04_ERROR_PREFIX_DATABASE]* and exit this lookup.

      5. Extract the string (non-empty line not prepended with "%") from the response, and do:
         1. If there is no such string, output *[CN04_EMPTY_PREFIX_SET]* and exit this lookup.
         2. Extract the IP prefix from the second field of the string.
         3. If it was not possible to extract the IP prefix (i.e., malformed response),
            output *[CN04_ERROR_PREFIX_DATABASE]* and exit this lookup.

      6. Return the IP prefix.
  dns-consistency01:
    Summary: Query all nameservers for SOA, and verify that they all have the same SOA serial number
    Description: |
      For the data served by the authoritative name servers for a designated zone
      to be consistent, all authoritative name servers must serve the same SOA
      record for the designated zone.

      If the serial number (explained in 3.3.13. of [RFC 1035]),
      which is part of the SOA record, is not consistent between authoritative servers,
      there is a possibility that the data served is inconsistent. The reasons for this
      inconsistency may be different - such as misconfiguration, or as a result of slow
      propagation to the secondary name servers.

      The objective of this test is to verify that the serial number is consistent
      between different authoritative name servers.

      For reference purposes : [RFC 1982]
      explains the serial number arithmetic, and section 4.3.5 of
      [RFC 1034] explains the importance of
      serial number consistency.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * "Child Zone" - The domain name to be tested
      * "Accepted Serial Difference" - Accepted difference between SOA serial
        values from SOA records of different name servers for *Child Zone*.
        Default value is 0, i.e. no difference.

      ## Ordered description of steps to be taken to execute the test case

      1. Obtain the list of name server IPs for the *Child Zone* from [Method4]
          and [Method5] ("Name Server IP").

      2. Create an SOA query for *Child Zone* name (the top of the zone).

      3. Create an empty set of pair of retrieved SOA serials and name server
         name and IP ("SOA Serial Set").

      3. For each name server in *Name Server IP* do:

          1. Send the SOA query to the name server.

          2. If the name server does not respond with a DNS response, then
             output *[NO_RESPONSE]*.

          3. Or, if the name server returns a DNS response, but no SOA
             record is included, then output *[NO_RESPONSE_SOA_QUERY]*.

          4. Or, retrieve the SOA SERIAL from the response and add it to
             *SOA Serial Set* (unless it is already there) and update the set
             with the name server name and IP.

      4. If *SOA Serial Set* has exactly one SOA serial value, then output
         *[ONE_SOA_SERIAL]*.

      5. Or, if *SOA Serial Set* has at least two SOA serials values, then do:
          1. Order the serial number values from *SOA Serial Set* from smallest
             to largest following the arithmetic for serial number, if possible.
          2. If there is not a single, uniquely defined order of the serial
             numbers, then output *[SOA_SERIAL_VARIATION]* and
             *[MULTIPLE_SOA_SERIALS]*.
          3. Or, if the difference between the first and the last serial number
             is larger than *Accepted Serial Difference*, using arithmetic
             for serial number, then output *[SOA_SERIAL_VARIATION]* and
             *[MULTIPLE_SOA_SERIALS]*.
          4. Or, if the difference between the first and the last serial number
             is not larger than *Accepted Serial Difference*, using arithmetic
             for serial number, output *[MULTIPLE_SOA_SERIALS_OK]*.

      6. For each SOA serial value in *SOA Serial Set*, output *[SOA_SERIAL]*
         with the serial number and a semicolon separated list of name server
         names and IP address pairs (name/IP).
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                       | Default severity level (if message is emitted)
      :-----------------------------|:-----------------------------------
      NO_RESPONSE                   | DEBUG
      NO_RESPONSE_SOA_QUERY         | DEBUG
      ONE_SOA_SERIAL                | INFO
      MULTIPLE_SOA_SERIALS          | WARNING
      MULTIPLE_SOA_SERIALS_OK       | NOTICE
      SOA_SERIAL                    | INFO
      SOA_SERIAL_VARIATION          | NOTICE

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      A manual inspection of the SOA serial may be needed to determine if the zone
      updates work properly or not, and if the serial values are within a
      reasonable range, then the test is OK.

      When comparing SOA serial it must be done using the arithmetic defined in
      [RFC 1982].
  dns-consistency02:
    Summary: Query all nameservers for SOA, and verify that they all have the same SOA rname
    Description: |
      All authoritative name servers must serve the same SOA record for the
      tested domain  (section 4.2.1 of [RFC 1034]). As per section 3.3.13 of [RFC 1035],
      the RNAME field in the SOA RDATA refers to the administrative contact. An inconsistency in
      the administrative contact for the domain might result in operational
      failures being reported to different persons.

      The objective of this test is to verify that the administrative contact is
      consistent between different authoritative name servers.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * The domain name to be tested ("Child Zone")

      ## Ordered description of steps to be taken to execute the test case

       1. Obtain the list of name server IPs for the *Child Zone* from [Method4]
          and [Method5].
       2. Create an SOA query for *Child Zone* apex and send it to all name
          server IPs.
       3. Retrieve the SOA RR from the responses from all name server IPs.
       4. If a name server does not respond, emit *[NO_RESPONSE]*.
       5. If a name server responds but does not include a SOA record
          in the response, emit *[NO_RESPONSE_SOA_QUERY]*.
       6. If at least one SOA record has been retrieved and RNAME is
          identical in all SOA records, emit *[ONE_SOA_RNAME]*.
       7. If RNAME is not identical in all SOA records, emit
          *[MULTIPLE_SOA_RNAMES]*.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                       | Default severity level (if message is emitted)
      :-----------------------------|:-----------------------------------
      NO_RESPONSE                   | DEBUG
      NO_RESPONSE_SOA_QUERY         | DEBUG
      ONE_SOA_RNAME                 | INFO
      MULTIPLE_SOA_RNAMES           | NOTICE

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.
  dns-consistency03:
    Summary: Query all nameservers for SOA, and verify that they all have the same time parameters (REFRESH/RETRY/EXPIRE/MINIMUM)
    Description: |
      All SOA record timer fields must be consistent across all authoritative
      name servers. An inconsistency in these fields might result in operational
      inconsistencies for the designated zone.

      There are other test cases that provide consistency tests for the other
      SOA fields:

      * [CONSISTENCY01] (SOA Serial)
      * [CONSISTENCY02] (RNAME)
      * [CONSISTENCY06] (MNAME)

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * The domain name to be tested ("Child Zone").

      ## Ordered description of steps to be taken to execute the test case

       1. Create an SOA query for *Child Zone* apex.

       2. Obtain the list of name server IPs for the *Child Zone* from [Method4]
          and [Method5].

       3. Send the SOA query to all name server IPs.

       4. If a name server does not respond, emit *[NO_RESPONSE]*.

       5. If a name server responds but no SOA record is included in the
          response, emit *[NO_RESPONSE_SOA_QUERY]*.

       6. Retrieve the SOA RR from the responses from all name server IPs.

       7. Emit *[ONE_SOA_TIME_PARAMETER_SET]* if at least one SOA record has
          been retrieved and all SOA records have:
          1. the same REFRESH value,
          2. the same RETRY value,
          3. the same EXPIRE value, and
          4. the same MINIMUM value.

       8. Emit *[MULTIPLE_SOA_TIME_PARAMETER_SET]* if any two SOA
          records had different values in previous step.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                          | Default severity level (if message is emitted)
      :--------------------------------|:-----------------------------------
      NO_RESPONSE                      | DEBUG
      NO_RESPONSE_SOA_QUERY            | DEBUG
      ONE_SOA_TIME_PARAMETER_SET       | INFO
      MULTIPLE_SOA_TIME_PARAMETER_SET  | NOTICE

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.
  dns-consistency04:
    Summary: Query all nameservers for the NS set, and verify that they have all the same content
    Description: |
      All authoritative name servers must serve the same NS record set
      for the tested domain, child zone ([RFC 1034], section 4.2.2).
      Any inconsistencies in NS records described in [RFC 1035],
      section 3.3.11, might result in operational failures.

      The objective of this test is to verify that the NS records are
      consistent between all authoritative name servers of the child zone.

      Two NS RR sets are considered to be equal if both sets have the
      same number of NS records, and for each NS record in one of the
      sets there is exactly one NS record with identical owner name,
      class, TTL and RDATA in the other NS set.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * The domain name to be tested ("Child Zone").

      ## Ordered description of steps to be taken to execute the test case

      1. Obtain the set of name server IPs for the *Child Zone* using
         [Method4] and [Method5].

      2. Create an NS query for the apex of the *Child Zone*.

      3. Send the NS query to each of the retrieved name server IPs.

      4. If a name server IP does not respond, emit *[NO_RESPONSE]*.

      5. If the response from a name server IP does not include an
         NS RR set for the *Child Zone* with the AA flag set, emit
         *[NO_RESPONSE_NS_QUERY]*.

      6. If all retreived NS RR sets are equal, emit *[ONE_NS_SET]*. Otherwise,
         emit *[MULTIPLE_NS_SET]*.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                       | Default severity level (if message is emitted)
      :-----------------------------|:-----------------------------------
      NO_RESPONSE                   | DEBUG
      NO_RESPONSE_NS_QUERY          | DEBUG
      ONE_NS_SET                    | INFO
      MULTIPLE_NS_SET               | NOTICE

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.
  dns-consistency05:
    Summary: Verify that the glue records are consistent with authoritative data
    Description: |
      For name servers that have IP addresses listed as glue, the IP addresses must
      match the authoritative A and AAAA records for that host. This is an IANA
      [name server requirement].

      The objective of this test is to verify that the [glue records][terminology]
      in the delegation are consistent with authoritative data.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * "Child Zone" - The domain name to be tested.

      ## Ordered description of steps to be taken to execute the test case
      1. Obtain the set of name server names from the NS records in the
         delegation of *Child Zone* using [Method2] and any glue IP addresses
         from the same delegation using [Method4].

         1. Extract the [in-bailiwick][terminology] name server names and create the set
            "Delegation Strict Glue", where each name server name
            is matched with its IP address or addresses, if available. (The
            set may be empty.)

         2. Extract the [out-of-bailiwick][terminology] name server names and create the
            set "Delegation Extended Glue", where each name server name
            is matched with its IP address or addresses, if available. (The
            set may be empty.)

      2. Obtain the set of name server names for the *Child Zone* using
         [Method2] and [Method3] and extract the [in-bailiwick][terminology] name
         server names, "IB NS Name Set". (The set may be empty.)

      3. Create an empty set of name server name with associated IP address
         or addresses, "Address Records From Child".

      4. If *IB NS Name Set* is non-empty, obtain the set of name server IP
         addresses, "NS IP", for *Child Zone* using [Method4] and [Method5].

      5. If *IB NS Name Set* is non-empty, then for each name server name in
         that set do:

         1. Create one A query and one AAAA query with the RD flag unset
            and name server name as owner name.

         2. For each name server in *NS IP* and for each record
            types (A, AAAA):
            1. Send the address query to the name server.
            2. If there is no DNS response from the server, then
               output *[NO_RESPONSE]*.
            3. Or, if the response is a delegation (referral) to a
               sub-zone of *Child Zone*, then:
               1. Copy the adress query (A, AAAA) that gave the referral
                  response.
               2. Set the RD flag in the copied query (from unset to set).
               3. Do a [DNS Lookup][terminology] of the the query.
               4. If the lookup returns the relevant address record or records,
                  A for A record query and AAAA for AAAA record query, and
                  with the same owner name as in the query (i.e. CNAME should
                  not be followed), then extract those and add to
                  *Address Records From Child* with name and IP
                  address or addresses.
            4. Or, if the response has the AA flag unset, then
               output *[CHILD_NS_FAILED]*.
            5. Or, if the RCODE of the response is neither NOERROR nor
               NXDOMAIN, then output *[CHILD_NS_FAILED]*.
            6. Or, if the RCODE is NOERROR (with the AA flag set), then
               extract any address records (A, AAAA) from the answer
               section whose owner name matches the owner name
               of the query (i.e. CNAME should not be followed) and add
               that or those to *Address Records From Child* with name and IP.
            7. Else, there is nothing to do (i.e. RCODE is NXDOMAIN).

         3. If all servers outputted *[NO_RESPONSE]* or *[CHILD_NS_FAILED]*,
            then output *[CHILD_ZONE_LAME]* and completely stop processing
            this test case.

      6. Compare the IP address for the name servers from
         *Delegation Strict Glue* with *Address Records From Child*
         (i.e. [in-bailiwick][terminology] only).

         1. If an IP from *Delegation Strict Glue* is not listed in
            *Address Records From Child* with that same name server name,
            then output *[IN_BAILIWICK_ADDR_MISMATCH]*.

         2. If an IP from *Address Records From Child* is not listed in
            *Delegation Strict Glue* with that same name server name, then
            output *[EXTRA_ADDRESS_CHILD]*.

      7. For each name server name in *Delegation Extended Glue*
         (i.e. [out-of-bailiwick][terminology] only) ("DEG Name Server Name") do:

         1. Do two [DNS Lookups][terminology], one record type A and one record type
            AAAA, for *DEG Name Server Name* on public DNS and create a
            set of the IP addresses from the A and AAAA records, respectively,
            from the answer sections of the responses and that matches
            the owner name of the query (i.e. CNAME should not be followed).
            (The set will be empty if there are no relevant records in the
            answer sections or if there is no response, e.g. SERVFAIL.)

         2. For each IP address for *DEG Name Server Name* in
            *Delegation Extended Glue* do:
            1. If the address is not member of the IP address set created
               in the previous DNS lookups, output
               *[OUT_OF_BAILIWICK_ADDR_MISMATCH]*.

      8. If none of *[IN_BAILIWICK_ADDR_MISMATCH]*, *[EXTRA_ADDRESS_CHILD]*
         or *[OUT_OF_BAILIWICK_ADDR_MISMATCH]* has been outputted, output
         *[ADDRESSES_MATCH]*.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      The outcome of this Test case is "pass" in all other cases.

      Message                           | Default severity level (when message is outputted)
      :---------------------------------|:-----------------------------------
      CHILD_NS_FAILED                   | DEBUG
      NO_RESPONSE                       | DEBUG
      CHILD_ZONE_LAME                   | ERROR
      IN_BAILIWICK_ADDR_MISMATCH        | ERROR
      OUT_OF_BAILIWICK_ADDR_MISMATCH    | ERROR
      EXTRA_ADDRESS_CHILD               | NOTICE
      ADDRESSES_MATCH                   | INFO

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol and log a message reporting
      the ignored result.

      If the test is an [undelegated test] then [Method2] and [Method4] will
      include the provided input data instead of data from any real delegation
      and authoritative data.

      For an [undelegated test] it is possible to intentionally insert data
      for [out-of-bailiwick][terminology] name servers that do not match what is found in
      public DNS. This Test Case will then report this as an ERROR which
      may not match the users expectation.

      It is assumed that the name servers of the parent zone behave the same way
      for the parent zone as when [BASIC01] was run.

      ## Terminology

      The terms "in-bailiwick" and "out-of-bailiwick" are used as defined
      in [RFC 7719], section 6, page 15.

      The term "glue records" is defined in [RFC 7719], section 6, page 15.
      Here we use "glue" in the wider sense.

      When the term "using Method" is used, names and IP addresses are fetched
      using the defined [Methods].

      The term "send" (to an IP address) is used when a DNS query is sent to
      a specific name server.

      The term "DNS Lookup" is used when a recursive lookup is used, though
      any changes to the DNS tree introduced by an [undelegated test] must be
      respected.
  dns-consistency06:
    Summary: Query all nameservers for SOA, and verify that they all have the same SOA mname
    Description: |
      All authoritative name servers must serve the same SOA record (section
      4.2.1) of [RFC 1034] for the tested domain. As per section 3.3.13 of
      [RFC 1035] the MNAME field in the SOA RDATA refers to the name of
      "the name server that was the original or primary source of data
      for this zone". Inconsistency in MNAME of the domain might result in
      operational failures for applications that uses MNAME.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * "Child Zone" - The domain name to be tested.

      ## Ordered description of steps to be taken to execute the test case

       1. Obtain the set of name server IPs for the *Child Zone* from [Method4]
          and [Method5] ("Name Server IP").

       2. Create an SOA query for *Child Zone* apex.

       3. For each name server in *Name Server IP* do:

          1. Send the query to name server.
          2. If the name server does not respond with a DNS response,
             emit *[NO_RESPONSE]* for that name server and go to next server.
          3. If the DNS response does not include a SOA record in the answer
             section then emit *[NO_RESPONSE_SOA_QUERY]* for that server and go
             to next server.
          4. Retrieve the MNAME field from the SOA RR from the DNS response
             and save that to compare it with the MNAME from the other name
             servers.

       4. Compare the MNAME fields retreived from all name servers.

       5. If at least one name server has responded with a SOA record and the
          MNAME is identical in all SOA records retrieved, emit *[ONE_SOA_MNAME]*.

       6. If MNAME is not identical in all SOA records retrieved, emit
          *[MULTIPLE_SOA_MNAMES]*.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                       | Default severity level (if message is emitted)
      :-----------------------------|:-----------------------------------
      NO_RESPONSE                   | DEBUG
      NO_RESPONSE_SOA_QUERY         | DEBUG
      ONE_SOA_MNAME                 | INFO
      MULTIPLE_SOA_MNAMES           | NOTICE

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.
  dns-delegation01:
    Summary: Verify that there are more than two nameservers
    Description: |
      Section 4.1 of [RFC 1034] specifies that there must be a minimum of two name servers
      for a domain. This test is done to verify this condition.

      The RFC ([RFC 1034]) predates IPv6. Since IPv4 and IPv6 work as separate networks, this
      test case has been extended to test for two name servers that resolve into IPv4 addresses
      and IPv6 addresses respectively.

      Both [RFC 3901] (section 3) and [RFC 4472] (section 1.3) states that a domain
      (zone) should be available over IPv4 for the time being. Therefore, it is by the
      default level in this test case considered to be more problematic not being available
      over IPv4 than not being available over IPv6.

      ## Inputs

      "Child Zone" - The domain name to be tested

      ## Ordered description of steps to be taken to execute the test case

       1. Using [Method2], obtain the complete set of names of the name servers
          from the delegation of the *Child Zone*.

       2. Count the name server names:
          1. If zero or one, emit *[NOT_ENOUGH_NS_DEL]*.
          2. If two or more, emit *[ENOUGH_NS_DEL]*.

       3. Using [Method4], obtain the IP addresses for the name servers of the
          delegation of the *Child Zone*.

       4. Count the number of name server names that resolve into at least one IPv4
          address:
          1. If zero, emit *[NO_IPV4_NS_DEL]*.
          2. If one, emit *[NOT_ENOUGH_IPV4_NS_DEL]*.
          3. If two or more, emit *[ENOUGH_IPV4_NS_DEL]*.

       5. Count the number of name server names that resolve into at least one IPv6
          address:
          1. If zero, emit *[NO_IPV6_NS_DEL]*.
          2. If one, emit *[NOT_ENOUGH_IPV6_NS_DEL]*.
          3. If two or more, emit *[ENOUGH_IPV6_NS_DEL]*.

       6. Using [Method3], obtain the complete set of names of the name servers
          from the *Child Zone* for the *Child Zone*.

       7. Count the name server names:
          1. If zero or one, emit *[NOT_ENOUGH_NS_CHILD]*.
          2. If two or more, emit *[ENOUGH_NS_CHILD]*.

       8. Using [Method5], obtain the IP addresses for the name servers from
          the *Child Zone* for the *Child Zone*.

       9. Count the number of name server names that resolve into at least one IPv4
          address:
          1. If zero, emit *[NO_IPV4_NS_CHILD]*.
          2. If one, emit *[NOT_ENOUGH_IPV4_NS_CHILD]*.
          3. If two or more, emit *[ENOUGH_IPV4_NS_CHILD]*.

      10. Count the number of name server names that resolve into at least one IPv6
          address:
          1. If zero, emit *[NO_IPV6_NS_CHILD]*.
          2. If one, emit *[NOT_ENOUGH_IPV6_NS_CHILD]*.
          3. If two or more, emit *[ENOUGH_IPV6_NS_CHILD]*.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      Else the outcome of this Test Case is "pass".

      Message                       | Default severity level
      :-----------------------------|:-----------------------------------
      ENOUGH_IPV4_NS_CHILD          | INFO
      ENOUGH_IPV4_NS_DEL            | INFO
      ENOUGH_IPV6_NS_CHILD          | INFO
      ENOUGH_IPV6_NS_DEL            | INFO
      ENOUGH_NS_CHILD               | INFO
      ENOUGH_NS_DEL                 | INFO
      NOT_ENOUGH_IPV4_NS_CHILD      | ERROR
      NOT_ENOUGH_IPV4_NS_DEL        | ERROR
      NOT_ENOUGH_IPV6_NS_CHILD      | ERROR
      NOT_ENOUGH_IPV6_NS_DEL        | ERROR
      NOT_ENOUGH_NS_CHILD           | ERROR
      NOT_ENOUGH_NS_DEL             | ERROR
      NO_IPV4_NS_CHILD              | WARNING
      NO_IPV4_NS_DEL                | WARNING
      NO_IPV6_NS_CHILD              | NOTICE
      NO_IPV6_NS_DEL                | NOTICE
  dns-delegation02:
    Summary: Verify that name servers have distinct IP addresses
    Description: |
      If the domain's name servers use several different names, they can all
      be using the same IP address. This may be due to a configuration error, or
      a workaround for a certain policy restriction. This test case checks that
      the name servers used do not reuse the same IP addresses.

      Section 4.1 of [RFC 1034] says at least two name servers must be used
      for a delegation.

      ## Inputs

      "Child Zone" - The domain name to be tested.

      ## Ordered description of steps to be taken to execute the test case

      1. Obtain the complete set of name server names in the delegation of
         the *Child Zone* using [Method2] and the IP addresses for each name
         using [Method4].

      2. If the same IP address is found for two or more name server names,
         emit *[DEL_NS_SAME_IP]* for each repeated address, else emit
         *[DEL_DISTINCT_NS_IP]*.

      3. Obtain the complete set of name server names from the *Child Zone*
         using [Method3] and the IP addresses for each name using [Method5].

      4. If the same IP address is found for two or more name server names,
         emit *[CHILD_NS_SAME_IP]* for each repeated address, else emit
         *[CHILD_DISTINCT_NS_IP]*.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message               | Default severity level (if message is emitted)
      :---------------------|:-----------------------------------
      DEL_NS_SAME_IP        | ERROR
      CHILD_NS_SAME_IP      | ERROR
      DEL_DISTINCT_NS_IP    | INFO
      CHILD_DISTINCT_NS_IP  | INFO
  dns-delegation03:
    Summary: Verify that there is no truncation on referrals
    Description: |
      The Domain Name System defaults to using UDP for queries and answers with a
      DNS payload limit of 512 octets (bytes). Larger replies cause an initial
      truncation indication leading to a subsequent handling via TCP with
      substantially higher overhead. EDNS0 is used to allow for larger UDP
      responses thus reducing the need for use of TCP.

      But [IANA] still maintains that referrals from the parent zone name servers
      must fit into a non-EDNS0 UDP DNS packet.

      ## Inputs

      * "Child Zone" - The domain name to be tested.

      ## Ordered description of steps to be taken to execute the test case

      1. Create a DNS packet with a maximally long subdomain
         under the *Child Zone* apex (that is, 255 octets including label
         separators) in the Query section.

      2. Obtain the set of name server names from the delegation of
         the *Child Zone* from the parent using [Method2].

      3. For each name server name obtained in the previous step:
         1. Create an NS record with the *Child Zone* apex as owner name
            and the name server name as RDATA.
         2. Add the NS record to the Authority section of the DNS packet
            created above using the message compression schema defined
            in section 4.1.4 of [RFC 1035] where applicable.

      4. Using [Method1], get the parent zone of *Child Zone*.

      5. Obtain the name server IP addresses per name server name for
         the delegation using [Method4].

      6. Make a set of the name server names that resolve into at least one
         IPv4 address ("IPv4 Name Server Set").

      7. If the *IPv4 Name Server Set* is not empty and all name server
         names in it are [In-Bailiwick of Parent] then:
         1. Create an A record using one of the name server names and any
            IPv4 address.
         2. Add the A record to the Additional section of the DNS packet
            created above using the message compression schema defined in
            section 4.1.4 of [RFC 1035].

      8. Make a set of the name server names that resolve into at least one
         IPv6 address ("IPv6 Name Server Set").

      9. If the *IPv6 Name Server Set* is not empty and all name server
         names in it are [In-Bailiwick of Parent] then:
         1. Create a AAAA record using one of the name server names and any
            IPv6 address.
         2. Add the AAAA record to the Additional section of the DNS packet
            created above using the message compression schema defined in
            section 4.1.4 of [RFC 1035].

      10. If the size of the DNS packet after encoding exceeds 512 octets
          then output *[REFERRAL_SIZE_TOO_LARGE]* else output
          *[REFERRAL_SIZE_OK]*.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                           | Default severity level of message
      :---------------------------------|:-----------------------------------
      REFERRAL_SIZE_TOO_LARGE           | WARNING
      REFERRAL_SIZE_OK                  | INFO

      ## Terminology

      The terms "in-bailiwick" and "out-of-bailiwick" are used as defined
      in [RFC 7719], section 6, page 15.

      ## In-Bailiwick of Parent

      A name server name is *In-Bailiwick of Parent* if the name is a or
      below the zone cut of the parent zone. If "example.com" is the parent
      zone of "foofoo.example.com" then name server "ns1.barbar.example.com"
      is *In-Bailiwick of Parent* for "foofoo.example.com".

      All name servers of a TLD are *In-Bailiwick of Parent* since all
      names are below the root apex '.'.

      [RFC 7719]: https://datatracker.ietf.org/doc/html/rfc7719

      [RFC 1035]: https://datatracker.ietf.org/doc/html/rfc1035

      [IANA]: https://www.iana.org/help/nameserver-requirements
  dns-delegation04:
    Summary: Verify that nameservers are authoritative
    Description: |
      Subsection 6.1 of [RFC 2181](https://datatracker.ietf.org/doc/html/rfc2181) specifies
      that the nameservers must answer authoritatively for the domain. Answers
      to queries to the name servers for the designated zone must have the "AA"
      bit set.

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Obtain the complete set of name server address records from the parent using
         [Method4](../Methods.md) and the child using [Method5](../Methods.md).
      2. All the uniquely obtained address records are queried for the SOA record
         over TCP and UDP on port 53.
      3. For each query in step 2, check whether DNS answer (bogus response are not
         checked here) is obtained. If any of the query fails to respond with an
         answer, then do not proceed to step 4 for that query. Exit from the test
         without any exceptions.
      4. If any name server fail to give an authoritative answer ("AA-bit" is set
         in the answer), the test fails.

      ### Outcome(s)

      If all the name servers answer with the AA-bit set, then the test succeeds.

      ### Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.
  dns-delegation05:
    Summary: Verify that NS RRs do not point to CNAMEs
    Description: |
      Name servers for a zone are defined in NS records. An NS record points
      at a name, i.e. the RDATA for an NS record is a domain name. That
      name is the name of the name server. [RFC 2181][RFC 2181#10.3], section
      10.3, states that the name of the name server must not itself point at
      a CNAME.

      The objective of this test is to verify that name servers of the tested
      domain (zone) do not point at CNAME records.

      ## Inputs

      "Child Zone" - The domain name to be tested.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Ordered description of steps to be taken to execute the test case

      1. Obtain the set of name server names using [Method2] and [Method3]
         ("NS Name").

      2. Obtain the set of name server IP addresses using [Method4] and
         [Method5] ("NS IP").

      3. For each name server name in *NS Name* do:

         1. Create a query for A record (A query) with the name server
            name as owner name.

         2. If the name server name is [in-domain] (sub-type of
            [in-bailiwick]) then for each name server IP in
            *NS IP* do:
            1. Send the A query to the name server IP with the RD flag unset.
            2. If the name server does not respond with a DNS response, then
               output *[NO_RESPONSE]*.
            3. Else, if the RCODE is not NOERROR, then output
               *[UNEXPECTED_RCODE]*.
            4. Else, if the answer section of the response includes a CNAME
               record then output *[NS_IS_CNAME]*.
            5. Else, if the response is a delegation (referral) to a
               sub-zone of *Child Zone*, then:
               1. Do a [DNS Lookup] of the A query with the RD
                  flag set.
               2. If the answer section of the response includes a CNAME
                  record then output *[NS_IS_CNAME]*.

         3. Else (the name server name is either [sibling domain]
            or [out-of-bailiwick]) then do:
            1. Do a [DNS Lookup] of the the A query with the RD
               flag set.
            2. If the answer section of the response includes a CNAME
               record then output *[NS_IS_CNAME]*.

      4. If no *[NS_IS_CNAME]* was outputted, then output *[NO_NS_CNAME]*.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message               | Default severity level
      :---------------------|:-----------------------------------
      NO_RESPONSE           | DEBUG
      UNEXPECTED_RCODE      | WARNING
      NS_IS_CNAME           | ERROR
      NO_NS_CNAME           | INFO

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      ## Terminology

      The terms "in-domain", "sibling domain", "in-bailiwick" and
      "out-of-bailiwick" are used as defined in [RFC 8499][RFC 8499#7], section 7
      (p 25), where "in-domain" and "sibling domain" are defined as a sub-types
      of "in-bailiwick".

      The term "DNS Lookup" is used when a recursive lookup is used, though
      any changes to the DNS tree introduced by an [undelegated test] must be
      respected.
  dns-delegation06:
    Summary: Verify existence of SOA
    Description: |
      Section 6.1 of the [RFC 2181](https://datatracker.ietf.org/doc/html/rfc2181) specifies
      that the SOA record is mandatory for every zone.

      This test is intended to verify the prescence of a SOA record for the
      domain.

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Obtain the complete set of name server address records from the parent using
         [Method4](../Methods.md) and the child using [Method5](../Methods.md).
      2. All the uniquely obtained address records are queried for the SOA record.
      3. If there is an answer with NOERROR and there is no content in the
         answer section, this test case fails.

      ### Outcome(s)

      If there is a SOA record present for the domain this test case succeeds.

      ### Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.
  dns-nameserver01:
    Summary: Verify that nameserver does not provide recursive service
    Description: |
      To ensure consistency in DNS, an authoritative name server should not be
      configured to do recursive lookups. Also, open recursive resolvers are
      considered bad internet practice due to their capability of assisting in
      large scale DDoS attacks. The introduction to [RFC 5358] elaborates on
      mixing recursor and authoritative functionality, and the issue is further
      elaborated by [D.J. Bernstein].

      Section 2.5 of [RFC 2870] have very specific requirement on disabling
      recursion functionality on root name servers.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * The domain name to be tested ("Child Zone").

      ## Ordered description of steps to be taken to execute the test case

      1. Create A queries for the following domain names:
         1. xn--nameservertest.iis.se
         2. xn--nameservertest.icann.org
         3. xn--nameservertest.ripe.net

      2. Retrieve all name server IPs for the *Child Zone* using
         [Method4] and [Method5].

      3. Repeat the following steps for each name server IP.
         1. Send the three A queries over UDP.
         2. For each query do the following steps:
            1. If the name server does not respond with a DNS
            	 response, then emit *[NO_RESPONSE]*.
            2. If the DNS response comes with the RA flag set, then
            	 emit *[IS_A_RECURSOR]*.
         3. If the RCODE is NXDOMAIN in the responses for all three
            queries then emit *[IS_A_RECURSOR]*.
         4. If neither *[NO_RESPONSE]* nor *[IS_A_RECURSOR]* has been emitted
            for that server, then emit *[NO_RECURSOR]*.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                       | Default severity level (if message is emitted)
      :-----------------------------|:-----------------------------------
      NO_RESPONSE                   | DEBUG
      IS_A_RECURSOR                 | ERROR
      NO_RECURSOR                   | INFO

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      The domain names used in the queries are selected to be almost certainly
      non-existent name since the names are chosen to violate the
      [IDNA 2008 specification] under SLDs (second-level domains) expected to
      respect that specification. The SLDs are selected so that the chance that
      they are all hosted on the same servers is low.

      ## Terminology

      Valid domain names according to the "IDNA 2008 specification" is found in
      [RFC 5890], section 2.3.1, page 7.
  dns-nameserver02:
    Summary: Verify EDNS0 support
    Description: |
      EDNS(0) is a mechanism to announce capabilities of a DNS implementation,
      and is now basically required by any new functionality in DNS such as
      DNSSEC. EDNS(0) is standardized in [RFC 6891].

      This test case checks that all name servers has the capability to do
      EDNS(0) or if not, correctly replies to queries containing EDNS
      (OPT record).

      Servers not supporting EDNS(0) must return FORMERR
      ([RFC 6891, section 7]):

      > Responders that choose not to implement the protocol extensions
      > defined in this document MUST respond with a return code (RCODE) of
      > FORMERR to messages containing an OPT record in the additional
      > section and MUST NOT include an OPT record in the response.

      Servers supporting EDNS(0) must reply with EDNS(0)
      ([RFC 6891, section 6.1.1]):

      > If an OPT record is present in a received request, compliant
      > responders MUST include an OPT record in their respective responses.

      To eliminating the risk of falsely classifying the server as not supporting
      EDNS due e.g. firewall issues, the UDP buffer size is set to 512 bytes
      (octets).

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * "Child Zone" - The domain name to be tested.

      ## Ordered description of steps to be taken to execute the test case

      1. Created an SOA query for the *Child Zone* with an OPT record with
         EDNS version set to "0" and with EDNS(0) option of payload size ("bufsize")
         set to 512 and "DO" bit unset.

      2. Create a second SOA query for the *Child Zone* without any OPT record.

      3. Obtain the set of name server IP addresses using [Method4] and [Method5]
         ("Name Server IP").

      4. For each name server in *Name Server IP* do:

         1. Send the SOA query **with** OPT record to the name server and collect
            the response.
         2. If there is no DNS response, then:
            1. Send the SOA query **without** OPT record to the name server and
               collect the response.
            2. If there is no DNS response, then output *[NO_RESPONSE]* and
               go to next server.
            3. Else (there is a DNS response), then output
               *[BREAKS_ON_EDNS]* and go to next server.
         3. Else, if the DNS response meet the following two criteria,
            then output *[NO_EDNS_SUPPORT]*:
            1. It has the RCODE "FORMERR"
            2. It has no OPT record.
         4. Else, if the DNS response meet the following criteria (compliant
            server), then go to the next name server:
            1. It has the RCODE "NOERROR".
            2. The answer section contains the SOA record for *Child Zone*.
            3. It has OPT record with EDNS version 0.
         5. Else, if the DNS response meet the following criteria,
            then output *[EDNS_RESPONSE_WITHOUT_EDNS]* and go to next server.
            1. It has the RCODE "NOERROR".
            2. It has no OPT record.
         6. Else, if the DNS response meet the following criteria,
            then output *[EDNS_VERSION_ERROR]* and go to next server.
            1. It has the RCODE "NOERROR".
            2. It has OPT record with EDNS version other than 0.
         7. Else output *[NS_ERROR]* (i.e. other erroneous or unexpected
            response).

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      The outcome of this Test case is "pass" in all other cases.

      Message                           | Default severity level (when message is outputted)
      :---------------------------------|:-----------------------------------
      NO_RESPONSE                       | DEBUG
      NO_EDNS_SUPPORT                   | WARNING
      BREAKS_ON_EDNS                    | ERROR
      EDNS_RESPONSE_WITHOUT_EDNS        | ERROR
      EDNS_VERSION_ERROR                | ERROR
      NS_ERROR                          | WARNING

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol and log a message reporting
      the ignored result.
  dns-nameserver04:
    Summary: Verify that replies from nameserver comes from the expected IP address
    Description: |
      Responses from the authoritative name servers must contain same source IP
      address as the destination IP address of the initial query. This has been
      clarified in section 4 of
      [RFC 2181](https://datatracker.ietf.org/doc/html/rfc2181#section-4).

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case
      1. Retrieve all address records for all the name servers using [Method
         4](../Methods.md) and [Method 5](../Methods.md).
      2. A SOA query for the domain name sent to the each name server IP address
         found in step 1.
      3. Any answer received from the SOA query must come from the same source IP address
         as the query was sent to. If there is a mismatch, this test case fails.

      ### Outcome(s)

      If any response comes from another IP address than the query was sent to,
      this test case fails.

      ### Special procedural requirements

      If there are many authoritative DNS nodes behind the IP adress the query
      is sent to, there could be multiple answers with possibly different source
      addresses for the query. This special case is currently ignored.
  dns-nameserver05:
    Summary: Verify behaviour against AAAA queries
    Description: |
      Older implementations of authoritative name servers have shown different
      misbehaviours trying to answer queries for AAAA records, as described in
      [RFC 4074]. This test case is intended to find out if the name server
      authoritative for the domain shows any of these behaviours.
      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      ## Ordered description of steps to be taken to execute the test case

      1. Create an A query for the apex of the *Child Zone*.

      2. Create a AAAA query for the apex of the *Child Zone*.

      3. Create an empty set "AAAA OK".

      4. Retrieve all name server IP addresses for the
         *Child Zone* using [Method4] and [Method5] ("NS IP").

      5. For each name server IP address in *NS IP* do:

         1. Send the A query over UDP to the name server IP.
         2. If no DNS response is returned, then output *[NO_RESPONSE]*.
         3. Else, if DNS response does not have RCODE NOERROR, then output
            *[A_UNEXPECTED_RCODE]*.
         4. Else, do:
            1. Send the AAAA query over UDP to the name server IP.
            2. If no DNS response is returned, then output *[AAAA_QUERY_DROPPED]*.
            3. Else, if the RCODE of the response is not NOERROR, then output
               *[AAAA_UNEXPECTED_RCODE]*.
            4. Else, if the answer section contains an AAAA record with incorrect
               RDATA lenght (e.g. 4 instead of 16 octets), then output
               *[AAAA_BAD_RDATA]*.
            5. Else, add the name server IP to *AAAA OK*.

      6. If *AAAA OK* is non-empty and no messages *[AAAA_QUERY_DROPPED]*,
         *[AAAA_UNEXPECTED_RCODE]* or *[AAAA_BAD_RDATA]* have been outputted for any
         name server IP, then output *[AAAA_WELL_PROCESSED]*.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                       | Default severity level
      :-----------------------------|:-----------------------------------
      AAAA_BAD_RDATA                | ERROR
      AAAA_QUERY_DROPPED            | ERROR
      AAAA_UNEXPECTED_RCODE         | ERROR
      AAAA_WELL_PROCESSED           | INFO
      A_UNEXPECTED_RCODE            | WARNING
      NO_RESPONSE                   | DEBUG

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.
  dns-nameserver06:
    Summary: Verify that each nameserver can be resolved to an IP address
    Description: |
      All name servers names listed for a delegation must be resolvable in DNS.
      If they are not resolvable using DNS this is a sign of misconfiguration,
      and raises the risk of unreachability for the domain. It could also lower
      the performance for any resolver trying to resolve the name.

      The objective of this test is to resolve the domain using all the listed
      name servers used in the delegation. More information about resolver
      behavior is in section 7 of [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035).

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Obtain the list of name servers for the domain using [Method 2](
         ../Methods.md#method-2-obtain-glue-name-records-from-parent) and [Method 3](
         ../Methods.md#method-3-obtain-name-servers-from-child).
      2. Use [Method 4](
         ../Methods.md#method-4-obtain-glue-address-records-from-parent) and
         [Method 5](
         ../Methods.md#method-5-obtain-the-name-server-address-records-from-child)
         to resolve all the name server names obtained in step 1.
      3. If any name does not resolve to either an A RR or AAAA RR, this test
         case fails.

      ### Outcome(s)

      If any of the name server names fails to resolve to an IP address, this
      test case fails.

      ### Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of
      the result of any test using this transport protocol. Log a message
      reporting on the ignored result.
  dns-nameserver07:
    Summary: Check whether authoritative name servers return an upward referral
    Description: |
      The configuration and/or implementation of some authoritative name servers
      causes them to return an upward referral to the root zone. There are proofs that
      such a [behaviour could be used for DDoS attacks](
      https://www.dns-oarc.net/oarc/articles/upward-referrals-considered-harmful)
      ### Inputs
      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case
      1. If the input domain to be tested is the root, exit from the test.
      2. Retrieve all address records for all the name servers using [Method
         4](../Methods.md) and [Method 5](../Methods.md).
      3. An NS query is sent to each name server IP address found in step 2,
         with the root “.” as the destination
      4. If any of the query returns with one or more responses in the
         authority section, then this test case fails.

      ### Outcome(s)
      The test case is Ok only if there are no responses in the authority section
  dns-nameserver08:
    Summary: Check whether authoritative name servers responses match the case of every letter in QNAME
    Description: |
      The DNS standards require that nameservers treat names with case insensitivity.
      That is, the names example.com and EXAMPLE.COM should resolve to the same IP
      address. However, in the response, most nameservers echo back the name as it
      appeared in the request, preserving the original case.

      Therefore, another way to add entropy to requests is to randomly vary the case
      of letters in domain names queried. This technique, also known as "0x20" because
      bit 0x20 is used to set the case of of US-ASCII letters, was first proposed in
      the [IETF internet draft](https://datatracker.ietf.org/doc/html/draft-vixie-dnsext-dns0x20-00) Use of Bit 0x20 in DNS Labels to Improve Transaction
      Identity. With this technique, the nameserver response must match not only the
      query name, but the case of every letter in the name string; for example,
      wWw.eXaMpLe.CoM or WwW.ExamPLe.COm. This may add little or no entropy to queries
      for the top-level and root domains, but it's effective for most hostnames.

      ### Inputs
      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case
      1. Retrieve all address records for all the name servers using [Method
         4](../Methods.md) and [Method 5](../Methods.md).
      2. A random query with mixed case (e.G Www.iETf.Org) is sent to each unique name
         server IP address found in step 1.
      3. Remember the case of the QNAME in the query sent.
      4. Compare the QNAME in the question section of the response with the string in    step3.
      5. If the string in step3 and step4 are not equal with respect to case in
         sensitivity, the test fails.
      ### Outcome(s)
      The test case is Ok only if there are no responses in the authority section
  dns-nameserver09:
    Summary: Check whether authoritative name servers return same results for equivalent names with different cases in the request
    Description: |
      There has been cases where the nameservers respond with complete
      case-sensitivity (in violation of the DNS standards): that is, they match the
      exact case of the name in the response; but return different results for
      equivalent names with different cases in the request (typically NXDOMAIN).
      ### Inputs
      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case
      1. Retrieve all address records for all the name servers using [Method
         4](../Methods.md) and [Method 5](../Methods.md).
      2. Send a query with the input string in a mixed case (e.g. wWW.iETF.oRG) to
         each of the name server IP address found in step 1.
      3. If the "answer" flag is greater than 0, remember the "answer" section, else
         remember the status flag.
      4. Send another query with an alternative mixed case (e.g. Www.Ietf.Org) to each
         of the name server found in step 1.
      5. If the "answer" flag is greater than 0, remember the "answer" section, else
         remember the status flag.
      6. Compare the results remembered in step3 and step5.
      7. If the results in step 6 are not equal, the test case fails.

      ### Outcome(s)
      The test case passes only if the results of all queries are exactly the same.
  dns-nameserver10:
    Summary: Check whether authoritative name servers respond correctly to queries with undefined EDNS version
    Description: |
      EDNS ([RFC 6891]) is a mechanism to announce capabilities of a DNS
      implementation, and is required by new functionality in DNS such as DNSSEC
      ([RFC 4033][RFC 4033#section-3], section 3).

      [RFC 6891][RFC 6891#section-6.1.3], section 6.1.3, states that if a nameserver
      has implemented EDNS but has not implemented the version level of the request,
      then it MUST respond with RCODE "BADVERS". Only version "0" has been defined for
      EDNS.

      Note that RCODE "BADVERS" is an extended RCODE which is calculated from the
      combination of the normal RCODE field in the DNS package header
      ([RFC 1035][RFC 1035#section-4.1.1], section 4.1.1) and the OPT record
      EXTENDED-RCODE field ([RFC 6891][RFC 6891#section-6.1.3], section 6.1.3). Also
      see [IANA RCODE Registry].
      ## Scope

      Issues covered by [Connectivity01] (basic name server issues) or [Nameserver02] (basic
      EDNS issues) will not result in messages from this test case.
      ## Inputs

      * "Child Zone" - The domain name to be tested.

      ## Summary

      * Only relevant for a zone whose name servers correctly support EDNS, version 0.

      Message Tag outputted         | Level   | Arguments         | Description of when message tag is outputted
      :-----------------------------|:--------|:------------------|:--------------------------------------------
      N10_NO_RESPONSE_EDNS1_QUERY   | WARNING | ns_ip_list        | Response when EDNS ver=0, but not when 1.
      N10_UNEXPECTED_RCODE          | WARNING | ns_ip_list, rcode | Unexpected RCODE value when EDNS ver=1.
      N10_EDNS_RESPONSE_ERROR       | WARNING | ns_ip_list        | Expected RCODE value when EDNS ver=1, but error in response.

      The value in the Level column is the default severity level of the message. The
      severity level can be changed in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].
      ## Test procedure

      1. Create the following empty sets:
         1. Name server IP ("No Response EDNS1 Query").
         2. Name server IP and associated RCODE ("Unexpected RCODE").
         3. Name server IP ("EDNS Response Error").

      2. Create an SOA query for the *Child Zone* with an OPT record with EDNS version
         set to "0" and with EDNS option of payload size ("bufsize") set to 512 and
         other EDNS options and flags unset ("Query One").

      3. Create an SOA query for the *Child Zone* with an OPT record with EDNS version
         set to "1" and with EDNS option of payload size ("bufsize") set to 512 and
         other EDNS options and flags unset ("Query Two").

      4. Obtain the set of name server IP addresses using [Method4] and [Method5]
         ("Name Server IP").

      5. For each name server in *Name Server IP* do:
         1. Send *Query One* over UDP to the name server, collect the response and do:
            1. If there is no DNS response then go to next name server.
            2. Else, if the RCODE value is not "NOERROR" then go to next name server.
         2. Send *Query Two* over UDP to the name server, collect the response and do:
            1. If there is no DNS response, then add the name server IP to the
               *No Response EDNS1 Query* set.
            2. Else, if the DNS response does not have RCODE with value "BADVERS", then
               add the name server IP and RCODE value to the *Unexpected RCODE* set.
            3. Else, if the DNS response meet all the following three criteria, then
               just go to the next name server (correct response):
               1. It has the RCODE "BADVERS".
               2. It has EDNS version 0.
               3. The answer section is empty.
            4. Else add the name server IP to the *EDNS Response Error* set.

      6. If the *No Response EDNS1 Query* set is non-empty, then output
         *[N10_NO_RESPONSE_EDNS1_QUERY]* with the name server IP addresses from the
         set.

      7. If the *Unexpected RCODE* set is non-empty, then for each RCODE value in the
         set do:
         * Output *[N10_UNEXPECTED_RCODE]* with the RCODE value and the name server
           IP addresses for that RCODE value.

      8. If the *EDNS Response Error* set is non-empty, then output
         *[N10_EDNS_RESPONSE_ERROR]* with the name server IP addresses from the set.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol and log a message reporting
      the ignored result.
  dns-nameserver11:
    Summary: Check whether authoritative name servers responses doe not include unknown EDNS OPTION-CODE used in query
    Description: |
      EDNS is a mechanism to announce capabilities of a DNS implementation,
      and is now basically required by any new functionality in DNS such as
      DNSSEC ([RFC 6891]).

      [RFC 6891][RFC 6891, section 6.1.2], section 6.1.2, states that any OPTION-CODE values
      not understood by a responder or requestor MUST be ignored. Unknown OPTION-CODE values
      must be processed as though the OPTION-CODE was not even there.

      In this test case, we will query with an unknown EDNS OPTION-CODE and expect
      that the OPTION-CODE is not present in the response for the query.

      ## Scope

      It is assumed that *Child Zone* is also tested and reported by [Connectivity01]. This
      test case will just ignore non-responsive name servers or name servers not
      giving a correct DNS response for an authoritative name server.

      It is assumed that *Child Zone* has been tested and reported by [Nameserver02].
      Running this test case without running [Nameserver02] can give an incomplete
      report status of *Child Zone*.

      ## Inputs

      "Child Zone" - The domain name to be tested.

      ## Summary

      Message Tag                       | Level   | Arguments         | Message ID for message tag
      :---------------------------------|:--------|-------------------|---------------------------------------------
      N11_NO_EDNS                       | WARNING | ns_ip_list        | The DNS response, on query with unknown EDNS option-code, does not contain any EDNS from name servers "{ns_ip_list}".
      N11_NO_RESPONSE                   | WARNING | ns_ip_list        | There is no response on query with unknown EDNS option-code from name servers "{ns_ip_list}".
      N11_RETURNS_UNKNOWN_OPTION_CODE   | WARNING | ns_ip_list        | The DNS response, on query with unknown EDNS option-code, contains an unknown EDNS option-code from name servers "{ns_ip_list}".
      N11_UNEXPECTED_ANSWER_SECTION     | WARNING | ns_ip_list        | The DNS response, on query with unknown EDNS option-code, does not contain the expected SOA record in the answer section from name servers "{ns_ip_list}".
      N11_UNEXPECTED_RCODE              | WARNING | ns_ip_list, rcode | The DNS response, on query with unknown EDNS option-code, has unexpected RCODE name "{rcode}" from name servers "{ns_ip_list}".
      N11_UNSET_AA                      | WARNING | ns_ip_list        | The DNS response, on query with unknown EDNS option-code, is unexpectedly not authoritative from name servers "{ns_ip_list}".
      The value in the Level column is the default severity level of the message. The
      severity level can be changed in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].

      ## Test procedure

      In this section and unless otherwise specified below, the term "[EDNS Query]"
      follows the specification for DNS queries as specified in [DNS Query and Response Defaults].
      The handling of the DNS responses on the DNS queries follow, unless otherwise specified below,
      what is specified for [EDNS Response] in the same specification.

      1. Create the following empty sets:
         1. Name server IP address ("No Response on Unknown Option Code")
         2. Name server IP address and [RCODE Name] ("Unexpected RCODE on Unknown Option Code")
         3. Name server IP address ("No EDNS on Unknown Option Code")
         4. Name server IP address ("Unexpected Answer Section on Unknown Option Code")
         5. Name server IP address ("Unset AA on Unknown Option Code")
         6. Name server IP address ("Returns Unknown Option Code")

      2. Create a [EDNS Query] with query type SOA, *Child Zone* as query name and with
         no EDNS options or flags ("SOA Query").

      3. Create a [EDNS Query] with query type SOA, *Child Zone* as query name and with
         EDNS OPTION-CODE set to anything other than what is already assigned in
         the [IANA-DNSSYSTEM-PARAMETERS] and no other EDNS options or flags
         ("SOA Query with EDNS Option").

      4. Obtain the set of name server IP addresses using [Method4] and [Method5]
         ("Name Server IP").

      5. For each name server in *Name Server IP* do:

         1. Send *SOA Query* to the name server and collect the response.
         2. Go to next name server if at least one of the following criteria is met:
            1. There is no DNS response from the server.
            2. EDNS is unset in the response.
            3. The [RCODE Name] in the response is not "NoError".
            4. The AA flag is unset in the response.
            5. The answer section has no SOA record with *Child Zone* as owner name.
         3. Send *SOA Query with EDNS Option* to the name server and collect the
            response.
            1. If there is no DNS response from the server then add the name server to
               the *No Response on Unknown Option Code* set.
            2. Else, if the [RCODE Name] in the response is not "NoError" then add the
               name server and [RCODE Name] to the
               *Unexpected RCODE on Unknown Option Code* set.
               server.
            3. Else, if EDNS is unset in the response then add the name server to
               the *No EDNS on Unknown Option Code* set.
            4. Else, if the answer section has no SOA record with *Child Zone* as owner
               name then add the name server to the
               *Unexpected Answer Section on Unknown Option Code* set.
            5. Else, if the AA flag is unset in the response then add the name server
               to the *Unset AA on Unknown Option Code* set.
            6. Else, if the "OPTION-CODE" from the query is present in the response,
               then add name server to the *Returns Unknown Option Code* set.
            7. Else, no issues were found.

      5. If the *No Response on Unknown Option Code* set is non-empty, then output
         *[N11_NO_RESPONSE]* with the name servers IP addresses from the set.

      6. If the *Unexpected RCODE on Unknown Option Code* set is non-empty, then for
         each [RCODE NAME] in the set output *[N11_UNEXPECTED_RCODE]* with the
         [RCODE Name] and the name servers IP addresses for that [RCODE NAME] in the
         set.

      7. If the *No EDNS on Unknown Option Code* set is non-empty, then output
         *[N11_NO_EDNS]* with the name servers IP addresses from the set.

      8. If the *Unexpected Answer Section on Unknown Option Code* set is non-empty,
         then output *[N11_UNEXPECTED_ANSWER_SECTION]* with the name servers IP
         addresses from the set.

      9. If the *Unset AA on Unknown Option Code* set is non-empty, then output
         *[N11_UNSET_AA]* with the name servers IP addresses from the set.

      11. If the *Returns Unknown Option Code* set is non-empty, then output
          *[N11_RETURNS_UNKNOWN_OPTION_CODE]* with the name servers IP addresses from
          the set.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, skip sending queries over that
      transport protocol. A message will be outputted reporting that the transport
      protocol has been skipped.
  dns-nameserver12:
    Summary: Check whether authoritative name servers responses has "Z" bits cleared even if they are set in the query
    Description: |
      EDNS is a mechanism to announce capabilities of a dns implementation,
      and is now basically required by any new functionality in dns such as
      DNSSEC ([RFC 6891]).

      [RFC 6891][RCF 6891#section-6.1.4], section 6.1.4, states that "Z"
      flag bits must be set to zero by senders and ignored by receiver.

      [IANA] lists the flags in the [EDNS Header Flags] assignment list.

      In this test case, the query will have an unknown EDNS flag set, i.e.
      one of the Z flag bits set to "1", and it is expected that all "Z"
      bits to be clear in the response (set to "0").

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      "Child Zone" - The domain name to be tested.

      ## Ordered description of steps to be taken to execute the test case

      1. Create a SOA query for the *Child Zone* with an OPT record with
         one of the EDNS flag "Z" bits set to "1" and no other EDNS options or
         flags set.

      2. Obtain the set of name server IP addresses using [Method4] and [Method5]
         ("Name Server IP").

      3. For each name server in *Name Server IP* do:
         1. Send the SOA query to the name server and collect the response.
         2. If there is no DNS response, output *[NO_RESPONSE]* and go to
            next server.
         3. Else, if the DNS response has the RCODE "FORMERR" then output
            *[NO_EDNS_SUPPORT]*.
         4. Else, if the pseudo-section has an OPT record with one or more Z
            flag bits being set to "1", then output [Z_FLAGS_NOTCLEAR].
         5. Else, if the DNS response meet the following four criteria,
            then just go to the next name server (no error):
            1. The SOA is obtained as response in the ANSWER section.
            2. If the DNS response has the RCODE "NOERROR".
            3. The pseudo-section response has an OPT record with version set to 0.
            4. The "Z" bits are clear in the response
         6. Else output *[NS_ERROR]*.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      The outcome of this Test case is "pass" in all other cases.

      Message                           | Default severity level
      :---------------------------------|:----------------------------
      NO_RESPONSE                       | DEBUG
      NO_EDNS_SUPPORT                   | WARNING
      NS_ERROR                          | WARNING
      Z_FLAGS_NOTCLEAR                  | WARNING

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol and log a message reporting
      the ignored result.
  dns-nameserver13:
    Summary: Verify that if the response to a query with an OPT record is truncated, then the response will contain an OPT record
    Description: |
      EDNS is a mechanism to announce capabilities of a DNS implementation,
      and is now basically required by any new functionality in DNS such as
      DNSSEC ([RFC 6891]).

      [RFC 6891, section 7] states that an OPT record must be included
      in a truncated response, if the query includes an OPT pseudo record.

      This Test Case will try to verify that if the response to a query with an OPT
      record is truncated, then the response will contain an OPT record.

      To trigger a truncated response, the OPT pseudo record 'DO' bit is set and the
      buffer size is limited to 512 bytes. If the zone is not signed with DNSSEC, the
      response will probably not be truncated anyway.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      "Child Zone" - The domain name to be tested.

      ## Ordered description of steps to be taken to execute the test case

      1. Create a DNSKEY query for the *Child Zone* that is signed with 'DO' bit
      set to '1' and setting the buffer size to 512 bytes

      2. Obtain the set of name server IP addresses using [Method4] and [Method5]
         ("Name Server IP").

      3. For each name server in *Name Server IP* do:

      	1. Send the query to the name server and collect the response.
      	2. If there is no DNS response, output *[NO_RESPONSE]* and go to
            	next server.
      	3. Else, if the DNS response has the RCODE "FORMERR" then output
            	*[NO_EDNS_SUPPORT]* and go to the next server.
      	4. Else, if the DNS response meet the following criteria output
              *[MISSING_OPT_IN_TRUNCATED]*:
      	        1. The DNS response is truncated (the "TC" flag is set).
      	        2. The DNS response has no OPT record.
      	5. Else, if the DNS response meet the following criteria,
            	then just go to the next name server (no error):
      		1. The DNS response has the RCODE "NOERROR".
      		2. The pseudo-section response has an OPT record with version set to 0.
      	6. Else output *[NS_ERROR]*.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      The outcome of this Test case is "pass" in all other cases.

      Message                           | Default severity level (when message is outputed)
      :---------------------------------|:--------------------------------------------------
      NO_RESPONSE                       | DEBUG
      NO_EDNS_SUPPORT                   | WARNING
      NS_ERROR                          | WARNING
      MISSING_OPT_IN_TRUNCATED          | WARNING

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol and log a message reporting
      the ignored result.
  dns-syntax05:
    Summary: Verify that a SOA rname (Zonemaster::Engine::DNSName) given has a conform usage of at sign (@)
    Description: |
      The SOA RNAME field does not allow the '@' characters to be used for
      describing a mailbox. The first dot ('.') is thus translated into the
      '@' character. This is a common mistake. The rules are defined in
      [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035).

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Obtain a set of name server IP addresses using [Method4] and [Method5].
      2. Create a SOA query for the zone.
      3. Send the SOA query over UDP to each name server IP address until a
         response is received or until the set is exhausted.
      4. Check if the RNAME field contains a '@' character.
      ### Outcome(s)

      If there is any '@' character in any SOA/RNAME field, this test case fails.
  dns-syntax06:
    Summary: Verify that a SOA rname (Zonemaster::Engine::DNSName) given is RFC822 compliant
    Description: |
      The SOA RNAME field is a mailbox address. The SOA RNAME field is defined
      in [RFC 1035][RFC 1035#3.3.13], section 3.3.13 and in
      [RFC 1912][RFC 1912#2.2], section 2.2. The RNAME
      field should follow the rules of an e-mail address also defined in
      [RFC 5322][RFC 5322#3.4.1], section 3.4.1.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * "Child Zone" - The domain name to be tested.

      ## Ordered description of steps to be taken to execute the test case

      1. Obtain the set of name server IP addresses using [Method4] and [Method5]
         ("NS IP").

      2. Create a SOA query for the apex of the *Child Zone* with RD flag unset.

      3. For each name server IP in *NS IP* do:
         1. Send the SOA query over UDP to the name server IP.
         2. If the name server does not respond with a DNS response, then:
            1. Output *[NO_RESPONSE]*.
            2. Go to next name server IP.
         3. If the DNS response does not include an SOA record in the
            answer section, then:
            1. Output *[NO_RESPONSE_SOA_QUERY]*.
            2. Go to next name server IP.
         4. Extract the RNAME from the SOA record (from the first SOA record if
            multiple) and convert it to an email address ("Email Address" below)
            using the following steps:
            1. Convert the first "." without backslash quoting to an "@" in
               the RNAME.
            2. Convert any backslash quoted "." to a single "." without quoting
               (see [RFC 1035], section [5.1][RFC 1035#5.1], [5.3][RFC 1035#5.3] and
               [8][RFC 1035#8] for the use of backslash).
         7. If *Email Address* does not meet the
            mail address specification in [RFC 5322][RFC 5322#3.4.1],
            section 3.4.1, then
            1. Output *[RNAME_RFC822_INVALID]*.
            2. Go to next name server IP.
         8. Extract the domain part (to the right of "@") from the *Mail
            address* ("Domain Part" below).
         9. Create an MX query for the *Domain Part* and do a
            [DNS Lookup][terminology] of that query.
         10. If the lookup of MX does not return a DNS response with RCODE
             "NOERROR", then:
             1. Output *[RNAME_MAIL_DOMAIN_INVALID]*.
             2. Go to next name server IP.
         11. When doing the MX lookup, CNAME or a chain of CNAMEs are followed, if
             any. If an MX record or records are found via CNAME, then
             set *Domain Part* to be equal to the owner name of that MX record
             (instead of being equal to the domain part of *Email Address*).
         12. If the MX lookup returned a NO DATA response (no MX record),
             then:
             1. Create address queries (A and AAAA) for the *Domain Part* and
                do:
                1. Do [DNS Lookups][terminology] of those queries.
                2. If the answer section contains a CNAME record output
                   *[RNAME_MAIL_ILLEGAL_CNAME]*.
                3. Else, extract any A and AAAA records from the answer
                   sections of the DNS responses with *Domain Part* as owner
                   name.
             2. If any A or AAAA record points at 127.0.0.1 or ::1 (localhost),
                respectively, then output *[RNAME_MAIL_DOMAIN_LOCALHOST]*.
             3. If no A or AAAA are extracted or any records points at
                127.0.0.1 or ::1, then output *[RNAME_MAIL_DOMAIN_INVALID]*.
         13. If the MX lookup returns one or more MX records, then for each
             MX record extract the domain name in RDATA ("Mail Exchange")
             and do:
             1. Create address queries (A and AAAA) of *Mail Exchange* and do:
                1. Do [DNS Lookups][terminology] of those queries.
                2. If the answer section contains a CNAME record output
                   *[RNAME_MAIL_ILLEGAL_CNAME]*.
                3. Else, extract any A and AAAA records from the answer
                   sections of the DNS responses with *Mail Exchange* as owner
                   name.
             2. If any A or AAAA record points at 127.0.0.1 or ::1 (localhost),
                respectively, then output *[RNAME_MAIL_DOMAIN_LOCALHOST]*.
             3. If no A or AAAA are are extracted or any records points at
                127.0.0.1 or ::1, then output *[RNAME_MAIL_DOMAIN_INVALID]*.

      4. If at least one name server IP has neither outputted *[NO_RESPONSE]*
         nor *[NO_RESPONSE_SOA_QUERY]* and *[RNAME_MAIL_DOMAIN_INVALID]* has not
         been outputted for any name server IP, then output *[RNAME_RFC822_VALID]*.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                       | Default severity level
      :-----------------------------|:-----------------------------------
      NO_RESPONSE                   | DEBUG
      NO_RESPONSE_SOA_QUERY         | DEBUG
      RNAME_RFC822_INVALID          | WARNING
      RNAME_MAIL_DOMAIN_INVALID     | WARNING
      RNAME_MAIL_DOMAIN_LOCALHOST   | WARNING
      RNAME_MAIL_ILLEGAL_CNAME      | WARNING
      RNAME_RFC822_VALID            | INFO

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.
      ## Terminology

      * "Using Method" - When the term is used, names and IP addresses are fetched
      using the defined [Methods].

      * "Send" (to an IP address) - The term is used when a DNS query is sent to
      a specific name server.

      * "DNS Lookup" - The term is used when a recursive lookup is used, though
      any changes to the DNS tree introduced by an [undelegated test] must be
      respected.
  dns-syntax07:
    Summary: Verify that SOA mname of zone given conforms to syntax rules
    Description: |
      The SOA MNAME field is a hostname. Hostnames are valid according to the
      rules defined in [RFC 952](https://datatracker.ietf.org/doc/html/rfc952),
      in section 2.1 in [RFC 1123](https://datatracker.ietf.org/doc/html/rfc1123#section-2.1),
      section 11 in [RFC 2182](https://datatracker.ietf.org/doc/html/rfc2181#section-11) and
      section 2 and 5 in [RFC 3696](https://datatracker.ietf.org/doc/html/rfc3696#section-2).
      Newer RFCs may override some rules defined in earlier documents.

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Retrieve the SOA record from the zone being tested.
      2. Get the MNAME from the SOA record.
      3. Each label of the hostname of the test object is used as the input
         for the validation.
      4. If any label in the hostname does not contain a-z or 0-9 this test case
         fails.
      5. If any label of the hostname is longer than 63 characters, this test case
         fails.
      6. If the hostname is longer than 255 characters including separators, this
         test case fails.
      7. If the rightmost label (the TLD) contains only digits, this test case
         fails.
      8. If there is a hyphen ('-') in position 3 and 4 of the label, and the prefix
         is not xn (used for internationalization), this test case fails.

      ### Outcome(s)

      If any of the steps 4 to 8 in the ordered description of this test case fails,
      the whole test case fails.

      ### Intercase dependencies

      This test case uses the same host name validator as test case [SYNTAX04](syntax04.md).

  dns-zone01:
    Summary: Check that master nameserver in SOA is fully qualified
    Description: |
      The MNAME field from the SOA record of a zone is supposed to contain the master
      name server for that zone. The hostname of the MNAME field may not be listed
      in the NS records in the zone among the delegated name servers, but should
      still be authoritative for the zone. MNAME may be used for other services
      such as DNS NOTIFY described in [RFC1996].

      [RFC1035], section 3.3.13, specifies that "the *domain-name* of the name server
      that was the original or primary source of data for this zone".

      [RFC1996], section 2, and [RFC2136], section 1, add that "the primary master is
      named in the zone's SOA MNAME field and optionally by an NS RR.
      There is by definition only one primary master server per zone".

      [RFC2181], section 7.2, clarifies that "it is quite clear in the specifications,
      yet seems to have been widely ignored, that the MNAME field of the SOA record
      should contain the name of the primary (master) server for the zone identified
      by the SOA. It should not contain the name of the zone itself. That information
      would be useless, as to discover it, one needs to start with the domain name of
      the SOA record - that is the name of the zone".

      There exists an unstandardized practice to set the SOA MNAME to ".", which
      should not be interpreted that there is no primary master server, but to
      indicate that there is no default server for dynamic updates. With ".", SOA
      MNAME has no server name. There is at least one old and expired Internet-Draft
      that attempted to standardize that behavior, [draft-jabley-dnsop-missing-mname].
      If the SOA MNAME is an empty name (".") this Test Case will not try to connect
      to a server behind it since there will never be a server behind that name, as
      the purpose is most definitely to follow that practice. Instead, a special
      message will be outputted.

      This Test Case will check that:
       - the SOA MNAME contains the master name server of *Child Zone*,
         as best as it can be determined.
       - the SOA MNAME name server is authoritative of *Child Zone*.
       - the SOA SERIAL of the SOA MNAME is at least equal to the ones found
         from the name servers in the NS record set of *Child Zone*.
         This comparison must be done following [RFC1982].
       - the SOA MNAME name server is listed as part of the NS record set of *Child Zone*.

      ## Scope

      It is assumed that *Child Zone* is tested and reported by [CONNECTIVITY01].
      This Test Case will just ignore non-responsive name servers or name servers
      not giving a correct DNS response for an authoritative name server, except
      if the name server is listed in the SOA MNAME.

      The syntax of the SOA MNAME for *Child Zone* is not tested in this Test
      Case, see [SYNTAX07].

      The consistency of the SOA MNAME between different servers of *Child Zone*
      is not tested by this Test Case, see [CONSISTENCY06].

      ## Inputs

      * "Child Zone" - The domain name to be tested.

      ## Summary

      Message Tag                   | Level   | Arguments                            | Message ID for message tag
      :---------------------------- |:--------|:-------------------------------------|:---------------------------------------------------------------------------------------
      Z01_MNAME_HAS_LOCALHOST_ADDR  | WARNING | nsname, ns_ip                        | SOA MNAME name server "{nsname}" resolves to a localhost IP address ({ns_ip}).
      Z01_MNAME_IS_DOT              | NOTICE  | ns_ip_list                           | SOA MNAME is specified as "." which usually means "no server". Fetched from name servers "{ns_ip_list}".
      Z01_MNAME_IS_LOCALHOST        | WARNING | ns_ip_list                           | SOA MNAME name server is "localhost", which is invalid. Fetched from name servers "{ns_ip_list}".
      Z01_MNAME_IS_MASTER           | DEBUG   | ns_list                              | SOA MNAME name server(s) "{ns_list}" appears to be master.
      Z01_MNAME_MISSING_SOA_RECORD  | WARNING | ns                                   | SOA MNAME name server "{ns}" reponds to an SOA query with no SOA records in the answer section.
      Z01_MNAME_NO_RESPONSE         | WARNING | ns                                   | SOA MNAME name server "{ns}" does not respond to an SOA query.
      Z01_MNAME_NOT_AUTHORITATIVE   | WARNING | ns                                   | SOA MNAME name server "{ns}" is not authoritative for the zone.
      Z01_MNAME_NOT_IN_NS_LIST      | INFO    | nsname                               | SOA MNAME name server "{nsname}" is not listed as NS record for the zone.
      Z01_MNAME_NOT_MASTER          | WARNING | ns_list, soaserial, soaserial_list   | SOA MNAME name server(s) "{ns_list}" do(es) not have the highest SOA SERIAL (expected "{soaserial}" but got "{soaserial_list}")
      Z01_MNAME_NOT_RESOLVE         | WARNING | nsname                               | SOA MNAME name server "{nsname}" cannot be resolved into an IP address.
      Z01_MNAME_UNEXPECTED_RCODE    | WARNING | ns, rcode                            | SOA MNAME name server "{ns}" gives unexpected RCODE name ("{rcode}") in response to an SOA query.

      The value in the Level column is the default severity level of the message. The
      severity level can be changed in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].

      ## Test procedure

      In this section and unless otherwise specified below, the terms "[DNS Query]"
      follow the specification for DNS queries as specified in [DNS Query and Response Defaults].
      The handling of the DNS responses on the DNS queries follow, unless otherwise
      specified below, what is specified for [DNS Response] in the same specification.

      1. Create a [DNS Query] with query type SOA and query name *Child Zone* ("SOA Query").

      2. Create the following empty sets:
         1. Name server SOA MNAME name, SOA MNAME IP address(es), SOA SERIAL(s) ("MNAME Nameservers")
         2. Name server SOA SERIAL ("SERIAL Nameservers")
         3. Name server SOA MNAME name, SOA MNAME IP address, SOA SERIAL ("MNAME Not Master")
         4. Name server SOA MNAME name, SOA MNAME IP address ("MNAME Is Master")
         5. Name server IP address ("MNAME Is Localhost")
         6. Name server IP address ("MNAME Is Dot")

      3. Obtain the set of name server IP addresses using
         [Method4] and [Method5] ("Name Server IP").

      4. For each name server IP address in *Name Server IP* do:
         1. Send *SOA Query* to the name server IP and collect the response.
         2. Go to next name server IP address if at least one of
            the following criteria is met:
            1. There is no DNS response.
            2. [RCODE Name] of the response is not "NoError".
            3. The AA flag is not set in the response.
            4. There is no SOA record with owner name matching the query.
         3. From the DNS response, extract the name server name from the SOA MNAME field:
            1. If the name is "localhost", then add name server IP address to
               the *MNAME Is Localhost* set.
            2. Else if the name is ".", then add name server IP address to
               the *MNAME Is Dot* set.
            3. Else, add SOA MNAME name server name to the *MNAME Nameservers* set.
         4. From the SOA record in the DNS response, extract the value from the SOA SERIAL
            field and add it to the *SERIAL Nameservers* set.
         5. Go to next name server IP address.

      5. If the set *MNAME Is Localhost* is non-empty, then output
         *[Z01_MNAME_IS_LOCALHOST]* with name server(s) IP address(es).

      6. If the set *MNAME Is Dot* is non-empty, then output
         *[Z01_MNAME_IS_DOT]* with name server(s) IP address(es).

      7. If the set *MNAME Nameservers* is empty, then terminate these procedures.

      8. Obtain the set of name server names using [Method3] ("Child Nameservers").

      9. For each SOA MNAME name server name in *MNAME Nameservers* do:
         1. If the SOA MNAME name server name is not part of the
            *Child Nameservers* set, then output *[Z01_MNAME_NOT_IN_NS_LIST]* with
            SOA MNAME name server name.
         2. Do a [DNS Lookup] of SOA MNAME name server name (A and AAAA) and add the
            SOA MNAME name server IP address(es) found to the *MNAME Nameservers* set
            for the same entry as the SOA MNAME name server name.
         3. If at least one IP address from the previous step was found, then:
            1. For each SOA MNAME name server IP address for the SOA MNAME name server name do:
               1. If the IP address is a localhost address (127.0.0.1 or ::1), then output
                  *[Z01_MNAME_HAS_LOCALHOST_ADDR]* with SOA MNAME name server name and IP.
               2. Else, send *SOA Query* to the name server IP and collect the response.
                  1. If there is a DNS response, with [RCODE Name] "NoError" and
                     an SOA record in the answer section, then:
                     1. If the AA flag is not set, then output *[Z01_MNAME_NOT_AUTHORITATIVE]*
                        with SOA MNAME name server name and IP address.
                     2. Else, add the SOA SERIAL value to the *MNAME Nameservers* set
                        for the SOA MNAME name server name and IP pair.
                  2. Else if [RCODE Name] is not "NoError", then output
                     *[Z01_MNAME_UNEXPECTED_RCODE]* with [RCODE Name], SOA MNAME name server
                     name and IP address.
                  3. Else if there is no SOA record in the answer section, then output
                     *[Z01_MNAME_MISSING_SOA_RECORD]* with SOA MNAME name server
                     name and IP address.
                  4. Else, output *[Z01_MNAME_NO_RESPONSE]* with SOA MNAME name server
                     name and IP address.
               3. Go to next SOA MNAME name server IP.
         4. Else, output *[Z01_MNAME_NOT_RESOLVE]* with SOA MNAME name server name.
         5. Go to next SOA MNAME name server name.

      10. If there is no SOA SERIAL in the *MNAME Nameservers* set, then
          terminate these procedures.

      11. For each SOA SERIAL (per SOA MNAME name server name and IP address pair)
          in *MNAME Nameservers* do:
          1. For each SOA SERIAL in *SERIAL Nameservers* do:
             1. Compare both SOA SERIAL values (using the arithmetic in [RFC1982]).
             2. If the one from *SERIAL Nameservers* is higher, then add SOA MNAME name
                server name, IP address and SOA SERIAL of the current SOA SERIAL value from
                the *MNAME Nameservers* set to the *MNAME Not Master* set, and go
                to next SOA SERIAL (from the *MNAME Nameservers* set).
          2. Add SOA MNAME name server name and IP address to the *MNAME Is Master* set.

      12. If the set *MNAME Not Master* is non-empty, then output *[Z01_MNAME_NOT_MASTER]*
          with SOA MNAME name server name(s), IP address(es) and SOA SERIAL from the set,
          along with the SOA SERIAL values from the *SERIAL Nameservers* set.

      13. If the set *MNAME Is Master* is non-empty, then output *[Z01_MNAME_IS_MASTER]*
          with SOA MNAME name server name(s) and IP address(es) from the set.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, skip sending queries over that
      transport protocol. A message will be outputted reporting that the transport
      protocol has been skipped.

      ## Terminology

      * "DNS Lookup" - The term is used when a recursive lookup is used, though
      any changes to the DNS tree introduced by an [undelegated test] must be
      respected.
  dns-zone02:
    Summary: Verify SOA 'refresh' minimum value
    Description: |
      The SOA refresh value is the number of seconds that describes
      how often a secondary name server will poll the primary name server
      to see if there is any updates. The SOA refresh value is described
      in section 3.3.13 in [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035),
      and clarified in section 2.2 of
      [RFC 1912](https://datatracker.ietf.org/doc/html/rfc1912).
      Setting the refresh value low will increase the DNS traffic between
      the servers, and also increase the load on the master name server.
      The primary name server will in most cases send DNS notifications to
      tell the secondary name servers that zone content has been updated,
      as described in [RFC 1996](https://datatracker.ietf.org/doc/html/rfc1996).

      The [RIPE-203](https://www.ripe.net/publications/docs/ripe-203) recommendation
      for the refresh value is 24 hours (86400 seconds). Older DNSCheck code
      had a four hour minimum value, and this is the minimum value we
      recommend.

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Retrieve the SOA record from a delegated name server for the domain.
      2. If the answer from step 1 is not authoritative, iterate step 1 until there is an authoritative answer.
      3. Retrieve the refresh value from the SOA record.
      4. If the refresh value is less than 14400 (four hours in seconds)
         this test case fails.

      ### Outcome(s)

      If the SOA refresh value is less than 14400 this test case fails.
  dns-zone03:
    Summary: Verify SOA 'retry' value is lower than SOA 'refresh' value
    Description: |
      The SOA retry value is the number of seconds that describes
      minimum time elapsed since a failed zone refresh from the primary
      name server. The SOA refresh value is described
      in section 3.3.13 in [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035),
      and clarified in section 2.2 of
      [RFC 1912](https://datatracker.ietf.org/doc/html/rfc1912).

      > It's typically some fraction of the refresh interval.

      Setting the retry value low will increase the DNS traffic between
      the servers, and also increase the load on the master name server.

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Retrieve the SOA record from a delegated name server for the domain.
      2. If the answer from step 1 is not authoritative, iterate step 1 until there is an authoritative answer.
      3. Retrieve the retry value from the SOA record.
      4. If the retry value is higher than or equal to the refresh value,
         this test case fails.

      ### Outcome(s)

      If the SOA retry value is higher than or equal to the refresh value,
      this test case fails.
  dns-zone04:
    Summary: Verify SOA 'retry' minimum value
    Description: |
      The SOA retry value is the number of seconds that describes
      minimum time elapsed since a failed zone refresh from the primary
      name server. The SOA refresh value is described
      in section 3.3.13 in [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035),
      and clarified in section 2.2 of
      [RFC 1912](https://datatracker.ietf.org/doc/html/rfc1912).

      Setting the retry value low will increase the DNS traffic between
      the servers, and also increase the load on the master name server.

      The [RIPE-203](https://www.ripe.net/publications/docs/ripe-203) recommendation
      for the retry value is 2 hours (7200 seconds). Older DNSCheck code
      had a one hour minimum value (3600 seconds), and this is the minimum
      value we recommend.

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Retrieve the SOA record from a delegated name server for the domain.
      2. If the answer from step 1 is not authoritative, iterate step 1 until there is an authoritative answer.
      3. Retrieve the retry value from the SOA record.
      4. If the retry value is less than 3600 seconds, this test case fails.

      ### Outcome(s)

      If the retry value is less than 3600 seconds, this test case fails.
  dns-zone05:
    Summary: Verify SOA 'expire' minimum value
    Description: |
      The SOA expire value specifies for how long any secondary name server
      keeps the zone valid without any contact with the primary name server.
      This value should be greater than how long a major outage would
      typically last. The expire value should also be larger than the
      refresh and retry values, as described in section 3.3.13 in
      [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035), and clarified in
      section 2.2 of [RFC 1912](https://datatracker.ietf.org/doc/html/rfc1912).

      Setting the expire value low will increase the risk of any unwanted
      non-availability of the zone because of any failures in contacting
      the primary name server.

      The [RIPE-203](https://www.ripe.net/publications/docs/ripe-203) recommendation
      for the expire value is 1000 hours (roughly 41 days). Older DNSCheck code
      had a 7 day minimum value (604800 seconds), and this is the minimum
      value we recommend as an absolut minimum.

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Retrieve the SOA record from a delegated name server for the domain.
      2. If the answer from step 1 is not authoritative, iterate step 1 until there is an authoritative answer.
      3. Retrieve the expire value and the refresh value from the SOA record.
      4. If the expire value is less than 604800 seconds (7 days), this test
         case fails.
      5. If the expire value is lower than the refresh value, this test case
         fails.

      ### Outcome(s)

      If the expire value is less than 604800 seconds or if the expire value is
      lower than the refresh value, this test case fails.
  dns-zone06:
    Summary: Verify SOA 'minimum' (default TTL) value
    Description: |
      The SOA minimum field sets the default TTL for all records in a zone.
      The recommended value is to be "cache-friendly". However, for a zone
      that changes content often, there is a need to keep the TTL values
      shorter. The use of the SOA minimum value today is the negative cache
      (where a resolver find content is missing).

      The SOA minimum field is described in section 3.3.13 in
      [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035), and clarified in
      section 2.2 of [RFC 1912](https://datatracker.ietf.org/doc/html/rfc1912).
      The description of the implementation of negative caching is in
      [RFC 2308](https://datatracker.ietf.org/doc/html/rfc2308) (although it has been
      updated by several DNSSEC related RFCs, it is still relevant for this
      purpose).

      The [RIPE-203](https://www.ripe.net/publications/docs/ripe-203) recommendation
      for the minimum value 2 days, but the negative caching is now the norm.
      DNSCheck has a recommended value of between 300 seconds (5 minutes) and
      86400 seconds (1 day).

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Obtain a set of name server IP addresses using [Method4] and [Method5].
      2. Create a SOA query for the zone.
      3. Send the SOA query over UDP to each name server IP address until
         a response is received or until the set is exhausted.
      4. If the answer from step 3 is not authoritative, iterate step 3 until there is an authoritative answer.
      5. Retrieve the SOA minimum value from the SOA record.
      6. If the minimum value is larger than 86400 seconds (1 day), this test
         case fails.
      7. If the minimum value is lower than 300 seconds (5 minutes), this test case
         fails.

      ### Outcome(s)

      If the minimum value is larger than 86400 seconds or if the minimum value is
      lower than 300 seconds, this test case fails.
  dns-zone07:
    Summary: Verify that SOA master is not an alias (CNAME)
    Description: |
      Any NS type record should not be a CNAME. The SOA MNAME should in this
      respect not be a CNAME.

      Quote from 2.4 in [RFC 1912](https://datatracker.ietf.org/doc/html/rfc1912):

      > Having NS records pointing to a CNAME is bad and may conflict badly
      > with current BIND servers.

      The SOA MNAME field is described in section 3.3.13 in
      [RFC 1035](https://datatracker.ietf.org/doc/html/rfc1035).

      The [RIPE-203](https://www.ripe.net/publications/docs/ripe-203) recommendation
      for the minimum value 2 days, but the negative caching is now the norm.
      DNSCheck has a recommended value of between 300 seconds (5 minutes) and
      86400 seconds (1 day).

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Retrieve the SOA record from a delegated name server for the domain.
      2. If the answer from step 1 is not authoritative, iterate step 1 until there is an authoritative answer.
      3. Retrieve the SOA MNAME value from the SOA record.
      4. Query for A and AAAA records for the host from MNAME.
      5. If the answer to the query is a CNAME, this test case fails.

      ### Outcome(s)

      If the SOA MNAME field is pointing to a CNAME, this test case fails.
  dns-zone10:
    Summary: Verify that the zone of the domain to be tested return exactly one SOA record
    Description: |
      The SOA record is crucial for the DNS zone and "exactly one SOA RR should
      be present at the top of the zone" ([RFC 1035][RFC 1035#5.2], section 5.2).
      This test case will verify that the zone of the domain to be tested return
      exactly one SOA record.
      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      ## Ordered description of steps to be taken to execute the test case

      1. Obtain the set of name server IP addresses using [Method4] and [Method5]
         ("NS IP").

      2. Create a SOA query for the apex of the *Child Zone* with RD flag unset.

      3. For each name server in *NS IP* do:
         1. Send the SOA query over UDP to the name server.
         2. If the name server does not respond with a DNS response, then
            output *[NO_RESPONSE]*.
         3. Else, if the DNS response does not include a SOA record in the
            answer section, then output *[NO_SOA_IN_RESPONSE]*.
         4. Else, if the SOA record or records in the answer section do not
            have *Child Zone* as owner name, then output *[WRONG_SOA]*.
         5. Else, if the DNS response includes multiple SOA records in the
            answer section, then output *[MULTIPLE_SOA]*.

      4. If no message is outputted for any server, then output *[ONE_SOA]*.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                       | Default severity level
      :-----------------------------|:-----------------------------------
      MULTIPLE_SOA                  | ERROR
      NO_RESPONSE                   | DEBUG
      NO_SOA_IN_RESPONSE            | DEBUG
      ONE_SOA                       | INFO
      WRONG_SOA                     | DEBUG

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      ## Terminology

      When the term "using Method" is used, names and IP addresses are fetched
      using the defined [Methods].

      The term "send" (to an IP address) is used when a DNS query is sent to
      a specific name server.
  dnssec-01:
    Summary: Verifies that all DS records have digest types registered with IANA
    Description: |
      The list of allowed Digest Algorithms in a DS record published by the parent is
      specified by [RFC 8624][RFC 8624#3.3], section 3.3, and is published in the
      [IANA registry][IANA registry on DS Digest Algorithm] of
      *DS RR Type Digest Algorithms*. No DS Digest Algorithm values, other than those
      specified in the RFC and allocated by IANA, should be used in public DNS.

      If [RFC 8624][RFC 8624#3.3] and the
      [IANA registry][IANA registry on DS Digest Algorithm] disagree on the same DS
      digest algorithm, the RFC takes precedence until the registry has a been updated
      with a reference to the RFC.

      The table of algorithms below is for reference only and is copied from
      [IANA registry][IANA registry on DS Digest Algorithm]. It is here to make it
      easier to read the steps when symbolic names are given. This is only an excerpt
      from the table. The full table is available at the IANA registry.

      Algorithm number | Algorithm (or description)
      :----------------|:-----------------------------------
      0                | (Reserved)
      1                | SHA-1
      2                | SHA-256
      3                | GOST R 34.11-94
      4                | SHA-384
      5-255            | (Unassigned)

      This test case will verify that the Zonemaster implementation has support for the
      DS digest algorithm of the DS record found, and if not output a message tag. If
      the support is missing other test cases will not be able to verify that DS
      record.
      ## Scope

      This test case will query the name servers of the parent zone, and will just
      ignore non-responsive name servers or name servers not giving a correct DNS
      response for an authoritative name server.

      If no DS record is found in the parent zone then this test case will be
      terminated without outputting any message tag.

      This test case does not report if the parent servers give inconsistent responses.

      If the *Child Zone* is the root zone, then it has no parent zone, and no DS
      records can be fetch.
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      * "Algorithm Status" - The status of all DS digest algorithms from
        [RFC 8624][RFC 8624#3.3] and the
        [IANA registry][IANA registry on DS Digest Algorithm].
      * "Test Type" - The test type with value "undelegated" or "normal".
      * "Undelegated DS" - The DS record or records submitted, undefined unless
        *Test Type* is undelegated and empty if no DS record has been submitted.
      ## Summary

      * At least one DS record must be found, or no further investigation will be done
        and no messages will be outputted.
      * No messages will be outputted due to errors in the responses from the parent
        name servers.

      Message Tag outputted          | Level   | Arguments                                | Description of when message tag is outputted
      :------------------------------|:--------|:-----------------------------------------|:--------------------------------------------
      DS01_DIGEST_NOT_SUPPORTED_BY_ZM| NOTICE  | ns_ip_list, algo_mnemo, algo_num, keytag | DS Digest cannot be validated by this installation of Zonemaster.
      DS01_DS_ALGO_DEPRECATED        | ERROR   | ns_ip_list, algo_mnemo, algo_num, keytag | The DS digest algorithm is deprecated.
      DS01_DS_ALGO_2_MISSING         | NOTICE  |                                          | DS created with algo 2 (SHA-256) is missing.
      DS01_DS_ALGO_NOT_DS            | ERROR   | ns_ip_list, algo_mnemo, algo_num, keytag | The DS digest algorithm is not for DS.
      DS01_DS_ALGO_RESERVED          | ERROR   | ns_ip_list, algo_mnemo, algo_num, keytag | No DS digest algorithm defined for the digest code.

      The value in the Level column is the default severity level of the message. The
      severity level can be overridden in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].
      ## Test procedure

      In this section and unless otherwise specified below, the term "[DNSSEC Query]"
      follows the specification for DNS queries as specified in
      [DNS Query and Response Defaults]. The handling of the DNS responses on the DNS
      queries follow, unless otherwise specified below, what is specified for
      [DNSSEC Response] in the same specification.

      1.  If the *Test Type* is "[undelegated]" do:

          1. If *Undelegated DS* is empty then do terminate the test procedure.

          2. Else, for each DS record in *Undelegated DS* do:

             1. Extract the digest algorithm code and key tag from the DS record
                ("Digest Code" and "Key Tag", respectively).

             2. If *Digest Code* is 0 then output *[DS01_DS_ALGO_NOT_DS]* with
                *Digest Code* and *Key Tag*. Set IP address as "-".

             3. If *Digest Code* is 1 or 3 then output *[DS01_DS_ALGO_DEPRECATED]* with
                *Digest Code* and *Key Tag*. Set IP address as "-".

             4. If *Digest Code* is 5-255 then output *[DS01_DS_ALGO_RESERVED]* with
                *Digest Code* and *Key tag*. Set IP address as "-".

             5. Verify if the Zonemaster implementation can create a digest of any
                valid DNSKEY record using *Digest Code*. If the verification fails
                output *[DS01_DIGEST_NOT_SUPPORTED_BY_ZM]* with *Digest Code* and
                *Key tag*. Set IP address as "-".

          3. If none of the DS records has digest algorithm value 2 output
             *[DS01_DS_ALGO_2_MISSING]*.

          4. Terminate the test procedure.

      2.  From here the test procedure is for normal test, not undelegated.

      3.  If *Child Zone* is the root zone (".") then terminate the test procedure.

      4.  Create the following empty set:
          1. Name server IP, key tag from DS record and digest algorithm code ("DS Records").

      5.  Create a [DNSSEC Query] with query type DS and query name *Child Zone*
          ("DS Query").

      6.  Retrieve all name server IP addresses for the parent zone of
          *Child Zone* using [Method1] (store as "Parent NS IP").

      7.  For each parent name server in *Parent NS IP* do:
          1. Send *DS Query* to the name server IP.
          2. If at least one of the following criteria is met, then go to next
             parent name server:
             1. There is no [DNSSEC Response].
             2. The RCODE in the [DNSSEC Response] is not "NoError"
                ([IANA RCODE List]).
             3. The OPT record is absent in the [DNSSEC Response].
             4. The DO flag is unset in the [DNSSEC Response].
             5. The AA flag is not set in the [DNSSEC Response].
             6. There is no DS record with matching owner name in the answer
                section of the [DNSSEC Response].
          3. Retrieve the DS records from the [DNSSEC Response] and add name sever IP,
             key tag from the DS record and the digest algorithm code from the DS
             record to the *DS Records* set.

      8.  If the *DS Records* set is empty terminate the test procedure.

      9.  For each subset in *DS Records* where both DS digest code ("Digest Code") and
          key tag ("Key Tag") are identical for all subset elements do:

          1. If *Digest Code* is 0 then output *[DS01_DS_ALGO_NOT_DS]* with
            *Digest Code*, *Key Tag* and list of name server IP addresses.
          2. If *Digest Code* is 1 or 3 then output *[DS01_DS_ALGO_DEPRECATED]* with
             *Digest Code*, *Key Tag* and list of name server IP addresses.
          3. If *Digest Code* is 5-255 then output *[DS01_DS_ALGO_RESERVED]* with
             *Digest Code*, *Key Tag* and list of name server IP addresses.
          4. Verify that the Zonemaster implementation can create a digest of any valid
             DNSKEY record using *Digest Code*. If the verification fails output
             *[DS01_DIGEST_NOT_SUPPORTED_BY_ZM]* with *Digest Code*, *Key Tag* and list
             of name server IP addresses.

      10. If none of the elements in *DS Records* has digest algorithm value 2 output
         *[DS01_DS_ALGO_2_MISSING]*.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      See the [DNSSEC README] document about DNSSEC algorithms.
  dnssec-02:
    Summary: Verifies that all DS records have a matching DNSKEY
    Description: |
      DNS delegations from a parent to a child are secured with DNSSEC by
      publishing one or several Delegation Signer (DS) records in the parent
      zone, along with the NS records for the delegation.

      For the secure delegation to work, at least one DS record must match a
      DNSKEY record in the child zone ([RFC 4035][RFC 4035#section-5], section 5).
      Each DS record should match a DNSKEY record in the child zone. More
      than one DS may match the same DNSKEY. The DNSKEY that the DS record
      refer to must be used to sign the DNSKEY RRset in the child zone
      ([RFC 4035][RFC 4035#section-5], section 5).

      The DNSKEY record that the DS record refer to must have bit 7
      ("Zone Key flag") set in the DNSKEY RR Flags ([RFC 4034][RFC 4034#section-5.2],
      section 5.2).

      Bit 15 ("Secure Entry Point flag") on a DNSKEY record signals that it
      is meant to be a KSK and pointed out by a DS record. It is noted if
      the DNSKEY record that the DS points at does not have that flag set
      ([RFC 4034][RFC 4034#section-2.1.1], section 2.1.1).

      ## Scope

      This test case will just ignore non-responsive name servers or name servers not
      giving a correct DNS response for an authoritative name server (handled by
      [Connectivity01]).

      If no DS record is found in the parent zone or no DNSKEY record is found in the
      *Child Zone* then this test case will be terminated (also see [DNSSEC11]).

      This test case does not report if the parent servers are unresponsive or
      inconsistent.
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      * "Test Type" - The test type with value "undelegated" or "normal".
      * "Undelegated DS" - The DS record or records submitted
        (only if *Test Type* is [undelegated]).
      ## Summary

      * Both DS record and DNSKEY record must be found, or else no further
        investigation will be done and no messages will be outputted.
      * No messages will be outputted due to errors in the responses from the parent
        name servers.

      Message Tag outputted              | Level   | Arguments                              | Description of when message tag is outputted
      :----------------------------------|:--------|:---------------------------------------|:-----------------------------------------------------------------------
      DS02_ALGO_NOT_SUPPORTED_BY_ZM      | NOTICE  |ns_ip_list, algo_mnemo, algo_num, keytag| DNSKEY with tag {keytag} uses unsupported algorithm {algo_num} ({algo_mnemo}) by this installation of Zonemaster. Fetched from the nameservers with IP addresses "{ns_ip_list}".
      DS02_DNSKEY_NOT_FOR_ZONE_SIGNING   | ERROR   | ns_ip_list, keytag                     | Flags field of DNSKEY record with tag {keytag} does not have ZONE bit set although DS with same tag is present in parent. Fetched from the nameservers with IP addresses "{ns_ip_list}".
      DS02_DNSKEY_NOT_SEP                | NOTICE  | ns_ip_list, keytag                     | Flags field of DNSKEY record with tag {keytag} does not have SEP bit set although DS with same tag is present in parent. Fetched from the nameservers with IP addresses "{ns_ip_list}".
      DS02_DNSKEY_NOT_SIGNED_BY_ANY_DS   | ERROR   | ns_ip_list                             | The DNSKEY RRset has not been signed by any DNSKEY matched by a DS record. Fetched from the nameservers with IP addresses "{ns_ip_list}".
      DS02_NO_DNSKEY_FOR_DS              | WARNING | ns_ip_list, keytag                     | The DNSKEY record with tag {keytag} that the DS refers to does not exist in the DNSKEY RRset. Fetched from the nameservers with IP "{ns_ip_list}".
      DS02_NO_MATCHING_DNSKEY_RRSIG      | WARNING | ns_ip_list, keytag                     | The DNSKEY RRset is not signed by the DNSKEY with tag {keytag} that the DS record refers to. Fetched from the nameservers with IP "{ns_ip_list}".
      DS02_NO_MATCH_DS_DNSKEY            | ERROR   | ns_ip_list, keytag                     | The DS record does not match the DNSKEY with tag {keytag} by algorithm or digest. Fetched from the nameservers with IP "{ns_ip_list}".
      DS02_NO_VALID_DNSKEY_FOR_ANY_DS    | ERROR   | ns_ip_list                             | There is no valid DNSKEY matched by any of the DS records. Fetched from the nameservers with IP addresses "{ns_ip_list}".
      DS02_RRSIG_NOT_VALID_BY_DNSKEY     | ERROR   | ns_ip_list, keytag                     | The DNSKEY RRset is signed with an RRSIG with tag {keytag} which cannot be validated by the matching DNSKEY. Fetched from the nameservers with IP addresses "{ns_ip_list}".

      The value in the Level column is the default severity level of the message. The
      severity level can be overridden in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].
      ## Test procedure

      In this section and unless otherwise specified below, the term "[DNSSEC Query]"
      follows the specification for DNS queries as specified in
      [DNS Query and Response Defaults]. The handling of the DNS responses on the DNS
      queries follow, unless otherwise specified below, what is specified for
      [DNSSEC Response] in the same specification.

      1.  Create the following empty sets:
          1.  DS record RDATA ("DS Record").
          2.  Name server IP and key tag from DS record ("No DNSKEY for DS").
          3.  Name server IP and key tag from DS record ("No Match DS DNSKEY").
          4.  Name server IP and DNSKEY record key tag ("DNSKEY Not for Zone Signing").
          5.  Name server IP and DNSKEY record key tag ("DNSKEY not SEP").
          6.  Name server IP and DNSKEY record key tag ("No Matching DNSKEY RRSIG").
          7.  Name server IP address, DNSKEY record key tag and DNSKEY algorithm code
              ("Algo Not Supported By ZM").
          8.  Name server IP and key tag from RRSIG record ("RRSIG Not Valid by DNSKEY").
          9.  Name server IP ("Responding Child Name Servers").
          10. DNSKEY record and key tag ("DNSKEY Matching DS").
          11. Name server IP ("Has DNSKEY Match DS").
          12. Name server IP ("Has DNSKEY RRSIG Match DS").

      2.  If the *Test Type* is "[undelegated]" do:
          1. If *Undelegated DS* is empty then do terminate this test case.
          2. Else add *Undelegated DS* as DS records to the *DS Record* set.

      3.  If *Test Type* is "normal", then:
          1. Create a [DNSSEC Query] with query type DS and query name *Child Zone*
             ("DS Query").
          2. Retrieve all name server IP addresses for the parent zone of
             *Child Zone* using [Method1] (store as "Parent NS IP").
          3. For each parent name server in *Parent NS IP* do:
             1. Send *DS Query* to the name server IP.
             2. If at least one of the following criteria is met, then go to next
                parent name server:
                1. There is no [DNSSEC Response].
                2. The RCODE in the [DNSSEC Response] is not "NoError"
                   ([IANA RCODE List]).
                3. The OPT record is absent in the [DNSSEC Response].
                4. The DO flag is unset in the [DNSSEC Response].
                5. The AA flag is not set in the [DNSSEC Response].
                6. There is no DS record with matching owner name in the answer
                   section of the [DNSSEC Response].
             3. Retrieve the DS records from the [DNSSEC Response] and add them to the
                *DS Record* set.
          4. If the *DS Record* set is empty exit this test case.

      4. Create a [DNSSEC Query] with query type DNSKEY and query name *Child Zone*
         ("DNSKEY Query").

      5.  Obtain the set of child name server IP addresses using [Method4] and
          [Method5] (store as "Child NS IP").

      6.  For each child name server in *Child NS IP* do:
          1. Send *DNSKEY Query* to the name server IP and collect the response.
          2. If at least one of the following criteria is met, then go to next
             child name server:
             1. There is no [DNSSEC Response].
             2. The RCODE in the [DNSSEC Response] is not "NoError"
                ([IANA RCODE List]).
             3. The OPT record is absent in the [DNSSEC Response].
             4. The DO flag is unset in the [DNSSEC Response].
             5. The AA flag is not set in the [DNSSEC Response].
             6. There is no DNSKEY record with matching owner name in the answer
                section of the [DNSSEC Response].
          3. Add the name server IP address to the *Responding Child Name Servers* set.
          4. Retrieve the DNSKEY RRset (store as "DNSKEY RRs") from the
             [DNSSEC Response].
          5. Retrieve the RRSIG records covering the DNSKEY RRset, possibly
             none (store as "DNSKEY RRSIG") from the [DNSSEC Response].
          6. Empty the *DNSKEY Matching DS* set.
          7. For each DS in *DS Records*, do:
             1. Find the equivalent DNSKEY in *DNSKEY RRs* by key ID (key tag). If
                there is more than one such DNSKEY, select the correct one.
             2. If matching DNSKEY is not found add DS key tag and name server IP to
                the *No DNSKEY for DS* set and go to next DS.
             3. Verify if the Zonemaster installation has support for the digest
                algorithm that created the DS:
                1. If no support, then ignore the following test if the DS matches
                   the DNSKEY.
                2. Else, if the DS values (algorithm and digest) do not match the
                   DNSKEY record then add DS key tag and name server IP to the
                   *No Match DS DNSKEY* set.
             4. If bit 7 of the DNSKEY flags field is unset (value 0), then do:
                1. Add DS key tag and name server IP to the
                   *DNSKEY Not for Zone Signing* set.
                2. Go to next DS.
             5. If bit 15 of the DNSKEY flags field is unset (value 0), then add the
                DNSKEY record key tag and name server IP to the *DNSKEY not SEP*
                set.
             6. Add the DNSKEY record and key tag to the *DNSKEY Matching DS*
                set.
             7. Add the name server IP to the *Has DNSKEY Match DS*
                set.
          8. For each DNSKEY in the *DNSKEY Matching DS* set, do:
             1. Look for an RRSIG record created by the DNSKEY in *DNSKEY RRSIG*.
                * Use key ID (key tag) to identify the corresponding RRSIG record.
                * If there is more than one such RRSIG record, select the correct one
                  by verifying the signature against the DNSKEY.
             2. If a matching RRSIG is not found, add DNSKEY record key tag and name
                server IP to the *No Matching DNSKEY RRSIG* set.
             3. Else, if the Zonemaster installation does not have support for the
                DNSKEY algorithm that created the RRSIG, then add name server IP,
                DNSKEY algorithm and DNSKEY key tag to the *Algo Not Supported By ZM*
                set.
             4. Else, if the RRSIG values (algorithm and signature) do not match
                the DNSKEY then add the key tag from the RRSIG record and name server
                IP to the *RRSIG Not Valid by DNSKEY* set.
             5. Else add the name server IP address to the *Has DNSKEY RRSIG Match DS*
                set.

      7.  If the *No DNSKEY for DS* set is non-empty, then for each key tag from the DS
          record from the set output *[DS02_NO_DNSKEY_FOR_DS]* with the key tag and the
          name servers IP addresses from the set.

      8.  If the *No Match DS DNSKEY* set is non-empty, then for each key tag from the
          DS record from the set output *[DS02_NO_MATCH_DS_DNSKEY]* with the key tag
          and the name servers IP addresses from the set.

      9.  If the *DNSKEY Not for Zone Signing* set is non-empty, then for each DNSKEY
          key tag from the set output *[DS02_DNSKEY_NOT_FOR_ZONE_SIGNING]* with the key
          tag and the name servers IP addresses from the set.

      10. If the *DNSKEY not SEP* set is non-empty, then for each DNSKEY key tag from
          the set output *[DS02_DNSKEY_NOT_SEP]* with the key tag and the name servers
          IP addresses from the set.

      11. If the *No Matching DNSKEY RRSIG* set is non-empty, then for each DNSKEY key
          tag from the set output *[DS02_NO_MATCHING_DNSKEY_RRSIG]* with the key tag
          and the name servers IP addresses from the set.

      12. If the *Algo Not Supported By ZM* set is non-empty, then output
          *[DS02_ALGO_NOT_SUPPORTED_BY_ZM]* for each DNSKEY key tag with the name
          server IP addresses, the key tag and the algorithm code from the set.

      13. If the *RRSIG Not Valid by DNSKEY* set is non-empty, then for each key tag
          from the RRSIG record from the set output *[DS02_RRSIG_NOT_VALID_BY_DNSKEY]*
          with the key tag and the name servers IP addresses from the set.

      14. Extract the name server IP addresses that are members of
          *Responding Child Name Servers* but are not members of *Has DNSKEY Match DS*
          set.

      15. If the subset from previous step is non-empty, then output
          *[DS02_NO_VALID_DNSKEY_FOR_ANY_DS]* with the subset of name server IP
          addresses.

      16. Else do:
          1. Extract the name server IP addresses that are members of
             *Responding Child Name Servers* but are not members of
             *Has DNSKEY RRSIG Match DS* set.
          2. If that subset is non-empty, then output
             *[DS02_DNSKEY_NOT_SIGNED_BY_ANY_DS]* with the subset of name server IP
             addresses.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, skip sending queries over that
      transport protocol. Output a message reporting that the transport protocol has
      been disabled.

      See the [DNSSEC README] document about DNSSEC algorithms.
  dnssec-03:
    Summary: Check iteration counts for NSEC3
    Description: |
      For an authoritative name server an increased number of NSEC3 iterations
      have a negative impact on performance.

      Section 10.3 in [RFC 5155](https://datatracker.ietf.org/doc/html/rfc5155#section-10.3)
      sets a maximum number of iterations depending on the DNSSEC key size -
      regardless of which algorithm is used.

      > A zone owner MUST NOT use a value higher than shown in the table
      > below for iterations for the given key size.  A resolver MAY treat a
      > response with a higher value as insecure, after the validator has
      > verified that the signature over the NSEC3 RR is correct.

      |Key Size |Iterations |
      |:--------|:----------|
      |1024     |150        |
      |2048     |500        |
      |4096     |2,500      |

      Section 5.3.2 in [RFC 6781](https://datatracker.ietf.org/doc/html/rfc6781#section-5.3.2)
      describes the consequences for an authoritative name server in more detail, and
      references the [NSEC Hash Performance](https://www.nlnetlabs.nl/downloads/publications/nsec3_hash_performance.pdf)
      study from NLNet Labs.

      > Choosing a value of 100 iterations is deemed to be a
      > sufficiently costly, yet not excessive, value: In the worst-case
      > scenario, the performance of name servers would be halved, regardless
      > of key size.

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

       1. Obtain a set of name server IP addresses using [Method4] and [Method5].
       2. Create an NSEC3PARAM query for the apex of the child zone.
       3. Create a DNSKEY query for the apex of the child zone.
       4. Send the NSEC3PARAM query over UDP to each name server IP address
          until a response is received or until the set is exhausted.
       5. If there is not use of NSEC3 there is no NSEC3PARAM RR in the child zone,
          and this test case ends here.
       6. The iterations value is extracted from the NSEC3PARAM RR.
       7. If the number of iterations is higher than 100, this test case emits
          at least a warning.
       8. Send the DNSKEY query over UDP to each name server IP address
          until a response is received or until the set is exhausted.
       9. Extract the smallest key from the zone.
      10. Depending on the key sizes listed in section 10.3 of RFC 5155, if the
          number of iterations is larger than the corresponding key size of
          the smallest key, this test case fails.
      ### Outcome(s)

      If the NSEC3 iterations value is higher than 100, this test case gives
      a warning. If it is higher than the number recommended for the corresponding
      key size, this test case fails.

      ### Special procedural requirements

      This test is only fully performed if the zone uses NSEC3 (has the
      NSEC3PARAM RR in the zone).

  dnssec-04:
    Summary: Checks the durations of the signatures for the DNSKEY and SOA RRsets
    Description: |
      Having RRSIG signature lifetimes last for too long opens up for DNS replay
      attacks. Having too short RRSIG signature lifetimes is likely to have
      a major operational impact if the master name server is down for that long.

      There is no clear recommendation of the exact validity periods to use with
      DNSSEC. Shorter validity than 12 hours until expiration will give a serious
      operational problem just in case of temporary network problems, and longer
      than 180 days will create wide open holes for replay attacks.

      The considerations are described in [RFC6781](
      https://datatracker.ietf.org/doc/html/rfc6781).

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. Obtain a set of name server IP addresses using [Method4] and [Method5].
      2. Create a DNSKEY query with DO flag set for the apex of the child zone.
      3. Create a SOA query with DO flag set for the apex of the child zone.
      4. Send the DNSKEY query over UDP to each name server IP address until
         a response is received or until the set is exhausted.
      5. Send the SOA query over UDP to each name server IP address until
         a response is received or until the set is exhausted.
      6. If any RRSIG validity is found where the expiration time already has
         passed, this test case fails.
      7. If any RRSIG validity time is shorter than 12 hours (from "now"),
         this test case fails.
      8. If any RRSIG validity time is longer than 180 days (from "now"), this
         test fails.
      9. If any RRSIG validity from inception to expiration is longer than 180
         days, this test case fails.

      ### Outcome(s)

      If any of the signature expirations time is either shorter than 12 hours or
      longer than 180 days, this test case fails.

      ### Special procedural requirements

      Test case is only performed if RRSIG RRs are found in the answers.
  dnssec-05:
    Summary: Check DNSKEY algorithms
    Description: |
      A domain name (zone) should only use DNSKEY algorithms that are specified
      by [RFC 8624], section 3.1 and the [IANA registry] of *DNSSEC Algorithm
      Numbers* to be used for DNSSEC signing. A public domain name (zone) should not use
      private algorithms.

      If [RFC 8624] and [IANA registry] disagree on the same algorithm, the
      RFC takes precedence until the registry has a been updated with a
      reference to the RFC.

      The table of algorithms below is for reference only and is copied from [IANA
      registry]. It is here to make it easier to read the steps when symbolic
      names are given. This is only an excerpt from the table. The full table is
      available at [IANA registry].

      Algorithm number | Algorithm (or description)
      :----------------|:-----------------------------------
      0                | (Delete DS)
      1                | RSA/MD5
      2                | Diffie-Hellman
      3                | DSA/SHA1
      4                | (Reserved)
      5                | RSA/SHA-1
      6                | DSA-NSEC3-SHA1
      7                | RSASHA1-NSEC3-SHA1
      8                | RSA/SHA-256
      9                | (Reserved)
      10               | RSA/SHA-512
      11               | (Reserved)
      12               | GOST R 34.10-2001
      13               | ECDSA Curve P-256 with SHA-256
      14               | ECDSA Curve P-384 with SHA-384
      15               | Ed25519
      16               | Ed448
      17-122           | (Unassigned)
      123-251          | (Reserved)
      252              | (Indirect Keys)
      253              | (Private algorithm)
      254              | (Private algorithm OID)
      255              | (Reserved)
      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * The domain name to be tested ("Child Zone").
      * The status of all algorithms from [RFC 8624] and [IANA registry]
        ("Algorithm Status").

      ## Ordered description of steps to be taken to execute the test case

      1. Create a DNSKEY query with DO flag set for the apex of the
         *Child Zone*.

      2. Retrieve all name server IP addresses for the
         *Child Zone* using [Method4] and [Method5].

      3. Repeat the following steps for each name server IP address:

         1. Send the DNSKEY query over UDP.
         2. If no DNS response is returned, then output *[NO_RESPONSE]*.
         3. Else if the DNS response does not contain an DNSKEY RRset,
            then output *[NO_RESPONSE_DNSKEY]*.
         4. Else extract the algorithm numbers from each DNSKEY record and
            compare the algorithm number to *Algorithm Status*.
            1. If the algorithm is deprecated (algorithm 1, 3, 6 or 12)
               output *[ALGORITHM_DEPRECATED]*.
            2. If the algorithm is reserved (algorithm
               4, 9, 11, 123-251 or 255), output *[ALGORITHM_RESERVED]*.
            3. If the algorithm is unassigned (algorithm
               17-122), output *[ALGORITHM_UNASSIGNED]*.
            4. If the algorithm is private algorithm
               (algorithm 253-254), output *[ALGORITHM_PRIVATE]*.
            5. If the algorithm is not meant for zone signing (algorithm
               0, 2 or 252), output *[ALGORITHM_NOT_ZONE_SIGN]*.
            6. If the algorithm is not rekommended for zone signing (algorithm
               5, 7 or 10), output *[ALGORITHM_NOT_RECOMMENDED]*.
            7. If no message has been outputted for the DNSKEY (i.e. algorithm
               8, 13, 14, 15 or 16), output *[ALGORITHM_OK]*.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                       | Default severity level
      :-----------------------------|:-----------------------------------
      NO_RESPONSE                   | DEBUG
      NO_RESPONSE_DNSKEY            | WARNING
      ALGORITHM_DEPRECATED          | ERROR
      ALGORITHM_RESERVED            | ERROR
      ALGORITHM_UNASSIGNED          | ERROR
      ALGORITHM_NOT_RECOMMENDED     | WARNING
      ALGORITHM_PRIVATE             | ERROR
      ALGORITHM_NOT_ZONE_SIGN       | ERROR
      ALGORITHM_OK                  | INFO

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      See the [DNSSEC README] document about DNSSEC algorithms.

      The test case is only performed if some DNSKEY record is found in the
      *Child Zone*.
  dnssec-06:
    Summary: Check for DNSSEC extra processing at child nameservers
    Description: |
      In order for an authoritative name server to be DNSSEC compliant,
      it must serve DNSSEC signatures (RRSIG) as additional data in a DNS answer.
      This additional processing is described in section 3.1 of [RFC 4035](
      https://datatracker.ietf.org/doc/html/rfc4035#section-3.1).

      ### Inputs

      The domain name to be tested.

      ### Ordered description of steps to be taken to execute the test case

      1. For each name server configured for the domain:
      2. Retrieve the DNSKEY RR set from the child zone.
      3. If the answer from the query does contain a DNSKEY _and_ RRSIG, this
         test case passes.
      4. If there is no DNSKEY RR or RRSIG RR in the answer and the RCODE is
         NOERROR, this test case fails.

      ### Outcome(s)

      If any of the name servers configured for the domains fail to answer with
      DNSSEC data, this test case fails.
  dnssec-08:
    Summary: Check that the DNSKEY RRset is signed
    Description: |
      A DNSSEC signed zone should have a DNSKEY RRset in the zone apex
      ([RFC 4035][RFC 4035#section-2.1], section 2.1) and that RRset
      should be signed by a key that matches one of the records in the
      DNSKEY RRset ([RFC 4035][RFC 4035#section-2.2], section 2.2).

      This test case will verify if the *Child Zone* meets that
      requirement.
      ## Scope

      It is assumed that *Child Zone* is tested and reported by [Connectivity01]. This test
      case will just ignore non-responsive name servers or name servers not giving a
      correct DNS response for an authoritative name server.

      This test case is only relevant if the zone has been DNSSEC signed.
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      ## Summary

      * If no DNSKEY records are found, then further investigation will not be done
        and no messages will be outputted.

      Message Tag outputted              | Level   | Arguments          | Description of when message tag is outputted
      :----------------------------------|:--------|:-------------------|:--------------------------------------------
      DS08_ALGO_NOT_SUPPORTED_BY_ZM      | NOTICE  | ns_ip_list, algo_mnemo, algo_num, keytag | This installation of Zonemaster does not support the DNSKEY algorithm.
      DS08_DNSKEY_RRSIG_EXPIRED          | ERROR   | ns_ip_list, keytag | DNSKEY RRset is signed with an RRSIG that has expired.
      DS08_DNSKEY_RRSIG_NOT_YET_VALID    | ERROR   | ns_ip_list, keytag | DNSKEY RRset is signed with a not yet valid RRSIG.
      DS08_MISSING_RRSIG_IN_RESPONSE     | ERROR   | ns_ip_list         | DNSKEY is unsigned which is against expectation.
      DS08_NO_MATCHING_DNSKEY            | ERROR   | ns_ip_list, keytag | DNSKEY RRset is signed with an RRSIG that does not match any DNSKEY.
      DS08_RRSIG_NOT_VALID_BY_DNSKEY     | ERROR   | ns_ip_list, keytag | DNSKEY RRset is signed with an RRSIG that cannot be validated by the matching DNSKEY.

      The value in the Level column is the default severity level of the message. The
      severity level can be changed in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].
      ## Test procedure

      1.  Create a DNSKEY query with DO flag set for *Child Zone* ("DNSKEY Query").

      2.  Retrieve all name server IP addresses for the
          *Child Zone* using [Method4] and [Method5] ("NS IP").

      3.  Create the following empty sets:
          1.  Name server IP address ("DNSKEY without RRSIG").
          2.  Name server IP address and RRSIG key tag ("DNSKEY RRSIG not yet valid").
          3.  Name server IP address and RRSIG key tag ("DNSKEY RRSIG expired").
          4.  Name server IP address and RRSIG key tag ("No matching DNSKEY").
          5.  Name server IP address and RRSIG key tag ("RRSIG not valid by DNSKEY").
          6.  Name server IP address, DNSKEY record key tag and DNSKEY algorithm code
              ("Algo Not Supported By ZM").

      4.  For each name server IP address in *NS IP* do:

          1. Send *DNSKEY Query* to the name server IP.
          2. If at least one of the following criteria is met, then go to next name
             server IP:
               1. There is no DNS response.
               2. The RCODE of response is not "NoError" ([IANA RCODE List]).
               3. The AA flag is not set in the response.
               4. There is no DNSKEY record with matching owner name in the answer
                  section.
          3. Retrieve the DNSKEY records and its RRSIG records from the answer section.
          4. If there is no RRSIG for the DNSKEY record, then add the name server IP
             address to the *DNSKEY without RRSIG* set and go to next name server IP.
          8. Else, for each DNSKEY RRSIG record do:
             1. If the RRSIG record start of validity is after the time of the
                test, then add name server IP and RRSIG key tag to the
                *DNSKEY RRSIG not yet valid* set.
             2. Else, if the RRSIG record end of validity is before the time of the
                test, then add name server IP and RRSIG key tag to the
                *DNSKEY RRSIG expired* set.
             3. Else, if the Zonemaster installation does not have support for the
                DNSKEY algorithm that created the RRSIG, then add name server IP,
                DNSKEY algorithm and DNSKEY key tag to the *Algo Not Supported By ZM*
                set.
             4. Else, if the RRSIG does not match any DNSKEY, then add the name server
                IP and the RRSIG key tag to the *No matching DNSKEY* set.
             5. Else, if the RRSIG cannot be validated by the matching DNSKEY record,
                then add the name server
                IP and the RRSIG key tag to the *RRSIG not valid by DNSKEY* set.

      6.  If the *DNSKEY without RRSIG* set is non-empty, then output
          *[DS08_MISSING_RRSIG_IN_RESPONSE]* with the name servers IP addresses from
          the set.

      7.  If the *DNSKEY RRSIG not yet valid* set is non-empty, then for each RRSIG key tag
          from the set output *[DS08_DNSKEY_RRSIG_NOT_YET_VALID]* with the key tag and the
          name servers IP addresses from the set.

      8.  If the *DNSKEY RRSIG expired* set is non-empty, then for each RRSIG key tag
          from the set output *[DS08_DNSKEY_RRSIG_EXPIRED]* with the key tag and the
          name servers IP addresses from the set.

      9.  If the *No matching DNSKEY* set is non-empty, then for each RRSIG key tag
          from the set output *[DS08_NO_MATCHING_DNSKEY]* with the key tag and the
          name servers IP addresses from the set.

      10. If the *RRSIG not valid by DNSKEY* set is non-empty, then for each RRSIG key
          ID from the set output *[DS08_RRSIG_NOT_VALID_BY_DNSKEY]* with the key tag and
          the name servers IP addresses from the set.

      11. If the *Algo Not Supported By ZM* set is non-empty, then output
          *[DS08_ALGO_NOT_SUPPORTED_BY_ZM]* for each DNSKEY key tag with the name
          server IP addresses, the key tag and the algorithm name and code from the set.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      See the [DNSSEC README] document about DNSSEC algorithms.
  dnssec-09:
    Summary: Check that the SOA RRset is signed
    Description: |
      If the zone is signed, the SOA RR should be signed with a valid RRSIG
      using a DNSKEY from the DNSKEY RR set. This is described
      in [RFC 4035][RFC 4035#section-2.2], section 2.2.

      This test case will verify if the *Child Zone* meets that
      requirement.
      ## Scope

      It is assumed that *Child Zone* is tested and reported by [Connectivity01]. This test
      case will just ignore non-responsive name servers or name servers not giving a
      correct DNS response for an authoritative name server.

      Inconsistencies in the SOA record are expected to be caught by [Consistency01],
      [Consistency02], [Consistency03] and [Consistency06].

      Inconsistencies in the DNSKEY RRset are expected to be caught by [DNSSEC08].

      This test case is only relevant if the zone has been DNSSEC signed.
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      ## Summary

      * If no DNSKEY records are found, then further investigation will not be done
        and no messages will be outputted.

      Message Tag outputted              | Level   | Arguments          | Description of when message tag is outputted
      :----------------------------------|:--------|:-------------------|:--------------------------------------------
      DS09_ALGO_NOT_SUPPORTED_BY_ZM      | NOTICE  | ns_ip_list, algo_mnemo, algo_num, keytag | This installation of Zonemaster does not support the DNSKEY algorithm.
      DS09_MISSING_RRSIG_IN_RESPONSE     | ERROR   | ns_ip_list         | SOA is unsigned which is against expectation
      DS09_NO_MATCHING_DNSKEY            | ERROR   | ns_ip_list, keytag | SOA is signed with an RRSIG that does not match any DNSKEY
      DS09_RRSIG_NOT_VALID_BY_DNSKEY     | ERROR   | ns_ip_list, keytag | SOA is signed with an RRSIG that cannot be validated by the matching DNSKEY
      DS09_SOA_RRSIG_EXPIRED             | ERROR   | ns_ip_list, keytag | SOA is signed with an RRSIG that has expired
      DS09_SOA_RRSIG_NOT_YET_VALID       | ERROR   | ns_ip_list, keytag | SOA is signed with a not yet valid RRSIG

      The value in the Level column is the default severity level of the message. The
      severity level can be changed in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].
      ## Test procedure

      1.  Create a DNSKEY query with DO flag set for *Child Zone* ("DNSKEY Query").

      2.  Create an SOA query with DO flag set for *Child Zone* ("SOA Query").

      3.  Retrieve all name server IP addresses for the
          *Child Zone* using [Method4] and [Method5] ("NS IP").

      4.  Create the following empty sets:
          1.  Name server IP address ("SOA without RRSIG").
          2.  Name server IP address and RRSIG key tag ("SOA RRSIG not yet valid").
          3.  Name server IP address and RRSIG key tag ("SOA RRSIG expired").
          4.  Name server IP address and RRSIG key tag ("No matching DNSKEY").
          5.  Name server IP address and RRSIG key tag ("RRSIG not valid by DNSKEY").
          6.  Name server IP address, DNSKEY record key tag and DNSKEY algorithm code
              ("Algo Not Supported By ZM").

      5.  For each name server IP address in *NS IP* do:

          1. Send *DNSKEY Query* to the name server IP.
          2. If at least one of the following criteria is met, then go to next name
             server IP:
               1. There is no DNS response.
               2. The RCODE of response is not "NoError" ([IANA RCODE List]).
               3. The AA flag is not set in the response.
               4. There is no DNSKEY record with matching owner name in the answer
                  section.
          3. Retrieve the DNSKEY records with matching owner name from the answer
             section (any DNSKEY records with non-matching owner name are ignored).
          4. Send *SOA Query* over UDP to the name server IP.
          5. If at least one of the following criteria is met, then go to next name
             server IP:
               1. There is no DNS response.
               2. The RCODE of response is not "NoError" ([IANA RCODE List]).
               3. The AA flag is not set in the response.
               4. There is no SOA record with matching owner name in the answer
                  section.
          6. Retrieve the SOA record with matching owner name and its RRSIG record.
             * Retrieve only one SOA record if there are multiple records. Any SOA
               records with non-matching owner name are ignored.
          7. If there is no RRSIG for the SOA record, then add the name server IP
             address to the *SOA without RRSIG* set and go to next name server IP.
          8. Else, for each SOA RRSIG record do:
             1. If the RRSIG record start of validity is after the time of the
                test, then add name server IP and RRSIG key tag to the
                *SOA RRSIG not yet valid* set.
             2. Else, if the RRSIG record end of validity is before the time of the
                test, then add name server IP and RRSIG key tag to the
                *SOA RRSIG expired* set.
             3. Else, if the Zonemaster installation does not have support for the
                DNSKEY algorithm that created the RRSIG, then add name server IP,
                DNSKEY algorithm and DNSKEY key tag to the *Algo Not Supported By ZM*
                set.
             4. Else, if the RRSIG does not match any DNSKEY, then add the name server
                IP and the RRSIG key tag to the *No matching DNSKEY* set.
             5. Else, if the RRSIG cannot be validated by the matching DNSKEY record,
                then add the name server
                IP and the RRSIG key tag to the *RRSIG not valid by DNSKEY* set.

      6.  If the *SOA without RRSIG* set is non-empty, then output
          *[DS09_MISSING_RRSIG_IN_RESPONSE]* with the name servers IP addresses from
          the set.

      7.  If the *SOA RRSIG not yet valid* set is non-empty, then for each RRSIG key tag
          from the set output *[DS09_SOA_RRSIG_NOT_YET_VALID]* with the key tag and the
          name servers IP addresses from the set.

      8.  If the *SOA RRSIG expired* set is non-empty, then for each RRSIG key tag
          from the set output *[DS09_SOA_RRSIG_EXPIRED]* with the key tag and the
          name servers IP addresses from the set.

      9.  If the *No matching DNSKEY* set is non-empty, then for each RRSIG key tag
          from the set output *[DS09_NO_MATCHING_DNSKEY]* with the key tag and the
          name servers IP addresses from the set.

      10. If the *RRSIG not valid by DNSKEY* set is non-empty, then for each RRSIG key
          ID from the set output *[DS09_RRSIG_NOT_VALID_BY_DNSKEY]* with the key tag and
          the name servers IP addresses from the set.

      11. If the *Algo Not Supported By ZM* set is non-empty, then output
          *[DS09_ALGO_NOT_SUPPORTED_BY_ZM]* for each DNSKEY key tag with the name
          server IP addresses, the key tag and the algorithm name and code from the set.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      See the [DNSSEC README] document about DNSSEC algorithms.
  dnssec-10:
    Summary: Check for the presence of either NSEC or NSEC3, with proper coverage and signatures
    Description: |
      When DNSSEC is enabled, NSEC or NSEC3 records provide a secure denial
      of existence for records not present in the zone. This test case
      verifies that correct NSEC or NSEC3 records with valid signatures are
      returned for a query for an non-existent name.

      Furthermore, it is verified that the name servers for the zone are consistent
      about NSEC and NSEC3, i.e. either all servers should use NSEC or all servers
      should use NSEC3. It is never permitted to serve both NSEC and NSEC3 for the
      same zone.

      The use of the NSEC RR type is described in
      [RFC 4035][RFC 4035#section-3.1.3], section 3.1.3, and
      the description of the NSEC RR itself is in
      [RFC 4034][RFC 4034#section-4], section 4.

      The description of the NSEC3 RR is in
      [RFC 5155][RFC 5155#section-3], section 3, and its
      use in the DNS response is described in
      [RFC 5155][RFC 5155#section-7.2], section 7.2.
      ## Scope

      This test case will just ignore non-responsive name servers or name servers not
      giving a correct DNS response for an authoritative name server (covered by
      [Connectivity01]).

      This test case is only relevant if the zone has been DNSSEC signed.
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      * "[Non-Existent Query Name]" - A name constructed by prepending
        *Child Zone* with a label (e.g. "xx--zpeqz4v66tckbqkyw35k--xx") created by the
        following steps, resulting in e.g. "xx--zpeqz4v66tckbqkyw35k--xx.exemple.com".
        * Use the string "xx--" as a prefix for the label.
        * As middle part of the label, use a mixed string of 20 characters from the set
          "a-z0-9".
        * Use the string "--xx" as a suffix for the label.
      ## Summary

      * If no DNSKEY records are found, then further investigation will not be done
        and no messages will be outputted.

      Message Tag outputted              | Level   | Arguments  | Description of when message tag is outputted
      :----------------------------------|:--------|:-----------|:--------------------------------------------
      DS10_ALGO_NOT_SUPPORTED_BY_ZM      | NOTICE  | ns_ip_list, algo_mnemo, algo_num, keytag | This installation of Zonemaster does not support the DNSKEY algorithm.
      DS10_ANSWER_VERIFY_ERROR           | ERROR   | ns_ip_list, domain, rrtype | RRSIG on record or records in answer section cannot be verified.
      DS10_HAS_NSEC                      | INFO    |            | Consistent NSEC returned from servers.
      DS10_HAS_NSEC3                     | INFO    |            | Consistent NSEC3 returned from servers.
      DS10_INCONSISTENT_NSEC_NSEC3       | ERROR   |2 ns_ip_list| Some servers return NSEC, others return NSEC3.
      DS10_MISSING_NSEC_NSEC3            | ERROR   | ns_ip_list | Missing expected NSEC or NSEC3 in a signed zone.
      DS10_MIXED_NSEC_NSEC3              | ERROR   | ns_ip_list | Both NSEC and NSEC3 are returned from the same server.
      DS10_NAME_NOT_COVERED_BY_NSEC      | ERROR   | ns_ip_list | The non-existent name is not correctly covered by the NSEC records.
      DS10_NAME_NOT_COVERED_BY_NSEC3     | ERROR   | ns_ip_list | The non-existent name is not correctly covered by the NSEC3 records.
      DS10_NON_EXISTENT_RESPONSE_ERROR   | ERROR   | ns_ip_list | No or error in response of an expected non-existent name.
      DS10_NSEC3_MISSING_SIGNATURE       | ERROR   | ns_ip_list | Missing signatures for NSEC3 record or records.
      DS10_NSEC3_RRSIG_VERIFY_ERROR      | ERROR   | ns_ip_list | The signature or signatures on the NSEC3 record or records cannot be correctly verfied.
      DS10_NSEC_MISSING_SIGNATURE        | ERROR   | ns_ip_list | Missing signatures for NSEC record or records.
      DS10_NSEC_RRSIG_VERIFY_ERROR       | ERROR   | ns_ip_list | The signature or signatures on the NSEC record or records cannot be correctly verfied.
      DS10_UNSIGNED_ANSWER               | ERROR   | ns_ip_list, domain, rrtype | RRSIG is missing for record or records in the answer section.

      The value in the Level column is the default severity level of the message. The
      severity level can be changed in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].
      ## Test procedure

      1.  Create a DNSKEY query with DO flag set for *Child Zone* ("DNSKEY Query").

      2.  Create an A query with DO flag set for *[Non-Existent Query Name]*
          ("Non-Existent Query").

      3.  Retrieve all name server IP addresses for the
          *Child Zone* using [Method4] and [Method5] ("NS IP").

      4.  Create the following empty sets:
          1.  Name server IP, RR type and owner name ("Unsigned Answer").
          2.  Name server IP, RR type and owner name("Answer Verify Error").
          3.  Name server IP address ("Has NSEC").
          4.  Name server IP address ("Has NSEC3").
          5.  Name server IP address ("No NSEC Or NSEC3").
          6.  Name server IP address ("Mixed NSEC/NSEC3").
          7.  Name server IP address ("Name Not Covered By NSEC").
          8.  Name server IP address ("Name Not Covered By NSEC3").
          9.  Name server IP address ("NSEC Missing Signature").
          10. Name server IP address ("NSEC3 Missing Signature").
          11. Name server IP address ("Non-Existent Response Error").
          12. Name server IP address ("NSEC RRSIG Verify Error").
          13. Name server IP address ("NSEC3 RRSIG Verify Error").
          14. Name server IP address, DNSKEY record key tag and DNSKEY algorithm code
             ("Algo Not Supported By ZM").

      5.  For each name server IP address in *NS IP* do:

          1. Send *DNSKEY Query* to the name server IP.
          2. If at least one of the following criteria is met, then go to next name
             server IP:
               1. There is no DNS response.
               2. The RCODE of response is not "NoError" ([IANA RCODE List]).
               3. The AA flag is not set in the response.
               4. There is no DNSKEY record with matching owner name in the answer section.
          3. Retrieve the DNSKEY records from the answer section.
          4. Send *Non-Existent Query* over UDP to the name server IP.
          5. If at least one of the following createria is met, then add the name
             server IP to the *Non-Existent Response Error* set and go to next name
             server IP:
               1. There is no DNS response.
               2. The RCODE of response is neither "NoError" nor "NXDomain"
                  ([IANA RCODE List]).
               3. The AA flag is not set in the response.
          6. If the following criteria are met go to next name server IP:
             1. The The RCODE of response is "NoError" ([IANA RCODE List]).
             2. The answer section has an RRset of RR type "A" ([IANA RR Type List])
                and either:
                1. The "A" RRset has the same owner name as the query name, or
                2. There are one or more record of RR type "CNAME"
                   ([IANA RR Type List]) chaining from the query name to the owner name
                   of the "A" RRset.
             3. The answer section has RRsig record or records in the answer section
                meeting the following criteria:
                1. There is at least one RRsig for the "A" RRset in the answer section.
                2. If there are CNAME records in the answer section, then there is at
                   least one RRsig for each CNAME record.
                3. None of the RRsig records are for a wildcard.
          7. If the following criteria are met go to next name server IP:
             1. The The RCODE of response is "NoError" ([IANA RCODE List]).
             2. The answer section has one or more record of RR type "CNAME"
                ([IANA RR Type List]) in a chain where first record has the onwer name
                matching the query name.
             3. The answer section has RRsig record or records in the answer section
                meeting the following criteria:
                1. There is at least one RRsig for each CNAME record.
                2. None of the RRsig records are for a wildcard.
             4. There are neither NSEC nor NSEC3 records in the authority section.
          8. If the answer section has any RRset of RR type "A" or "CNAME"
             ([IANA RR Type List]) do ("RRset"):
             1. For each RRset in *RRset* add name server IP, RR type and owner name
                to the *Unsigned Answer* set if both criteria are true:
                1. There is no RRSIG record covering the owner name of the RRset.
                2. There is no RRSIG record covering a wild card record whose owner
                   name covers the owner name of the RRset.
             2. Go to next name server IP if any data was added to the
                *Unsigned Answer* set in the loop above.
             3. For each RRset in *RRset* add name server IP, RR type and owner name to
                the *Answer Verify Error* set if its RRSIG cannot be verified by the
                corresponding DNSKEY or DNSKEY is missing.
             2. Go to next name server IP if any data was added to the
                *Answer Verify Error* set in the loop above.
          9.  If the authority section has both NSEC and NSEC3 records, add the name
              server IP to the *Mixed NSEC/NSEC3* set.
          10. Else, if the authority section has neither NSEC nor NSEC3 records, then
              add the name server IP to the *No NSEC Or NSEC3* set.
          11. Else (the authority section has one or more NSEC records but no NSEC3
              records or one or more NSEC3 records but no NSEC records) do:
              1. Add the name server IP to the *Has NSEC* set (*Has NSEC3*
                 set).
              2. Retrieve all NSEC (NSEC3) records from the response.
              3. Verify if the NSEC (NSEC3) records cover the
                 *[Non-Existent Query Name]*.
                 * If not then add the name server IP to the
                  *Name Not Covered By NSEC* (*Name Not Covered By NSEC3*) set.
              4. Retrieve the RRSIG records for the retrieved NSEC records
                 (NSEC3 records).
              5. If any of the NSEC records (NSEC3 records) do not have
                 a matching RRSIG record, then add the name server IP to the
                 *NSEC Missing Signature* (*NSEC3 Missing Signature*) set.
              6. If no NSEC (NSEC3) record was signed, go to next name server IP.
              7. Compare the RRSIG records with the retrieved DNSKEY records.
              8. For each NSEC RRSIG (NSEC3 RRSIG) do:
                 1. Verify the RRSIG record by the DNSKEY records.
                 2. If the Zonemaster installation does not have support for the DNSKEY
                    algorithm that created the RRSIG, then add name server IP, DNSKEY
                    algorithm and DNSKEY key tag to the *Algo Not Supported By ZM* set.
                 2. Else, if one or more of the following criteria is met, add the name
                    server IP to the *NSEC RRSIG Verify Error*
                    (*NSEC3 RRSIG Verify Error*) set.
                    1. No DNSKEY records are available.
                    2. The RRSIG record has a validity period that starts after or ends
                       before the time of test execution.
                    3. There is no DNSKEY that matches RRSIG by key tag.
                    4. The RRSIG cannot be validated by the DNSKEY record appointed.
      6.  If the *Non-Existent Response Error* set is non-empty then output
          *[DS10_NON_EXISTENT_RESPONSE_ERROR]* with the name server IP addresses from
          the set.

      7.  If the *Unsigned Answer* set is non-empty then for each owner name and RR
          type output *[DS10_UNSIGNED_ANSWER]* with owner name, RR type and name server
          IP addresses.

      8.  If the *Answer Verify Error* set is non-empty then for each owner name and RR
          type output *[DS10_ANSWER_VERIFY_ERROR]* with owner name, RR type and name
          server IP addresses.

      9.  If the *No NSEC Or NSEC3* set is non-empty then output
          *[DS10_MISSING_NSEC_NSEC3]* with the name server IP addresses from the set.

      10. If both the *Has NSEC* and the *Has NSEC3* are non-empty, then output
          *[DS10_INCONSISTENT_NSEC_NSEC3]* with the name server IP addresses from the
          sets (two sets of name server IP addresses).

      11. If the *Mixed NSEC/NSEC3* set is non-empty, then output
          *[DS10_MIXED_NSEC_NSEC3]* with the name server IP addresses from the set.

      12. If the *Has NSEC* set is non-empty and all the following sets are empty, then
          output *[DS10_HAS_NSEC]*:
          1. *No NSEC Or NSEC3* set
          2. *Has NSEC3* set
          3. *Mixed NSEC/NSEC3* set

      13. If the *Has NSEC3* set is non-empty and all the following sets are empty,
          then output *[DS10_HAS_NSEC3]*:
          1. *No NSEC Or NSEC3* set
          2. *Has NSEC* set
          3. *Mixed NSEC/NSEC3* set

      14. If the *Name Not Covered By NSEC* set is non-empty then output
          *[DS10_NAME_NOT_COVERED_BY_NSEC]* with the name server IP addresses from the
          set.

      15. If the *Name Not Covered By NSEC3* set is non-empty then output
          *[DS10_NAME_NOT_COVERED_BY_NSEC3]* with the name server IP addresses from the
          set.

      16. If the *NSEC Missing Signature* set is non-empty then output
          *[DS10_NSEC_MISSING_SIGNATURE]* with the name server IP addresses from the
          set.

      17. If the *NSEC3 Missing Signature* set is non-empty then output
          *[DS10_NSEC3_MISSING_SIGNATURE]* with the name server IP addresses from the
          set.

      18. If the *NSEC RRSIG Verify Error* set is non-empty, then output
          *[DS10_NSEC_RRSIG_VERIFY_ERROR]* with the name server IP addresses from the
          set.

      19. If the *NSEC3 RRSIG Verify Error* set is non-empty, then output
          *[DS10_NSEC3_RRSIG_VERIFY_ERROR]* with the name server IP addresses from the
          set.

      20. If the *Algo Not Supported By ZM* set is non-empty, then output
          *[DS10_ALGO_NOT_SUPPORTED_BY_ZM]* for each DNSKEY key tag with the name
          server IP addresses, the key tag and the algorithm name and code from the set.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      See the [DNSSEC README] document about DNSSEC algorithms.

      ## Terminology

      ### The Non-Existent Query Name

      The term "The Non-Existent Query Name" is used for a name in the *Child Zone*,
      just below apex constructed for this test case to, with high certainty, not
      exist, as a directly defined name. The first label starts with "xx--" which
      should not be used as of [RFC 5890][RFC 5890#section-2.3.1], section 2.3.1.
  dnssec-13:
    Summary: Check that all DNSKEY algorithms are used to sign the zone
    Description: |
      From [RFC 6840][RFC 6840#section-5.11], section 5.11:

      > The DS RRset and DNSKEY RRset are used to signal which algorithms are used to
      > sign a zone. [...] The zone MUST also be signed with each algorithm (though
      > not each key) present in the DNSKEY RRset. [...]

      To verify that the whole zone is signed with all algorithms require access to the
      complete zone, which is generally not possible for public zones. This test case
      is limited to three RRsets that must be present in a signed zone, the SOA RRset,
      the NS RRset and the DNSKEY RRset.

      This test case will verify that for each DNSKEY algorithm, there is a RRSIG of
      that algorithm for the three selected RRsets.
      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01], [DNSSEC08] and
      [DNSSEC09]. Issues covered by [Connectivity01] (basic name server issues), [DNSSEC08]
      (signing of DNSKEY RRset) and [DNSSEC09] (signing of SOA RRset) will not result
      in messagess from this test case.
      ## Inputs

      * "Child Zone" - The domain name to be tested.
      ## Summary

      * If the name server reports no DNSKEY RRset, then this test case will not test
        or report anything.
      * This test case will not report anything unless there is an issue to report.

      Message Tag outputted         | Level   | Arguments                        | Description of when message tag is outputted
      :-----------------------------|:--------|:---------------------------------|:--------------------------------------------
      DS13_ALGO_NOT_SIGNED_DNSKEY   | WARNING | ns_ip_list, algo_mnemo, algo_num | The DNSKEY RRset is not signed with an algorithm present in the DNSKEY RRset
      DS13_ALGO_NOT_SIGNED_NS       | WARNING | ns_ip_list, algo_mnemo, algo_num | The NS RRset is not signed with an algorithm present in the DNSKEY RRset
      DS13_ALGO_NOT_SIGNED_SOA      | WARNING | ns_ip_list, algo_mnemo, algo_num | The SOA RRset is not signed with an algorithm present in the DNSKEY RRset

      The value in the Level column is the default severity level of the message. The
      severity level can be changed in the [Zonemaster-Engine profile]. Also see the
      [Severity Level Definitions] document.

      The argument names in the Arguments column lists the arguments used in the
      message. The argument names are defined in the [argument list].
      ## Test procedure

      1. Create a DNSKEY query with DO flag set for the apex of the
         *Child Zone* ("DNSKEY Query").

      2. Create a SOA query with DO flag set for the apex of the
         *Child Zone* ("SOA Query").

      3. Create a NS query with DO flag set for the apex of the
         *Child Zone* ("NS Query").

      4. Retrieve all name server IP addresses for the
         *Child Zone* using [Method4] and [Method5] ("NS IP").

      5. Create the following empty sets:

         1. Name server IP address and associated DNSKEY algorithm
            ("Algo not signed DNSKEY").
         2. Name server IP address and associated DNSKEY algorithm
            ("Algo not signed SOA").
         3. Name server IP address and associated DNSKEY algorithm
            ("Algo not signed NS").

      6. For each name server IP in the *NS IP* set do:

         1. Create an empty set of DNSKEY algorithms ("DNSKEY Algorithm").
         2. Send *DNSKEY Query* over UDP and do:
            1. Go to next name server IP if any of the following criteria is met:
               1. No DNS response is returned.
               2. The RCODE value of the DNS response is not "NoError"
                  ([IANA RCODE List]).
               3. The AA flag of the response is unset.
               4. The DNS response contains no DNSKEY record in the answer section.
               5. The DNS response contains no RRSIG for the DNSKEY RRset.
            2. Extract all DNSKEY records from the answer section.
            3. Extract the algorithm numbers from each DNSKEY record and add them to
               the *DNSKEY Algorithm* set.
            4. Extract all RRSIG records for the DNSKEY RRset from the response.
            5. For each algorithm in *DNSKEY Algorithm* do:
               * If there is no RRSIG for the DNSKEY RRset created by the algorithm
                 then add name server IP and DNSKEY algorithm to the
                 *Algo not signed DNSKEY* set.

         3. Send *SOA Query* over UDP and do:
            1. Go to next name server IP if any of the following criteria is met:
               1. No DNS response is returned.
               2. The RCODE value of the DNS response is not "NoError"
                  ([IANA RCODE List]).
               3. The AA flag of the response is unset.
               4. The DNS response contains no SOA record in the answer section.
               5. The DNS response contains no RRSIG for the SOA RRset.
            2. Extract the SOA record from the answer section (ignore additional SOA
               records, if any).
            3. Extract all RRSIG records for the SOA RRset from the response.
            4. For each algorithm in *DNSKEY Algorithm* do:
               * If there is no RRSIG for the SOA RRset created by the algorithm then
                 add name server IP and DNSKEY algorithm to the
                     *Algo not signed SOA* set.

         4. Send *NS Query* over UDP.
            1. Go to next name server IP if any of the following criteria is met:
               1. No DNS response is returned.
               2. The RCODE value of the DNS response is not "NoError"
                  ([IANA RCODE List]).
               3. The AA flag of the response is unset.
               4. The DNS response contains no NS record in the answer section.
               5. The DNS response contains no RRSIG for the NS RRset.
            2. Extract all NS records from the answer section.
            3. Extract all RRSIG records for the NS RRset from the response.
            4. For each algorithm in *DNSKEY Algorithm* do:
               * If there is no RRSIG for the NS RRset created by the algorithm then
                 add name server IP and DNSKEY algorithm to the
                 *Algo not signed NS* set.

      7. If the *Algo not signed DNSKEY* set is non-empty, then for each DNSKEY
         algorithm in the set output *[DS13_ALGO_NOT_SIGNED_DNSKEY]* with the name
         server IP addresses from the set and the DNSKEY algorithm.

      8. If the *Algo not signed SOA* set is non-empty, then for each DNSKEY
         algorithm in the set output *[DS13_ALGO_NOT_SIGNED_SOA]* with the name
         server IP addresses from the set and the SOA algorithm.

      9. If the *Algo not signed NS* set is non-empty, then for each DNSKEY
         algorithm in the set output *[DS13_ALGO_NOT_SIGNED_NS]* with the name
         server IP addresses from the set and the NS algorithm.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      See the [DNSSEC README] document about DNSSEC algorithms.

      Test case is only performed if DNSKEY records are found.
  dnssec-14:
    Summary: Check for valid RSA DNSKEY key size
    Description: |
      The DNSKEYs based on RSA have different minimum and maximum key sizes,
      which must be followed. This test case will validate the keys size of
      such keys. RSA based algorithms that are deprecated or else not suitable
      for DNSKEY ([RFC 8624] and [IANA registry]) are just ignored. See test
      case [DNSSEC05] for test of algorithm.

      The table 1 below specify the maximum and minimum key size,
      respectively. Algorithm number can be found in [IANA registry].

      Table 1: Minimum and maximum RSA key sizes in bits

      Algorithm | Min size  | Max size | Reference
      :---------|:----------|:---------|:----------------
      5         | 512       | 4096     | [RFC 3110]
      7         | 512       | 4096     | [RFC 5155]
      8         | 512       | 4096     | [RFC 5702]
      10        | 1024      | 4096     | [RFC 5702]

      It is also recommended that an RSA based algorithm has a key length
      of at least 2048 bit as stated in [NIST SP 800-57 Part 1 Rev. 4],
      table 2 on page 53 in section 5.6.1 and table 4 on page 55 in
      section 5.6.2.

      This test case verifies that RSA DNSKEYs follows the stated key lengths
      from the RFCs and also the NIST recommended shortest key length.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will set DEBUG level on messages for non-responsive name servers.

      ## Inputs

      * "Child Zone" - The domain name to be tested.
      * "Key Size Table" - The table above.

      ## Ordered description of steps to be taken to execute the test case

      1. Create a DNSKEY query with DO flag set for the apex of the
         *Child Zone*.

      2. Retrieve all name server IP addresses for the
         *Child Zone* using [Method4] and [Method5] ("NS IP").

      3. Create an empty set "DNSKEY RRs".

      4. For each name server IP address in *NS IP* do:

         1. Send the DNSKEY query over UDP.
         2. If no DNS response is returned, then output *[NO_RESPONSE]*.
         3. Else, if the DNS response does not contain an DNSKEY RRset,
            then output *[NO_RESPONSE_DNSKEY]*.
         4. Else, retrieve the DNSKEY RRs and add them to *DNSKEY RRs*.

      5. For each DNSKEY from the *DNSKEY RRs* do:
         1. If the algorithm of the DNSKEY is not listed in *Key Size
            Table*, go to next DNSKEY.
         2. Else, if the algorithm is listed in *Key Size Table* and the
            key size is smaller than specified, then output
            *[DNSKEY_TOO_SMALL_FOR_ALGO]*.
         3. Else, if the algorithm is listed in *Key Size Table* and the
            key size is smaller than 2048 bits, then output
            *[DNSKEY_SMALLER_THAN_REC]*.
         3. Else, if the algorithm is listed in *Key Size Table* and the
            key size is larger than specified, then output
            *[DNSKEY_TOO_LARGE_FOR_ALGO]*.

      6. If *DNSKEY RRs* is non-empty and no messages, except for any
         *[NO_RESPONSE]*, has been outputted, then output
         *[KEY_SIZE_OK]*.
      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *ERROR* or *CRITICAL*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *WARNING*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases the outcome of this Test Case is "pass".

      Message                       | Default severity level
      :-----------------------------|:-----------------------------------
      NO_RESPONSE                   | DEBUG
      NO_RESPONSE_DNSKEY            | WARNING
      DNSKEY_SMALLER_THAN_REC       | WARNING
      DNSKEY_TOO_SMALL_FOR_ALGO     | ERROR
      DNSKEY_TOO_LARGE_FOR_ALGO     | ERROR
      KEY_SIZE_OK                   | INFO

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      on the ignored result.

      See the [DNSSEC README] document about DNSSEC algorithms.

      The test case is only performed if some DNSKEY record is found in the
      *Child Zone*.
  dnssec-15:
    Summary: Check existence of CDS and CDNSKEY
    Description: |
      CDS and CDNSKEY record types are defined in [RFC 7344] and [RFC 8078].
      Both record types are optional in a zone. The objective of this test
      case is to verify that they are correctly set-up, if included in the
      zone.

      If a CDS record is included in the zone, the corresponding CDNSKEY
      record should also be included ([RFC 7344][RFC 7344#4], section 4).

      The CDS and CDNSKEY RRsets should be consistent between all name
      servers for the zone in question.

      If there are both CDS RRs and CDNSKEY RRs in the zone they must match in
      content ([RFC 7344][RFC 7344#4], section 4). It means that both
      must be derived from the same DNSKEY or both being "delete" CDS and
      CDNSKEY.

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will just ignore non-responsive name servers or name servers not
      giving a correct DNS response for an authoritative name server.

      ## Inputs

      * "Child Zone" - The domain name to be tested.

      ## Summary

      Message Tag outputted     | [Default level] | Description of when message tag is outputted
      :-------------------------|:----------------|:-----------------------------------------
      DS15_HAS_CDNSKEY_NO_CDS   | NOTICE          | CDNSKEY RRset is found, but no CDS RRset.
      DS15_HAS_CDS_AND_CDNSKEY  | INFO            | CDNSKEY and CDS RRsets are found.
      DS15_HAS_CDS_NO_CDNSKEY   | NOTICE          | CDS RRset is found, but no CDNSKEY RRset.
      DS15_INCONSISTENT_CDNSKEY | ERROR           | All servers do not have the same CDNSKEY RRset.
      DS15_INCONSISTENT_CDS     | ERROR           | All servers do not have the same CDS RRset.
      DS15_MISMATCH_CDS_CDNSKEY | ERROR           | Both CDS and CDNSKEY RRsets are found but they do not match.
      DS15_NO_CDS_CDNSKEY       | INFO            | No CDS or CDNSKEY RRsets are found on any name server.

      ## Ordered description of steps to be taken to execute the test case

      1.  Create the following empty sets:
          1. Name server IP address and associated CDS RRset ("CDS RRsets"). A
             name server IP can hold an empty RRset.
          2. Name server IP address and associated CDNSKEY RRset ("CDNSKEY RRsets").
             A name server IP can hold an empty RRset.
          3. Name server IP address set ("Mismatch CDS/CDNSKEY").
          4. Name server IP address set ("Has CDS No CDNSKEY").
          5. Name server IP address set ("Has CDNSKEY No CDS").
          6. Name server IP address set ("Has CDS And CDNSKEY").

      2.  Retrieve all name server IP addresses for the *Child Zone* using
          [Method4] and [Method5] ("NS IP").

      3.  Create a CDS query with EDNS enabled with the DO bit set for the
          apex of the *Child Zone*.

      4.  Create a CDNSKEY query with EDNS enabled with the DO bit set for
          the apex of the *Child Zone*.

      5.  For each name server IP in the *NS IP* set do:

          1. Send the CDS query over UDP to the name server IP address.
             1. If no DNS response is returned, then go to next name server IP.
             2. Else, if AA bit is not set in the DNS response, then go to next
                name server IP.
             3. Else, if the RCODE in the DNS response is not *NOERROR*, then go to
                next name server IP.
             4. Else, if the DNS response contains no CDS record in the
                answer section, then add the name server IP and an empty RRset to
                the *CDS RRsets* set.
             5. Else, add the name server IP and the CDS RRset from the answer
                section to the *CDS RRsets* set.
          2. Send the CDNSKEY query over UDP to the name server IP address.
             1. If no DNS response is returned, then go to next name server IP.
             2. Else, if AA bit is not set in the DNS response, then go to next
                name server IP.
             3. Else, if the RCODE in the DNS response is not *NOERROR*, then go to
                next name server IP.
             4. Else, if the DNS response contains no CDNSKEY record in the
                answer section, then add the name server IP and an empty RRset to
                the *CDNSKEY RRsets* set.
             5. Else, add the name server IP and the CDNSKEY RRset from the answer
                section to the *CDNSKEY RRsets* set.
          3. Go to next name server IP.

      6.  If the *CDS RRsets* set and the *CDNSKEY RRsets* set are empty
          then output *[DS15_NO_CDS_CDNSKEY]* and terminate this
          test case.

      7.  For each name server IP in the *CDS RRsets* set do:

          1. If the name server IP is not listed in *CDNSKEY RRsets*, go to next name
             server IP.
          2. If the name server IP address has a non-empty RRset in the
             *CDS RRsets* set, but an empty RRset in the *CDNSKEY RRsets*
             set, then add the name server IP address to *Has CDS No CDNSKEY*.
          3. If the name server IP address has a non-empty RRset in the
             *CDNSKEY RRsets* set, but an empty RRset in the *CDS RRsets*
             set, then add the name server IP address to *Has CDNSKEY No CDS*.
          4. If the name server IP address has a non-empty RRset in both
             sets, *CDNSKEY RRsets* and *CDS RRsets*, then add the name
             server IP address to *Has CDS And CDNSKEY*.
          5. Go to next name server IP.

      8.  For each name server IP in the *CDS RRsets* set do:

          1. If the name server IP is not listed in *CDNSKEY RRsets*, go to next name
             server IP.
          2. Extract the CDS RRset (possibly empty) for the IP in the *CDS RRsets* set.
          3. Extract the CDNSKEY RRset (possibly empty) for the same IP from
             the *CDNSKEY RRsets* set.
          4. If both RRsets are non-empty then do:
             1. For each CDS RR verify that there is a matching CDNSKEY (derived
                from the same DNSKEY or both being "delete").
             2. For each CDNSKEY RR verify that there is a matching CDS (derived
                from the same DNSKEY or both being "delete").
             3. If one or both of the verifications fail then add the name server
                IP to the *Mismatch CDS/CDNSKEY* set.
          4. Go to next name sever IP.
      9.  If the *Has CDS No CDNSKEY* set is non-empty then output
          *[DS15_HAS_CDS_NO_CDNSKEY]* with the name server IP addresses from
          the set.

      10. If the *Has CDNSKEY No CDS* set is non-empty then output
          *[DS15_HAS_CDNSKEY_NO_CDS]* with the name server IP addresses from
          the set.

      11. If the *Has CDS And CDNSKEY* set is non-empty then output
          *[DS15_HAS_CDS_AND_CDNSKEY]* with the name server IP addresses from
          the set.

      12. If not all CDS RRsets in the *CDS RRsets* set are identical, where
          a non-empty RRset is considered to be different from an empty
          RRset, then output *[DS15_INCONSISTENT_CDS]*.

      13. If not all CDNSKEY RRsets in the *CDNSKEY RRsets* set are identical,
          where a non-empty RRset is considered to be different from an
          empty RRset, then output *[DS15_INCONSISTENT_CDNSKEY]*.

      14. If the *Mismatch CDS/CDNSKEY* set is non-empty, then output
          *[DS15_MISMATCH_CDS_CDNSKEY]* and list the name server IPs from
          the set.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      the ignored protocol.
  dnssec-16:
    Summary: Validate CDS
    Description: |
      CDS and CDNSKEY record types are defined in [RFC 7344] and [RFC 8078].
      Both record types are optional in a zone. The objective of this test
      case is to verify that the CDS RRset is valid. This test case is
      only relevant if the zone has at least one CDS record. For tests of the
      CDNSKEY, see test case [DNSSEC17].

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will just ignore non-responsive name servers or name servers not
      giving a correct DNS response for an authoritative name server.

      It is assumed that *Child Zone* has been tested or will be tested by
      [DNSSEC15] and [DNSSEC17] and that the servers give the same responses.
      Running this test case without running [DNSSEC15] and [DNSSEC17] can
      give an incomplete report of the CDS and CDNSKEY status of
      *Child Zone*.

      ## Inputs

      * "Child Zone" - The domain name to be tested.

      ## Summary

      * If no CDS record is found, the test case will terminate early
        with no message tag outputted.
      * If a CDS record is of "delete" type, then it can by definition not
        match or point at any DNSKEY record.

      Message Tag outputted                | [Default level] | Description of when message tag is outputted
      :------------------------------------|:--------|:-----------------------------------------
      DS16_CDS_INVALID_RRSIG               | ERROR   | CDS RRset is signed with an invalid RRSIG.
      DS16_CDS_MATCHES_NON_SEP_DNSKEY      | NOTICE  | CDS record matches a DNSKEY with SEP bit (bit 15) unset.
      DS16_CDS_MATCHES_NON_ZONE_DNSKEY     | ERROR   | CDS record matches a DNSKEY with zone bit (bit 7) unset.
      DS16_CDS_MATCHES_NO_DNSKEY           | WARNING | CDS record does not match any DNSKEY in DNSKEY RRset.
      DS16_CDS_NOT_SIGNED_BY_CDS           | NOTICE  | CDS RRset is not signed by the key that the CDS record points to.
      DS16_CDS_SIGNED_BY_UNKNOWN_DNSKEY    | ERROR   | CDS RRset is signed by a key not in DNSKEY RRset.
      DS16_CDS_UNSIGNED                    | ERROR   | CDS RRset is unsigned.
      DS16_CDS_WITHOUT_DNSKEY              | ERROR   | CDS RRset exists, but there is no DNSKEY RRset.
      DS16_DELETE_CDS                      | INFO    | CDS RRset has a "delete" CDS record as a single record.
      DS16_DNSKEY_NOT_SIGNED_BY_CDS        | WARNING | DNSKEY RRset is not signed by the key or keys that the CDS records point to.
      DS16_MIXED_DELETE_CDS                | ERROR   | "Delete" CDS record is mixed with normal CDS record.

      ## Ordered description of steps to be taken to execute the test case

      1.  Create the following empty sets:
          1.  Name server IP address and associated CDS RRset and its RRSIG
              records ("CDS RRsets"). The set of RRSIG records may be empty.
          2.  Name server IP address and associated DNSKEY RRset and its
              RRSIG records ("DNSKEY RRsets"). The set of RRSIG records may be empty.
          3.  Name server IP address ("No DNSKEY RRset").
          4.  Name server IP address ("Mixed Delete CDS").
          5.  Name server IP address ("Delete CDS").
          6.  Name server IP address and associated CDS key tag
              ("No Match CDS With DNSKEY").
          7.  Name server IP address and associated CDS key tag
              ("CDS points to non-zone DNSKEY").
          8.  Name server IP address and associated CDS key tag
              ("CDS points to non-SEP DNSKEY").
          9.  Name server IP address and associated CDS key tag
              ("DNSKEY Not Signed By CDS").
          10. Name server IP address and associated CDS key tag
              ("CDS Not Signed By CDS").
          11. Name server IP address ("CDS Not Signed").
          12. Name server IP address and key tag
              ("CDS Signed By Unknown DNSKEY").
          13. Name server IP address and key tag ("CDS Invalid RRSIG").

      2.  Create a CDS query with EDNS enabled and the DO bit set for the
          apex of the *Child Zone*.

      3.  Create a DNSKEY query with EDNS enabled and the DO bit set for
          the apex of the *Child Zone*.

      4.  Retrieve all name server IP addresses for the *Child Zone* using
          [Method4] and [Method5] ("NS IP").

      5.  Repeat the following steps for each name server IP address in
          *NS IP*:

          1. Send the CDS query over UDP to the name server IP address.
             1. If no DNS response is returned, then go to next name server
                IP.
             2. Else, if AA bit is not set in the DNS response, then go to
                next name server IP.
             3. Else, if the RCODE in the DNS response is not *NOERROR*, then
                go to next name server IP.
             4. Else, if the answer section has no CDS records, go to next
                name server IP.
             5. Add the name server IP and the CDS RRset from the answer
                section to the *CDS RRsets* set. Also include any associated
                RRSIG records in the answer section.
          2. Send the DNSKEY query over UDP to the name server IP address.
             1. If no DNS response is returned, then go to next name server
                IP.
             2. Else, if AA bit is not set in the DNS response, then go to
                next name server IP.
             3. Else, if the RCODE in the DNS response is not *NOERROR*, then
                go to next name server IP.
             4. Else, if the DNS response contains at least one DNSKEY
                record in the answer section, then add the name server IP and
                the DNSKEY RRset from the answer section to the
                *DNSKEY RRsets* set. Also include any associated RRSIG
                records in the answer section.
          3. Go to next name server IP.

      6.  If the *CDS RRsets* set is empty then terminate this test case.

      7.  For each name server IP in the *CDS RRsets* set do:

          1. If the CDS RRset is empty go to next name server IP address.
          2. Get the CDS RRset and the associated RRSIG records, if any, from the
             *CDS RRsets* set for the name server IP.
          3. If any CDS record is a "delete" CDS, then do:
             1. If there is more than a single CDS record then add the name
                server IP to the *Mixed Delete CDS* set.
             2. Else, add the name server IP address to the *Delete CDS*
                set.
          4. Get the DNSKEY RRset and the associated RRSIG records, if any, from the
             *DNSKEY RRsets* for the same name server IP.
          5. If there are no DNSKEY records, then do:
             1. Add name server IP address to the *No DNSKEY RRset* set.
             2. Go to next name server IP.
          6. Repeat the following steps for each CDS record unless it is a "delete"
             CDS record:
             1. Compare the key tag from the CDS record with the
                [calculated key tags][Key Tag Calculation] for the DNSKEY records.
             2. If the CDS record does not match any DNSKEY record then add
                the name server IP address and CDS record key tag to the
                *No Match CDS With DNSKEY* set.
             3. Else, if bit 7 of the flags field of the DNSKEY that the DS record
                points to is unset (value 0) then add the name server IP address and
                CDS record key tag to the *CDS points to non-zone DNSKEY* set.
             4. Else, do:
                1. If the DNSKEY RRset has not been signed by the DNSKEY record that
                   the CDS record points at then add the name server IP address and
                   key tag of CDS record to the *DNSKEY Not Signed By CDS* set.
                2. If the CDS RRset has not been signed by the DNSKEY record that
                   the CDS record points at then add the name server IP address and
                   key tag of CDS record to the *CDS Not Signed By CDS* set.
                3. If bit 15 of the flags field of the DNSKEY that the CDS record
                   points at is unset (value 0) then add the name server IP address
                   and the key tag of the CDS record to the
                   *CDS points to non-SEP DNSKEY* set.
          7. If CDS RRset is not signed, then add the name server IP address to the
             *CDS Not Signed* set.
          8. Else, for each RRSIG for the CDS RRset do:
             1. If the key tag of the RRSIG does not match any DNSKEY record in the
                DNSKEY RRset then add the name server IP address and key tag to the
                *CDS Signed By Unknown DNSKEY* set.
             2. Else, if the RRSIG cannot be validated by the DNSKEY it
                refers to by key tag, then add the name server IP and RRSIG
                key tag to the *CDS Invalid RRSIG* set.
          9. Go to next name server IP address.

      8.  If the *No DNSKEY RRset* set is non-empty, then output
          *[DS16_CDS_WITHOUT_DNSKEY]* with all name server IP addresses
          in the set.

      9.  If the *Mixed Delete CDS* set is
          non-empty, then output *[DS16_MIXED_DELETE_CDS]* with all
          name server IP addresses in the set.

      10. If the *Delete CDS* set is non-empty, then output
          *[DS16_DELETE_CDS]* with all name server IP addresses.

      11. If the *No Match CDS With DNSKEY* set is non-empty then do:
          * For each CDS key tag in the set do:
              * Output *[DS16_CDS_MATCHES_NO_DNSKEY]* with the CDS key tag
                and the name server IP addresses in the set for that key
                tag.

      12. If the *CDS points to non-zone DNSKEY* set is non-empty then do:
          * For each CDS key tag in the set do:
              * Output *[DS16_CDS_MATCHES_NON_ZONE_DNSKEY]* with the CDS key tag
                and the name server IP addresses in the set for that key
                tag.

      13. If the *CDS points to non-SEP DNSKEY* set is non-empty then do:
          * For each CDS key tag in the set do:
              * Output *[DS16_CDS_MATCHES_NON_SEP_DNSKEY]* with the CDS key tag
                and the name server IP addresses in the set for that key
                tag.

      14. If the *DNSKEY Not Signed By CDS* set is non-empty then do:
          * For each CDS key tag in the set do:
              * Output *[DS16_DNSKEY_NOT_SIGNED_BY_CDS]* with the CDS key
                tag and the name server IP addresses in the set for that
                key tag.

      15. If the *CDS Not Signed By CDS* set is non-empty then do:
          * For each CDS key tag in the set do:
              * Output *[DS16_CDS_NOT_SIGNED_BY_CDS]* with the CDS key
                tag and the name server IP addresses in the set for that
                key tag.

      16. If the *CDS Invalid RRSIG* set is non-empty then do:
          * For each RRSIG key tag in the set do:
              * Output *[DS16_CDS_INVALID_RRSIG]* with the RRSIG key tag and
                the name server IP addresses in the set for that key tag.

      17. If the *CDS Not Signed* set is non-empty then output
          *[DS16_CDS_UNSIGNED]* with all name server IP addresses in the set.

      18. If the *CDS Signed By Unknown DNSKEY* set is non-empty then output
          *[DS16_CDS_SIGNED_BY_UNKNOWN_DNSKEY]* with the name server IP
          addresses in the set.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      the ignored protocol.
  dnssec-17:
    Summary: Validate CDNSKEY
    Description: |
      CDS and CDNSKEY record types are defined in [RFC 7344] and [RFC 8078].
      Both record types are optional in a zone. The objective of this test
      case is to verify that the CDNSKEY RRset is valid. This test case is
      only relevant if the zone has at least one CDNSKEY record. For tests of the
      CDS, see test case [DNSSEC16].

      ## Scope

      It is assumed that *Child Zone* is also tested by [Connectivity01]. This test
      case will just ignore non-responsive name servers or name servers not
      giving a correct DNS response for an authoritative name server.

      It is assumed that *Child Zone* has been tested or will be tested by
      [DNSSEC15] and [DNSSEC16] and that the servers give the same responses.
      Running this test case without running [DNSSEC15] and [DNSSEC16] can
      give an incomplete report of the CDS and CDNSKEY status of
      *Child Zone*.

      ## Inputs

      * "Child Zone" - The domain name to be tested.

      ## Summary

      * If no CDNSKEY record is found, the test case will terminate early
        with no message tag outputted.
      * If a CDNSKEY record is of "delete" type, then it can by
        definition not match or point at any DNSKEY record.

      Message Tag outputted                | [Default level] | Description of when message tag is outputted
      :------------------------------------|:--------|:-----------------------------------------
      DS17_CDNSKEY_INVALID_RRSIG           | ERROR   | CDNSKEY RRset signed with an invalid RRSIG.
      DS17_CDNSKEY_IS_NON_SEP              | NOTICE  | CDNSKEY record has the SEP bit (bit 15) unset.
      DS17_CDNSKEY_IS_NON_ZONE             | ERROR   | CDNSKEY record has the zone bit (bit 7) unset.
      DS17_CDNSKEY_MATCHES_NO_DNSKEY       | WARNING | CDNSKEY record does not match any DNSKEY in DNSKEY RRset.
      DS17_CDNSKEY_NOT_SIGNED_BY_CDNSKEY   | NOTICE  | CDNSKEY RRset is not signed by the key that the CDNSKEY record points to.
      DS17_CDNSKEY_SIGNED_BY_UNKNOWN_DNSKEY| ERROR   | CDNSKEY RRset is signed by a key not in DNSKEY RRset.
      DS17_CDNSKEY_UNSIGNED                | ERROR   | CDNSKEY RRset is unsigned.
      DS17_CDNSKEY_WITHOUT_DNSKEY          | ERROR   | CDNSKEY RRset exists, but there is no DNSKEY RRset.
      DS17_DELETE_CDNSKEY                  | INFO    | CDNSKEY RRset has a "delete" CDNSKEY record as a single record.
      DS17_DNSKEY_NOT_SIGNED_BY_CDNSKEY    | WARNING | DNSKEY RRset is not signed by the key or keys that the CDNSKEY records point to.
      DS17_MIXED_DELETE_CDNSKEY            | ERROR   | "Delete" CDNSKEY record is mixed with normal CDNSKEY record.

      ## Ordered description of steps to be taken to execute the test case

      1.  Create the following empty sets:
          1.  Name server IP address and associated CDNSKEY RRset and its
              RRSIG redords ("CDNSKEY RRsets"). The set of RRSIG records may be empty
          2.  Name server IP address and associated DNSKEY RRset and its
              RRSIG records ("DNSKEY RRsets"). The set of RRSIG records may be empty.
          3.  Name server IP address ("No DNSKEY RRset").
          4.  Name server IP address ("Mixed Delete CDNSKEY").
          5.  Name server IP address ("Delete CDNSKEY").
          6.  Name server IP address and associated CDNSKEY key tag
              ("No Match CDNSKEY With DNSKEY").
          7.  Name server IP address and associated CDNSKEY key tag
              ("CDNSKEY is non-zone key").
          8.  Name server IP address and associated CDNSKEY key tag
              ("CDNSKEY is non-SEP key").
          9.  Name server IP address and key tag
              ("DNSKEY Not Signed By CDNSKEY").
          10. Name server IP address and key tag
              ("CDNSKEY Not Signed By CDNSKEY").
          11. Name server IP address ("CDNSKEY Not Signed").
          12. Name server IP address and key tag
              ("CDNSKEY Signed By Unknown DNSKEY").
          13. Name server IP address and key tag ("CDNSKEY Invalid RRSIG").

      2.  Create a CDNSKEY query with EDNS enabled and the DO bit set for
          the apex of the *Child Zone*.

      3.  Create a DNSKEY query with EDNS enabled and the DO bit set for
          the apex of the *Child Zone*.

      4.  Retrieve all name server IP addresses for the *Child Zone* using
          [Method4] and [Method5] ("NS IP").

      5.  Repeat the following steps for each name server IP address in
          *NS IP*:

          1. Send the CDNSKEY query over UDP to the name server IP address.
             1. If no DNS response is returned, then go to next name server
                IP.
             2. Else, if AA bit is not set in the DNS response, then go to
                next name server IP.
             3. Else, if the RCODE in the DNS response is not *NOERROR*, then
                go to next name server IP.
             4. Else, if the answer section has no CDNSKEY records, go to
                next name server IP.
             5. Add the name server IP and the CDNSKEY RRset from the answer
                section to the *CDNSKEY RRsets* set. Also include any
                associated RRSIG records in the answer section.
          2. Send the DNSKEY query over UDP to the name server IP address.
             1. If no DNS response is returned, then go to next name server
                IP.
             2. Else, if AA bit is not set in the DNS response, then go to
                next name server IP.
             3. Else, if the RCODE in the DNS response is not *NOERROR*, then
                go to next name server IP.
             4. Else, if the DNS response contains at least one DNSKEY
                record in the answer section, then add the name server IP and
                the DNSKEY RRset from the answer section to the
                *DNSKEY RRsets* set. Also include any associated RRSIG records
                in the answer section.
          3. Go to next name server IP.

      6.  If the *CDNSKEY RRsets* set is empty then terminate this test case.

      7.  For each name server IP in the *CDNSKEY RRsets* set do:

          1. If the CDNSKEY RRset is empty go to next name server IP address.
          2. Get the CDNSKEY RRset and the associated RRSIG records, if any, from the
             *CDNSKEY RRsets* set for the name server IP.
          3. If any CDNSKEY record is a "delete" CDNSKEY, then do:
             1. If there is more than a single CDNSKEY record then add the
                name server IP to the *Mixed Delete CDNSKEY* set.
             2. Else, add the name server IP address to the *Delete CDNSKEY*
                set.
          4. Get the DNSKEY RRset and the associated RRSIG records, if any, from the
             *DNSKEY RRsets* for the same name server IP.
          5. If there are no DNSKEY records, then do:
             1. Add name server IP address to the *No DNSKEY RRset* set
                (duplicates not possible).
             2. Go to next name server IP.
          6. Repeat the following steps for each CDNSKEY record unless it is a "delete"
             CDNSKEY record:
             1. If bit 7 of the flags field of the CDNSKEY record is unset (value 0)
                then add the name server IP address and the
                [key tag calculated][Key Tag Calculation] from the CDNSKEY record to
                the *CDNSKEY is non-zone key* set.
             2. Else, do:
                1. If bit 15 of the flags field of the CDNSKEY is unset (value 0) then
                   add the name server IP address and the
                   [key tag calculated][Key Tag Calculation] from the CDNSKEY to the
                   *CDNSKEY is non-SEP key* set.
                2. Compare the CDNSKEY record with the DNSKEY records.
                3. If the CDNSKEY record does not match any DNSKEY record then
                   add the name server IP address and the
                   [key tag calculated][Key Tag Calculation] from the CDNSKEY record
                   to the *No Match CDNSKEY With DNSKEY* set.
                4. Else, do:
                   1. If the DNSKEY RRset is not signed by the DNSKEY record that
                      corresponds to the CDNSKEY record then add the name server IP
                      address and [key tag calculated][Key Tag Calculation] from
                      CDNSKEY record to the *DNSKEY Not Signed By CDNSKEY* set.
                   2. If the CDNSKEY RRset is not signed by the DNSKEY record that
                      corresponds to the CDNSKEY record then add the name server IP
                      address and [key tag calculated][Key Tag Calculation] from
                      CDNSKEY record to the *CDNSKEY Not Signed By CDNSKEY* set.

          7. If the CDNSKEY RRset is not signed, then add the name server IP address to
             the *CDNSKEY Not Signed* set.
          8. Else, for each RRSIG for the CDNSKEY RRset do:
             1. If the key tag of the RRSIG does not match any DNSKEY record in the
                DNSKEY RRset then add the name server IP address and key tag to the
                *CDNSKEY Signed By Unknown DNSKEY* set.
             2. Else, if the RRSIG cannot be validated by the DNSKEY it
                refers to by key tag, then add the name server IP and RRSIG
                key tag to the *CDNSKEY Invalid RRSIG* set.
          9. Go to next name server IP address.

      8.  If the *No DNSKEY RRset* set is non-empty, then output
          *[DS17_CDNSKEY_WITHOUT_DNSKEY]* with all name server IP addresses
          in the set.

      9. If the the *Mixed Delete CDNSKEY* set is
          non-empty, then output *[DS17_MIXED_DELETE_CDNSKEY]* with all
          name server IP addresses in the set.

      10. If the *Delete CDNSKEY* set is non-empty then output
          *[DS17_DELETE_CDNSKEY]* with all name server IP addresses.

      11. If the *No Match CDNSKEY With DNSKEY* set is non-empty then do:
          * For each CDNSKEY key tag in the set do:
              * Output *[DS17_CDNSKEY_MATCHES_NO_DNSKEY]* with the CDNSKEY
                key tag and the name server IP addresses in the set for that
                key tag.

      12. If the *CDNSKEY is non-zone key* set is non-empty then do:
          * For each CDNSKEY key tag in the set do:
              * Output *[DS17_CDNSKEY_IS_NON_ZONE]* with the CDNSKEY key tag
                and the name server IP addresses in the set for that key tag.

      13. If the *CDNSKEY is non-SEP key* set is non-empty then do:
          * For each CDNSKEY key tag in the set do:
              * Output *[DS17_CDNSKEY_IS_NON_SEP]* with the CDNSKEY key tag
                and the name server IP addresses in the set for that key tag.

      14. If the *DNSKEY Not Signed By CDNSKEY* set is non-empty then do:
          * For each CDNSKEY key tag in the set do:
              * Output *[DS17_DNSKEY_NOT_SIGNED_BY_CDNSKEY]* with the CDNSKEY
                key tag and the name server IP addresses in the set for that
                key tag.

      15. If the *CDNSKEY Not Signed By CDNSKEY* set is non-empty then do:
          * For each CDNSKEY key tag in the set do:
              * Output *[DS17_CDNSKEY_NOT_SIGNED_BY_CDNSKEY]* with the CDNSKEY key tag
                and the name server IP addresses in the set for that key tag.

      16. If the *CDNSKEY Invalid RRSIG* set is non-empty then do:
          * For each RRSIG key tag in the set do:
              * Output *[DS17_CDNSKEY_INVALID_RRSIG]* with the RRSIG key tag
                and the name server IP addresses in the set for that key tag.

      17. If the *CDNSKEY Not Signed* set is
          non-empty then output *[DS17_CDNSKEY_UNSIGNED]* with all
          name server IP addresses in the set.

      18. If the *CDNSKEY Signed By Unknown DNSKEY* set is non-empty then
          output *[DS17_CDNSKEY_SIGNED_BY_UNKNOWN_DNSKEY]* with the name server
          IP addresses in the set.

      ## Outcome(s)

      The outcome of this Test Case is "fail" if there is at least one message
      with the severity level *[ERROR]* or *[CRITICAL]*.

      The outcome of this Test Case is "warning" if there is at least one message
      with the severity level *[WARNING]*, but no message with severity level
      *ERROR* or *CRITICAL*.

      In other cases, no message or only messages with severity level
      *[INFO]* or *[NOTICE]*, the outcome of this Test Case is "pass".

      ## Special procedural requirements

      If either IPv4 or IPv6 transport is disabled, ignore the evaluation of the
      result of any test using this transport protocol. Log a message reporting
      the ignored protocol.
  dnssecRSP01-ZSKRollover:
    Summary: ZSK rollover
    Description: |
      This test case verifies the RSP's ability to perform a ZSK rollover for a
      zone.
    Input-Parameters:
    Dependencies:
  dnssecRSP02-KSKRollover:
    Summary: KSK rollover
    Description: |
      This test case verifies the RSP's ability to perform a KSK rollover for a
      zone.
    Input-Parameters:
    Dependencies:
  dnssecRSP03-AlgorithmRollover:
    Summary: algorithm rollover
    Description: |
      This test case verifies the RSP's ability to perform an algorithm rollover
      for a zone.
    Input-Parameters:
    Dependencies:

  rdap-ipv4Validation:
    Summary: IPv4 address validation
    Description: |
      **The following steps should be used to test that an IPv4 address is
      valid:**

      1.  The IPv4 address is syntactically valid in dot-decimal notation.

      {

      \"code\": -10099-10100,

      \"value\": \"\<IPv4 address string\>\",

      \"message\": \"The IPv4 address is not syntactically valid in
      dot-decimal notation.\"

      }

      The IPv4 address MUST be part of a prefix categorized as \"ALLOCATED\"
      or \"LEGACY\" in the \"Status\" field in the **ipv4AddressSpace**.{

      \"code\": -10101,

      \"value\": \"\<IPv4 address string\>\",

      \"message\": \"The IPv4 address is not included in a prefix
      categorized as ALLOCATED or LEGACY in the IANA IPv4 Address Space
      Registry. Dataset: ipv4AddressSpace\"

      }

      The IPv4 address MUST NOT be part of the **specialIPv4Addresses**.{

      \"code\": -10102,

      \"value\": \"\<IPv4 address string\>\",

      \"message\": \"The IPv4 address is included in the IANA IPv4
      Special-Purpose Address Registry. Dataset: specialIPv4Addresses\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC791
    Input-Parameters:
    Dependencies:
  rdap-ipv6Validation:
    Summary: IPv6 address validation
    Description: |
      **The following steps should be used to test that an IPv6 address is
      valid:**

      The IPv6 address is in canonical textual representation format.{

      \"code\": -10199-10200,

      \"value\": \"\<IPv6 address string\>\",

      \"message\": \"The IPv6 address is not syntactically valid.\"

      }

      The IPv6 address MUST be part of an allocation of type \"Global
      Unicast\" in the **ipv6AddressSpace**.{

      \"code\": -10201,

      \"value\": \"\<IPv6 address string\>\",

      \"message\": \"The IPv6 address is not included in a prefix
      categorized as Global Unicast in the Internet Protocol Version 6
      Address Space. Dataset: ipv6AddressSpace\"

      }

      The IPv6 address MUST NOT be part of the **specialIPv6Addresses**.{

      \"code\": -10202,

      \"value\": \"\<IPv6 address string\>\",

      \"message\": \"The IPv6 address is included in the IANA IPv6
      Special-Purpose Address Registry. Dataset: specialIPv6Addresses\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC5952
    Input-Parameters:
    Dependencies:
  rdap-domainNameValidation:
    Summary: Domain Name validation
    Description: |
      **The following steps should be used to test that a domain name is
      valid:**

      The length of each label is between 1 and 63.{

      \"code\": -10299-10300,

      \"value\": \"\<domain name\>\",

      \"message\": \"A DNS label with length not between 1 and 63 was
      found.\"

      }

      A maximum total length of 253 characters not including the last
      \".\".{

      \"code\": -10301,

      \"value\": \"\<domain name\>\",

      \"message\": \"A domain name of more than 253 characters was found. \"

      }

      At least two labels shall exist in the domain name. See,
      RDAP_Technical_Implementation_Guide_2_1 section 1.10.{

      \"code\": -10302,

      \"value\": \"\<domain name\>\",

      \"message\": \"A domain name with less than two labels was found. See
      RDAP_Technical_Implementation_Guide_2_1 section 1.10\"

      }

      Each label of the domain name is a valid \"A-label\", \"U-label\", or
      \"NR-LDH label\".{

      \"code\": -10303,

      \"value\": \"\<domain name\>\",

      \"message\": \"A DNS label not being a valid \"A-label\", \"U-label\",
      or \"NR-LDH label\" was found.\"

      }

      Note: the latest version of the IANA IDNA Rules and Derived Property
      Values shall be used. See,
      <https://www.iana.org/assignments/idna-tables-11.0.0/idna-tables-11.0.0.xml>

      **The following normative references are required to understand this
      test group:**

      DNS_RFCsIDNA_RFCs
    Input-Parameters:
    Dependencies:
  rdap-webUriValidation:
    Summary: Web URI validation
    Description: |
      **The following steps should be used to test that a *Web URI* is
      valid:**

      The URI shall be syntactically valid according to RFC3986.{

      \"code\": -10399-10400,

      \"value\": \"\<URI\>\",

      \"message\": \"The URI is not syntactically valid according to
      RFC3986.\"

      }

      The scheme of the URI shall be \"http\" or \"https\".{

      \"code\": -10401,

      \"value\": \"\<URI\>\",

      \"message\": \"The scheme of the URI is not \'http\' nor \'https\'\".

      }

      The host of the URI shall pass the test Domain Name validation
      \[domainNameValidation\], IPv4 address validation \[ipv4Validation\]
      or IPv6 address validation \[ipv6Validation\].{

      \"code\": -10402,

      \"value\": \"\<URI\>\",

      \"message\": \"The host does not pass Domain Name validation
      \[domainNameValidation\], IPv4 address validation \[ipv4Validation\]
      nor IPv6 address validation \[ipv6Validation\]\".

      }

      **The following normative references are required to understand this
      test group:**

      RFC3986
    Input-Parameters:
    Dependencies:
  rdap-domainCaseFoldingValidation:
    Summary: Domain label case folding validation
    Description: "**The following steps should be used to test that an RDAP server
      is\nprocessing label case conversion correctly for domain name lookups:**\n\n1.
      \ \n\nA subsequent RDAP lookup may be performed in the case of a domain name\nlookup
      to validate correct support for case insensitive label\nmatching:For any \\\"NR-LDH
      label\\\" or \\\"A-label\\\" present, the RDAP\nresponse must match the response
      of a subsequent request converting\nany \\\"NR-LDH label\\\" or \\\"A-label\\\"
      alternating uppercase and\nlowercase characters (e.g., if the domain is \\\"test.example\\\"
      the RDAP\nresponse must match also for converted domain name\n\\\"tEsT.ExAmPlE\\\").For
      any \\\"U-Label\\\" present, in case that any of the\ncode points support case
      folding, the u-label should be case-folded\nfor the subsequent request. (e.g.,
      if the domain is \\\"CAF\xC9.EXAMPLE\\\"\nthe RDAP response must match also
      for converted domain name\n\\\"caf\xE9.ExAmPlE\\\").In case that the domain
      name in the query contains\nall u-labels and none of the labels can be case-folded
      (i.e., the\nscript or code points do not support case folding) a subsequent
      query\nis not required.In case that the domain name in the query contains all\nu-labels
      and the resulting domain name to query after case-folding is\nthe same as the
      original, a subsequent query is not required.{\n\n\\\"code\\\": -10399-10403,\n\n\\\"value\\\":
      \\\"\\<converted domain name\\>\\\",\n\n\\\"message\\\": \\\"RDAP responses
      do not match when handling domain label\ncase folding.\\\"\n\n}\n\n**The following
      normative references are required to understand this\ntest group:**\n\nDNS_RFCsIDNA_RFCs\n\n##
      Standard RDAP Common Data Structures Validations\n"
    Input-Parameters:
    Dependencies:
  rdap-stdRdapConformanceValidation:
    Summary: RDAP Conformance validation
    Description: |
      **The following steps should be used to test that an *RDAP
      Conformance* data structure is valid:**

      The *RDAP Conformance* data structure must be a syntactically valid
      [JSON array]{.underline}.{

      \"code\": -10499-10500,

      \"value\": \"\<rdapConformance structure\>\",

      \"message\": \"The RDAP Conformance structure is not syntactically
      valid.\"

      }

      Every value of the [JSON array]{.underline} shall be a [JSON
      string]{.underline} data type.{

      \"code\": -10501,

      \"value\": \"\<JSON value\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      Each of the [JSON string]{.underline} values in the [JSON
      array]{.underline}, with the exception of \"rdap_level_0\", shall be
      included as an Extension Identifier in **RDAPExtensions**.{

      \"code\": -10502,

      \"value\": \"\<JSON string\>\",

      \"message\": \"The JSON string is not included as an Extension
      Identifier in RDAPExtensions.\"

      }

      The [JSON string]{.underline} value \"rdap_level_0\" is not included
      in the *RDAP Conformance* data structure.{

      \"code\": -10503,

      \"value\": \"\<rdapConformance\>\",

      \"message\": \"The RDAP Conformance data structure does not include
      rdap_level_0.\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs**\
      **
    Input-Parameters:
    Dependencies:
  rdap-stdRdapLinksValidation:
    Summary: Links validation
    Description: |
      **The following steps should be used to test that a links data
      structure is valid:**

      The *links* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -10599-10600,

      \"value\": \"\<links structure\>\",

      \"message\": \"The links structure is not syntactically valid.\"

      }

      For every object (i.e. link) of the [JSON array]{.underline}, verify
      that the *link* structure complies with:

      The name of every name/value pair shall be *value*, *rel*, *href*,
      *hreflang*, *title*, *media* or *type*.{

      \"code\": -10601,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: value, rel,
      href, hreflang, title, media or type.\"

      }

      The JSON name/value pairs of *rel*, *href*, *hreflang*, *title*,
      *media* and *type* shall appear only once.{

      \"code\": -10602,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a link structure was
      found more than once.\"

      }

      If the JSON name *media* exists, the allowed values are: screen, tty,
      tv, projection, handheld, print, braille, embossed, speech, and all.{

      \"code\": -10603,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name media is not of: screen,
      tty, tv, projection, handheld, print, braille, embossed, speech, or
      all.\"

      }

      If the JSON name *rel* exists, the value shall be included as a
      \"Relation Name\" in **linkRelations**.{

      \"code\": -10604,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not included as a Relation Name in
      linkRelations.\"

      }

      If the JSON name *type* exists, the value shall be included as a
      \"Name\" in **mediaTypes**.{

      \"code\": -10605,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not included as a Name in
      mediaTypes.\"

      }

      If the JSON name *title* exists, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -10606,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      If the JSON name *hreflang* exists, the value shall be [a JSON
      string]{.underline} data type or a valid [JSON array]{.underline}
      where every value is a [JSON string]{.underline} data type.{

      \"code\": -10607,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name hreflang is not a JSON
      string data type or a valid JSON array where every value is a JSON
      string data type.\"

      }

      If the JSON name *hreflang* exists, every one of the *JSON string*
      data values shall conform to the Language-Tag syntax. {

      \"code\": -10608,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value of the JSON string data in the hreflang does
      not conform to Language-Tag syntax.\"

      }

      If the JSON name *value* exists, the value shall pass the test Web URI
      validation \[webUriValidation\] defined in this document.{

      \"code\": -10609,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Web URI
      validation \[webUriValidation\].\"

      }

      The JSON name *href* shall exist.{

      \"code\": -10610,

      \"value\": \"\<links structure\>\",

      \"message\": \"The href element does not exist.\"

      }

      For the JSON name *href*, the value shall pass the test Web URI
      validation \[webUriValidation\] defined in this document.{

      \"code\": -10611,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name href does not pass Web URI
      validation \[webUriValidation\].\"

      }

      **\
      **

      **The following normative references are required to understand this
      test group:**

      RFC5646RFC7159RFC8288RDAP_RFCsMedia_Queries

      **\
      **
    Input-Parameters:
    Dependencies:
  rdap-stdRdapNoticesRemarksValidation:
    Summary: Notices and Remarks Validation
    Description: |
      **The following steps should be used to test that a notices or remarks
      data structure is valid:**

      The *notices* or *remarks* data structure must be a syntactically
      valid [JSON array]{.underline}.{

      \"code\": -10699-10700,

      \"value\": \"\<notices or remarks structure\>\",

      \"message\": \"The notices or remarks structure is not syntactically
      valid.\"

      }

      For every object of the [JSON array]{.underline}, verify that the
      structure complies with:

      The name of every name/value pair shall be *title*, *type*,
      *description* or *links*. {

      \"code\": -10701,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: title, type,
      description or links.\"

      }

      The JSON name/values of *title*, *type*, *description* and *links*
      shall exist only once. {

      \"code\": -10702,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a link structure was
      found more than once.\"

      }

      If the JSON name *title* exists, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -10703,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      If the JSON name *links* exists, the value shall pass the test Links
      validation \[stdRdapLinksValidation\] defined in this document.{

      \"code\": -10704,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Links
      validation \[stdRdapLinksValidation\].\"

      }

      If the JSON name *type* exists, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -10705,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      If the JSON name *type* exists, the value shall be included in the
      **RDAPJSONValues** with Type=\"notice and remark type\".{

      \"code\": -10706,

      \"value\": \"\<JSON string\>\",

      \"message\": \"The JSON string is not included as a Value with
      Type=\"notice and remark type\" in the RDAPJSONValues dataset.

      }

      The JSON name *description* shall exist.{

      \"code\": -10707,

      \"value\": \"\<notices or remarks structure\>\",

      \"message\": \"The description element does not exist.\"

      }

      The *description* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -10708,

      \"value\": \"\<description structure\>\",

      \"message\": \"The description structure is not syntactically valid.\"

      }

      Every value of the [JSON array]{.underline} of the *description* data
      structure shall be a [JSON string]{.underline} data type.{

      \"code\": -10709,

      \"value\": \"\<JSON value\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapLanguageIdentifierValidation:
    Summary: Language Identifier Validation
    Description: |
      **The following steps should be used to test that a lang data
      structure is valid:**

      For the JSON name *lang*, the value shall conform to the Language-Tag
      syntax.{

      \"code\": -10799-10800,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value of the JSON string data in lang does not
      conform to Language-Tag syntax.\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC5646RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapEventsValidation:
    Summary: Events Validation
    Description: |
      **The following steps should be used to test that a events data
      structure is valid:**

      The *events* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -10899-10900,

      \"value\": \"\<events structure\>\",

      \"message\": \"The events structure is not syntactically valid.\"

      }

      For every object of the [JSON array]{.underline}, verify that the
      structure complies with:

      The name of every name/value pair shall be any of: *eventAction*,
      *eventActor*, *eventDate* or *links*. {

      \"code\": -10901,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: eventAction,
      eventActor, eventDate or links.\"

      }

      The JSON name/value pairs of *eventAction*, *eventActor*, *eventDate*
      and *links* shall exist only once. {

      \"code\": -10902,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a link structure was
      found more than once. \"

      }

      The JSON name *eventAction* shall exist.{

      \"code\": -10903,

      \"value\": \"\<links structure\>\",

      \"message\": \"The eventAction element does not exist.\"

      }

      For the JSON name *eventAction*, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -10904,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      For the JSON name *eventAction*, the value shall be included in the
      **RDAPJSONValues** with Type=\"event action\".{

      \"code\": -10905,

      \"value\": \"\<JSON string\>\",

      \"message\": \"The JSON string is not included as a Value with
      Type=\"event action\" in the RDAPJSONValues data set.

      }

      The JSON name *eventDate* shall exist.{

      \"code\": -10906,

      \"value\": \"\<links structure\>\",

      \"message\": \"The eventDate element does not exist.\"

      }

      For the JSON name *eventDate*, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -10907,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      For the JSON name *eventDate*, the value shall be syntactically valid
      time and date according to RFC3339.{

      \"code\": -10908,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value shall be a syntactically valid time and
      date according to RFC3339.\"

      }

      If the JSON name *eventActor* exists, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -10909,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      If the JSON name *links* exists, the JSON name *eventActor* shall also
      exist.{

      \"code\": -10910,

      \"value\": \"\<events structure\>\",

      \"message\": \"A links structure was found but an eventActor was
      not.\"

      }

      If the JSON name *links* exists, the value shall pass the test Links
      validation \[stdRdapLinksValidation\] defined in this document.{

      \"code\": -10911,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Links
      validation \[stdRdapLinksValidation\].\"

      }

      An *eventAction* value shall only appears once within the events
      array.{

      \"code\": -10912,

      \"value\": \"\<events structure\>\",

      \"message\": \"An eventAction value exists more than once within the
      events array.\"

      }

      **\
      **

      **The following normative references are required to understand this
      test group:**

      RFC3339RFC7159RDAP_RFCs**\
      **
    Input-Parameters:
    Dependencies:
  rdap-stdRdapStatusValidation:
    Summary: Status validation
    Description: |
      **The following steps should be used to test that a status data
      structure is valid:**

      The *status* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -10999-11000,

      \"value\": \"\<status structure\>\",

      \"message\": \"The status structure is not syntactically valid.\"

      }

      Every value of the [JSON array]{.underline} shall be a [JSON
      string]{.underline} data type.{

      \"code\": -11001,

      \"value\": \"\<JSON value\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      Each of the [JSON string]{.underline} values in the [JSON
      array]{.underline} shall be included in the **RDAPJSONValues** with
      Type=\"status\".{

      \"code\": -11002,

      \"value\": \"\<JSON string\>\",

      \"message\": \"The JSON string is not included as a Value with
      Type=\"status\".\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapPort43WhoisServerValidation:
    Summary: Port 43 WHOIS Server
    Description: |
      **The following steps should be used to test that a port43 data
      structure is valid:**

      For the JSON name *port43*, the value shall pass the test
      \[IPv4Validation\], \[IPv6Validation\] or \[DomainNameValidation\]
      defined in this document.{

      \"code\": -11099-11100,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name port43 does not pass
      \[IPv4Validation\], \[IPv6Validation\] or \[DomainNameValidation\].\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapPublicIdsValidation:
    Summary: Public IDs validation
    Description: |
      **The following steps should be used to test that a publicIds data
      structure is valid:**

      The *publicIds* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -11199-11200,

      \"value\": \"\<publicIds structure\>\",

      \"message\": \"The publicIds structure is not syntactically valid.\"

      }

      For every object of the [JSON array]{.underline}, verify that the
      structure complies with:

      The name of every name/value pairs shall be *type* or *identifier*. {

      \"code\": -11201,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: type or
      identifier.\"

      }

      The JSON name/values of *type* or *identifier* shall appear only once.
      {

      \"code\": -11202,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a domain structure
      was found more than once.\"

      }

      The JSON name/values of *type* and *identifier* shall appear. {

      \"code\": -11203,

      \"value\": \"\<publicIds structure\>\",

      \"message\": \"The following name/values shall exist: type or
      identifier.\"

      }

      For the JSON name *type*, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -11204,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      For the JSON name *identifier*, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -11205,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapAsEventActorValidation:
    Summary: asEventActor Validation
    Description: |
      **The following steps should be used to test that an asEventActor data
      structure is valid:**

      The *asEventActor* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -11299-11300,

      \"value\": \"\<asEventActor structure\>\",

      \"message\": \"The asEventActor structure is not syntactically
      valid.\"

      }

      The *asEventActor* data structure must be embedded within an entity
      object, and the entity object must be embedded within another object.{

      \"code\": -11301,

      \"value\": \"\<asEventActor structure\>\",

      \"message\": \"The asEventActor structure is not embedded within an
      entity object and the entity object is not embedded within another
      object.\"

      }

      For every object of the JSON array, verify that the structure complies
      with:

      The name of every name/value pair shall be any of: *eventAction* or
      *eventDate*. {

      \"code\": -11302,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: eventAction
      and eventDate.\"

      }

      The JSON name/values of *eventAction* or *eventDate* shall appear only
      once. {

      \"code\": -11303,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a link structure was
      found more than once.\"

      }

      The JSON name *eventAction* shall exist.{

      \"code\": -11304,

      \"value\": \"\<links structure\>\",

      \"message\": \"The eventAction element does not exist.\"

      }

      For the JSON name *eventAction*, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -11305,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      For the JSON name *eventAction*, the value shall be included in the
      **RDAPJSONValues** with Type=\"event action\".{

      \"code\": -11306,

      \"value\": \"\<JSON string\>\",

      \"message\": \"The JSON string is not included as a Value with
      Type=\"event action\" in the RDAPJSONValues dataset.\"

      }

      The JSON name *eventDate* shall exist.{

      \"code\": -11307,

      \"value\": \"\<links structure\>\",

      \"message\": \"The eventDate element does not exist.\"

      }

      For the JSON name *eventDate*, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -11308,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      For the JSON name *eventDate*, the value shall be syntactically valid
      time and date according to RFC3339.{

      \"code\": -11309,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value shall be a syntactically valid time and
      date according to RFC3339.\"

      }

      An *eventAction* shall only appear once within the events array.{

      \"code\": -11310,

      \"value\": \"\<events structure\>\",

      \"message\": \"An *eventAction* exists more than once within the
      events array.\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC3339RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapIpAddressesValidation:
    Summary: IP Addresses Validation
    Description: |
      **The following steps should be used to test that an ipAddresses data
      structure is valid:**

      The *ipAddresses* data structure must be a syntactically valid JSON
      object.{

      \"code\": -11399-11400,

      \"value\": \"\<ipAddresses structure\>\",

      \"message\": \"The ipAddresses structure is not syntactically valid.\"

      }

      The name of every name/value pair shall be any of: *v4* or *v6*. {

      \"code\": -11401,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: v4 or v6.\"

      }

      The JSON name/values of *v4* and *v6* shall appear only once. {

      \"code\": -11402,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of an ipAddresses
      structure was found more than once.\"

      }

      One *v4* name/values or one *v6* name/value shall appear. {

      \"code\": -11403,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"v4 nor v6 name/value pair exists.\"

      }

      If the JSON name *v4* exists, the value shall pass the following:

      The *v4* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -11404,

      \"value\": \"\<v4 structure\>\",

      \"message\": \"The v4 structure is not syntactically valid.\"

      }

      For every object of the [JSON array]{.underline}, verify that the
      structure complies with:

      Every value of the [JSON array]{.underline} shall be a [JSON
      string]{.underline} data type.{

      \"code\": -11405,

      \"value\": \"\<JSON value\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      The IPv4 address is syntactically valid in dot-decimal notation.{

      \"code\": -11406,

      \"value\": \"\<IPv4 address string\>\",

      \"message\": \"The IPv4 address is not syntactically valid in
      dot-decimal notation.\"

      }

      If the JSON name *v6* exists, the value shall pass the following:

      The *v6* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -11407,

      \"value\": \"\<v6 structure\>\",

      \"message\": \"The v6 structure is not syntactically valid.\"

      }

      For every object of the [JSON array]{.underline}, verify that the
      structure complies with:

      Every value of the [JSON array]{.underline} shall be a [JSON
      string]{.underline} data type.{

      \"code\": -11408,

      \"value\": \"\<JSON value\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      The IPv6 address is syntactically valid.{

      \"code\": -11409,

      \"value\": \"\<IPv6 address string\>\",

      \"message\": \"The IPv6 address is not syntactically valid.\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC791RFC5952RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapVariantsValidation:
    Summary: Variants validation
    Description: |
      **The following steps should be used to test that a variants data
      structure is valid:**

      The *variants* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -11499-11500,

      \"value\": \"\<variants structure\>\",

      \"message\": \"The variants structure is not syntactically valid.\"

      }

      For every object of the [JSON array]{.underline}, verify that the
      structure complies with:

      The name of every name/value pair shall be *relation*, *idnTable* or
      *variantNames*. {

      \"code\": -11501,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: relation,
      idnTable or variantNames.\"

      }

      The JSON name/value pairs of *relation*, *idnTable* and *variantNames*
      shall appear only once. {

      \"code\": -11502,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a link structure was
      found more than once.\"

      }

      The RDAP *relation* data structure must be a syntactically valid *JSON
      array*.{

      \"code\": -11503,

      \"value\": \"\<relation structure\>\",

      \"message\": \"The RDAP Conformance structure is not syntactically
      valid.\"

      }

      For every object of the [JSON array]{.underline}, verify that the
      structure complies with:

      Every value of the [JSON array]{.underline} shall be a [JSON
      string]{.underline} data type.{

      \"code\": -11504,

      \"value\": \"\<JSON value\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      Each of the [JSON string]{.underline} values in the [JSON
      array]{.underline} shall be included in the **RDAPJSONValues** with
      Type=\"domain variant relation\".{

      \"code\": -11505,

      \"value\": \"\<JSON string\>\",

      \"message\": \"The JSON string is not included as a Value with
      Type=\"domain variant relation \".\"

      }

      If the JSON name *idnTable* exists, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -11506,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      The *variantNames* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -11507,

      \"value\": \"\<variantNames structure\>\",

      \"message\": \"The variantNames structure is not syntactically
      valid.\"

      }

      For every object of the [JSON array]{.underline}, verify that the
      structure complies with:

      The name of every name/value pair shall be any of: *ldhName* or
      *unicodeName*{

      \"code\": -11508,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: ldhName or
      unicodeName.\"

      }

      The JSON name/value pairs of *ldhName* or *unicodeName* shall exist
      only once. {

      \"code\": -11509,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a link structure was
      found more than once.\"

      }

      If the JSON name title *ldhName* exists, the value shall pass the test
      LDH name \[stdRdapLdhNameValidation\] defined in this document.{

      \"code\": -11510,

      \"value\": \"\<name/value pair\>\",

      \"message\": \" The value for the JSON name value does not pass LDH
      name \[stdRdapLdhNameValidation\].\"

      }

      If the JSON name *unicodeName* exists, the value shall pass the test
      Unicode name \[stdRdapUnicodeNameValidation\] defined in this
      document.{

      \"code\": -11511,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Unicode
      name \[stdRdapUnicodeNameValidation\].\"

      }

      **The following normative references are required to understand this
      test group:**
    Input-Parameters:
    Dependencies:
  rdap-stdRdapUnicodeNameValidation:
    Summary: Unicode name
    Description: |
      **The following steps should be used to test that a unicodeName is
      valid:**

      The length of each label is between 1 and 63.{

      \"code\": -11599-11600,

      \"value\": \"\<domain name\>\",

      \"message\": \"A DNS label with length not between 1 and 63 was
      found.\"

      }

      A maximum total length of 253 characters not including the last
      \".\".{

      \"code\": -11601,

      \"value\": \"\<domain name\>\",

      \"message\": \"A domain name of more than 253 characters was found.\"

      }

      At least two labels shall exist in the domain name. See,
      RDAP_Technical_Implementation_Guide_2_1 section 1.10.{

      \"code\": -11602,

      \"value\": \"\<domain name\>\",

      \"message\": \"A domain name with less than two labels was found. See
      RDAP_Technical_Implementation_Guide_2_1 section 1.10\"

      }

      Each label of the domain name is a valid \"U-label or \"NR-LDH
      label\". {

      \"code\": -11603,

      \"value\": \"\<domain name\>\",

      \"message\": \"A label not being a valid \"U-label\" or \"NR-LDH
      label\" was found.\"

      }

      Note: the latest version of the IANA IDNA Rules and Derived Property
      Values shall be used. See,
      <https://www.iana.org/assignments/idna-tables-11.0.0/idna-tables-11.0.0.xml>

      Note: some legacy gTLDs may fail this test, because they have a few
      domain name registrations that comply with IDNA2003 but not IDNA2018.
      Such names are not recommended to be used when testing an RDAP
      response with this tool.

      **The following normative references are required to understand this
      test group:**

      DNS_RFCsIDNA_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapLdhNameValidation:
    Summary: LDH name
    Description: |
      **The following steps should be used to test that a ldhName is
      valid:**

      The length of each label is between 1 and 63.{

      \"code\": -11699-11700,

      \"value\": \"\<domain name\>\",

      \"message\": \"A DNS label with length not between 1 and 63 was
      found.\"

      }

      A maximum total length of 253 characters not including the last
      \".\".{

      \"code\": -11701,

      \"value\": \"\<domain name\>\",

      \"message\": \"A domain name of more than 253 characters was found.\"

      }

      At least two labels shall exist in the domain name. See,
      RDAP_Technical_Implementation_Guide_2_1 section 1.10.{

      \"code\": -11702,

      \"value\": \"\<domain name\>\",

      \"message\": \"A domain name with less than two labels was found. See
      RDAP_Technical_Implementation_Guide_2_1 section 1.10\"

      }

      Each label of the domain name is a valid \"A-label or \"NR-LDH
      label\".{

      \"code\": -11703,

      \"value\": \"\<domain name\>\",

      \"message\": \"A label not being a valid \"A-label\" or \"NR-LDH
      label\" was found.\"

      }

      Note: the latest version of the IANA IDNA Rules and Derived Property
      Values shall be used. See,
      <https://www.iana.org/assignments/idna-tables-11.0.0/idna-tables-11.0.0.xml>

      Note: some legacy gTLDs may fail this test, because they have a few
      domain name registrations that comply with IDNA2003 but not IDNA2018.
      Such names are not recommended to be used when testing an RDAP
      response with this tool.

      **The following normative references are required to understand this
      test group:**

      DNS_RFCsIDNA_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapRolesValidation:
    Summary: Roles validation
    Description: |
      **The following steps should be used to test that a roles data
      structure is valid:**

      The *roles* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -11799-11800,

      \"value\": \"\<roles structure\>\",

      \"message\": \"The roles structure is not syntactically valid.\"

      }

      Every value of the [JSON array]{.underline} shall be a [JSON
      string]{.underline} data type.{

      \"code\": -11801,

      \"value\": \"\<JSON value\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      Each of the [JSON string]{.underline} values in the [JSON
      array]{.underline} shall be included in the **RDAPJSONValues** with
      Type=\"role\".{

      \"code\": -11802,

      \"value\": \"\<JSON string\>\",

      \"message\": \"The JSON string is not included as a Value with
      Type=\"role\".\"

      }

      The role value shall only appear once in the [JSON
      array]{.underline}.{

      \"code\": -11803,

      \"value\": \"\<roles structure\>\",

      \"message\": \"A role value appeared more than once.\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapEntitiesValidation:
    Summary: Entities validation
    Description: |
      **The following steps should be used to test that an entities data
      structure is valid:**

      The *entities* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -11899-11900,

      \"value\": \"\<entities structure\>\",

      \"message\": \"The entities structure is not syntactically valid.\"

      }

      Every value of the [JSON array]{.underline} shall pass the test Entity
      lookup validation \[stdRdapEntityLookupValidation\] defined in this
      document.{

      \"code\": -11901,

      \"value\": \"\<JSON value\>\",

      \"message\": \"The JSON value does not pass Entity lookup validation
      \[stdRdapEntityLookupValidation\].\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapSecureDnsValidation:
    Summary: Secure DNS validation
    Description: |
      **The following steps should be used to test that a secureDNS data
      structure is valid:**

      The *secureDNS* data structure must be a syntactically valid JSON
      object.{

      \"code\": -11999-12000,

      \"value\": \"\<secureDNS structure\>\",

      \"message\": \"The domain structure is not syntactically valid.\"

      }

      The name of every name/value pairs shall be *zoneSigned*,
      *delegationSigned*, *maxSigLife*, *dsData* or *keyData*. {

      \"code\": -12001,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: zoneSigned,
      delegationSigned, maxSigLife, dsData or keyData.\"

      }

      The JSON name/values of *zoneSigned*, *delegationSigned*,
      *maxSigLife*, *dsData* and *keyData* shall appear only once. {

      \"code\": -12002,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a domain structure
      was found more than once.\"

      }

      If the JSON name *zoneSigned* appears, the value shall be a [JSON
      boolean]{.underline} data type.{

      \"code\": -12003,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a boolean.\"

      }

      The JSON name *delegationSigned* shall appear.{

      \"code\": -12004,

      \"value\": \"\<links structure\>\",

      \"message\": \"The delegationSigned element does not exist.\"

      }

      For the JSON name *delegationSigned*, the value shall be a [JSON
      boolean]{.underline} data type.{

      \"code\": -12005,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a boolean.\"

      }

      If the JSON name *maxSigLife* exists, the value shall be a [JSON
      number]{.underline} data type between 1 and 2147483647.{

      \"code\": -12006,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a number between 1 and
      2147483647.\"

      }

      One *dsData* name/values or one *keyData* name/value shall appear. {

      \"code\": -12007,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"dsData nor keyData name/value pair exists.\"

      }

      If the JSON name *dsData* appears, the value shall pass the following:

      The *dsData* data structure must be a syntactically valid JSON
      object.{

      \"code\": -12008,

      \"value\": \"\<dsData structure\>\",

      \"message\": \"The dsData structure is not syntactically valid.\"

      }

      The name of every name/value pair shall be any of: *keyTag*,
      *algorithm*, *digest*, *digestType*, *events* or *links*. {

      \"code\": -12009,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: keyTag,
      algorithm, digest, digestType, events or links.\"

      }

      The JSON name/values of *keyTag*, *algorithm*, *digest*, *digestType*,
      *events* or *links* shall appear only once. {

      \"code\": -12010,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a dsData structure
      was found more than once.\"

      }

      The JSON name/values of *keyTag*, *algorithm*, *digest* and
      *digestType* shall appear. {

      \"code\": -12011,

      \"value\": \"\<dsData structure\>\",

      \"message\": \"The following name/values shall exist: keyTag,
      algorithm, digest and digestType.\"

      }

      For the JSON name *keyTag*, the value shall be a JSON number data type
      between 1 and 65535.{

      \"code\": -12012,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a number between 1 and 65535.\"

      }

      For the JSON name *algorithm*, the value shall be a [JSON
      number]{.underline} listed with Zone Signing=Y in
      **dnsSecAlgNumbers**. The values 253 and 254 are not valid for this
      test.{

      \"code\": -12013,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not listed with Zone Signing=Y in
      dnsSecAlgNumbers, or it\'s 253 or 254.\"

      }

      For the JSON name *digest*, the value shall be a [JSON
      string]{.underline} of case-insensitive hexadecimal digits. Whitespace
      is allowed within the hexadecimal text.{

      \"code\": -12014,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string of case-insensitive
      hexadecimal digits. Whitespace is allowed within the hexadecimal
      test.\"

      }

      For the JSON name *digestType*, the value shall be a [JSON
      number]{.underline} assigned in **dsRrTypes**. {

      \"code\": -12015,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not assigned in dsRrTypes.\"

      }

      If the JSON name *events* exists, the value shall pass the test Events
      Validation \[stdRdapEventsValidation\] defined in this document.{

      \"code\": -12016,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Events
      Validation \[stdRdapEventsValidation\].\"

      }

      If the JSON name *links* exists, the value shall pass the test Links
      validation \[stdRdapLinksValidation\] defined in this document.{

      \"code\": -12017,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Links
      validation \[stdRdapLinksValidation\].\"

      }

      If the JSON name *keyData* exists, the value shall pass the following:

      The *keyData* data structure must be a syntactically valid JSON
      object.{

      \"code\": -12018,

      \"value\": \"\<keyData structure\>\",

      \"message\": \"The keyData structure is not syntactically valid.\"

      }

      The name of every name/value pair shall be *flags*, *protocol*,
      *publicKey*, *algorithm*, *events* or *links*. {

      \"code\": -12019,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: flags,
      protocol, publicKey, algorithm, events or links.\"

      }

      The JSON name/values of *flags*, *protocol*, *publicKey*, *algorithm*,
      *events* or *links* shall appear only once. {

      \"code\": -12020,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a keyData structure
      was found more than once.\"

      }

      The JSON name/values of *flags*, *protocol*, *publicKey* and
      *algorithm* shall appear. {

      \"code\": -12021,

      \"value\": \"\<dsData structure\>\",

      \"message\": \"The following name/values shall exist: flags, protocol,
      publicKey and algorithm.\"

      }

      For the JSON name *flags*, the value shall be a [JSON
      number]{.underline} data type with values: 256 or 257.{

      \"code\": -12022,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not 256 or 257.\"

      }

      For the JSON name *protocol*, the value shall be a [JSON
      number]{.underline} data type with value: 3.{

      \"code\": -12023,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not 3.\"

      }

      For the JSON name *publicKey*, the value shall be a [JSON
      string]{.underline}, and the key is represented as a Base64.
      Whitespace is allowed within the text.{

      \"code\": -12024,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string of case-insensitive
      hexadecimal digits. Whitespace is allowed within the hexadecimal
      text.\"

      }

      For the JSON name *algorithm*, the value shall be a JSON number listed
      with Zone Signing=Y in **dnsSecAlgNumbers**. The values 253 and 254
      are not valid for this test.{

      \"code\": -12025,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not listed with Zone Signing=Y in
      dnsSecAlgNumbers, or it\'s 253 or 254.\"

      }

      If the JSON name *events* exists, the value shall pass the test Events
      Validation \[stdRdapEventsValidation\] defined in this document.{

      \"code\": -12026,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Events
      Validation \[stdRdapEventsValidation\].\"

      }

      If the JSON name *links* exists, the value shall pass the test Links
      validation \[stdRdapLinksValidation\] defined in this document.{

      \"code\": -12027,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Links
      validation \[stdRdapLinksValidation\].\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCsDNSSEC_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapErrorResponseBodyValidation:
    Summary: Error Response Body
    Description: |
      **The following steps should be used to test that an error data
      structure is valid:**

      The *error* data structure must be a syntactically valid JSON object.{

      \"code\": -12099-12100,

      \"value\": \"\<error structure\>\",

      \"message\": \"The error structure is not syntactically valid.\"

      }

      At least the following name/value pairs shall appear: *errorCode*,
      *title* and *description*. {

      \"code\": -12101,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"At least the following name/value pairs shall exist:
      errorCode, title and description.\"

      }

      The JSON name/values of *errorCode*, *title*, and *description* shall
      appear only once. {

      \"code\": -12102,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of an error structure
      was found more than once.\"

      }

      For the JSON name *errorCode*, the value shall be a [JSON
      number]{.underline} data type.{

      \"code\": -12103,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a number.\"

      }

      For the JSON name *title*, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -12104,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      The *description* data structure must be a syntactically valid [JSON
      array]{.underline}.{

      \"code\": -12105,

      \"value\": \"\<description structure\>\",

      \"message\": \"The description structure is not syntactically valid.\"

      }

      Every value of the [JSON array]{.underline} of the *description* data
      structure shall be a [JSON string]{.underline} data type.{

      \"code\": -12106,

      \"value\": \"\<JSON value\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      **\
      **

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs

      ## Standard RDAP Object Classes Validations
    Input-Parameters:
    Dependencies:
  rdap-stdRdapDomainLookupValidation:
    Summary: Domain Lookup Validation
    Description: |
      **The following steps should be used to test that a domain data
      structure is valid:**

      The *domain* data structure must be a syntactically valid JSON
      object.{

      \"code\": -12199-12200,

      \"value\": \"\<domain structure\>\",

      \"message\": \"The domain structure is not syntactically valid.\"

      }

      The name of every name/value pairs shall be any of: *objectClassName*,
      *handle*, *ldhName*, *unicodeName*, *variants*, *nameservers*,
      *secureDNS*, *entities*, *status*, *publicIds*, *remarks*, *links*,
      *port43*, *events*, *notices* or *rdapConformance*. {

      \"code\": -12201,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of:
      objectClassName, handle, ldhName, unicodeName, variants, nameservers,
      secureDNS, entities, status, publicIds, remarks, links, port43,
      events, notices or rdapConformance.\"

      }

      The JSON name/values of *objectClassName*, *handle*, *ldhName*,
      *unicodeName*, *variants*, *nameservers*, *secureDNS*, *entities*,
      *status*, *publicIds*, *remarks*, *links*, *port43*, *events*,
      *notices* or *rdapConformance* shall appear only once. {

      \"code\": -12202,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a domain structure
      was found more than once.\"

      }

      For the JSON name *objectClassName*, the value shall be \"domain\".{

      \"code\": -12203,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not \"domain\".\"

      }

      If the JSON name *handle* exists, the value shall be a JSON string
      data type.{

      \"code\": -12204,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      If the JSON name *ldhName*, the value shall pass the test LDH name
      \[stdRdapLdhNameValidation\] defined in this document.{

      \"code\": -12205,

      \"value\": \"\<name/value pair\>\",

      \"message\": \" The value for the JSON name value does not pass LDH
      name \[stdRdapLdhNameValidation\].\"

      }

      If the JSON name *unicodeName* exists, the value shall pass the test
      Unicode name \[stdRdapUnicodeNameValidation\] defined in this
      document.{

      \"code\": -12206,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Unicode
      name \[stdRdapUnicodeNameValidation\].\"

      }

      If the JSON name *variants* exists, the value shall pass the test
      Variants validation \[stdRdapVariantsValidation\] defined in this
      document.{

      \"code\": -12207,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass
      Variants validation \[stdRdapVariantsValidation\].\"

      }

      If the JSON name *nameservers* exists, the value shall pass the test
      Nameserver lookup validation \[stdRdapNameserverLookupValidation\]
      defined in this document.{

      \"code\": -12208,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass
      Nameserver lookup validation \[stdRdapNameserverLookupValidation\].\"

      }

      If the JSON name *secureDNS* exists, the value shall pass the test
      Secure DNS validation \[stdRdapSecureDnsValidation\] defined in this
      document.{

      \"code\": -12209,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Secure
      DNS validation \[stdRdapSecureDnsValidation\].\"

      }

      If the JSON name *entities* exists, the value shall pass the test
      Entities validation \[stdRdapEntitiesValidation\] defined in this
      document.{

      \"code\": -12210,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass
      Entities validation \[stdRdapEntitiesValidation\].\"

      }

      If the JSON name *status* exists, the value shall pass the test Status
      validation \[stdRdapStatusValidation\] defined in this document.{

      \"code\": -12211,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Status
      validation \[stdRdapStatusValidation\].\"

      }

      [\
      ]{.mark}

      If the JSON name *publicIds* exists, the value shall pass the test
      Public IDs validation \[stdRdapPublicIdsValidation\] defined in this
      document.{

      \"code\": -12212,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Public
      IDs validation \[stdRdapPublicIdsValidation\].\"

      }

      If the JSON name *remarks* exists, the value shall pass the test
      Notices and Remarks Validation \[stdRdapNoticesRemarksValidation\]
      defined in this document.{

      \"code\": -12213,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Notices
      and Remarks Validation \[stdRdapNoticesRemarksValidation\].\"

      }

      If the JSON name *links* exists, the value shall pass the test Links
      validation \[stdRdapLinksValidation\] defined in this document.{

      \"code\": -12214,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Links
      validation \[stdRdapLinksValidation\].\"

      }

      If the JSON name *port43* exists, the value shall pass the test Port
      43 WHOIS Server \[stdRdapPort43WhoisServerValidation\] defined in this
      document.{

      \"code\": -12215,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Port 43
      WHOIS Server \[stdRdapPort43WhoisServerValidation\].\"

      }

      If the JSON name *events* exists, the value shall pass the test Events
      Validation \[stdRdapEventsValidation\] defined in this document.{

      \"code\": -12216,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Events
      Validation \[stdRdapEventsValidation\].\"

      }

      If the JSON name *notices* exists, the value shall pass the test
      Notices and Remarks Validation \[stdRdapNoticesRemarksValidation\]
      defined in this document.{

      \"code\": -12217,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Notices
      and Remarks Validation \[stdRdapNoticesRemarksValidation\].\"

      }

      If the JSON name *notices* exists and the domain object is not the
      topmost JSON object.{

      \"code\": -12218,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name notices exists but
      nameserver object is not the topmost JSON object.\"

      }

      If the JSON name *rdapConformance* exists, the value shall pass the
      test RDAP Conformance validation \[stdRdapConformanceValidation\]
      defined in this document.{

      \"code\": -12219,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass RDAP
      Conformance validation \[stdRdapConformanceValidation\].\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapEntityLookupValidation:
    Summary: Entity lookup validation
    Description: |
      **The following steps should be used to test that an entity data
      structure is valid:**

      The *entity* data structure must be a syntactically valid JSON
      object.{

      \"code\": -12299-12300,

      \"value\": \"\<entity structure\>\",

      \"message\": \"The entity structure is not syntactically valid.\"

      }

      The name of every name/value pairs shall be any of: *objectClassName*,
      *handle*, *vcardArray*, *roles*, *publicIds*, *entities*, *remarks*,
      *links*, *events*, *asEventActor*, *status*, *port43*, *notices* or
      *rdapConformance*. {

      \"code\": -12301,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of:
      objectClassName, handle, vcardArray, roles, publicIds, entities,
      remarks, links, events, asEventActor, status, port43, notices or
      rdapConformance.\"

      }

      The JSON name/values of *objectClassName*, *handle*, *vcardArray*,
      *roles*, *publicIds*, *entities*, *remarks*, *links*, *events*,
      *asEventActor*, *status*, *port43*, *notices* or *rdapConformance*
      shall exist only once. {

      \"code\": -12302,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a domain structure
      was found more than once.\"

      }

      For the JSON name *objectClassName*, the value shall be \"entity\".{

      \"code\": -12303,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not \"entity\".\"

      }

      If the JSON name *handle* exists, the value shall be a [JSON
      string]{.underline} data type.{

      \"code\": -12304,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      If the JSON name title *vcardArray* exists, the value shall be
      syntactically valid.{

      \"code\": -12305,

      \"value\": \"\<name/value pair\>\",

      \"message\": \" The value for the JSON name value is not a
      syntactically valid vcardArray.\"

      }

      Note: it\'s expected that a library for testing jCard objects will be
      used.

      If the JSON name *roles* exists, the value shall pass the test Roles
      validation \[stdRdapRolesValidation\] defined in this document.{

      \"code\": -12306,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Roles
      validation \[stdRdapRolesValidation\].\"

      }

      If the JSON name *publicIds* exists, the value shall pass the test
      Public IDs validation \[stdRdapPublicIdsValidation\] defined in this
      document.{

      \"code\": -12307,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Public
      IDs validation \[stdRdapPublicIdsValidation\].\"

      }

      If the JSON name *entities* exists, the value shall pass the test
      Entities validation \[stdRdapEntitiesValidation\] defined in this
      document.{

      \"code\": -12308,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass
      Entities validation \[stdRdapEntitiesValidation\].\"

      }

      If the JSON name *remarks* exists, the value shall pass the test
      Notices and Remarks Validation \[stdRdapNoticesRemarksValidation\]
      defined in this document.{

      \"code\": -12309,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Notices
      and Remarks Validation \[stdRdapNoticesRemarksValidation\].\"

      }

      If the JSON name *links* exists, the value shall pass the test Links
      validation \[stdRdapLinksValidation\] defined in this document.{

      \"code\": -12310,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Links
      validation \[stdRdapLinksValidation\].\"

      }

      If the JSON name *events* exists, the value shall pass the test Events
      Validation \[stdRdapEventsValidation\] defined in this document.{

      \"code\": -12311,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Events
      Validation \[stdRdapEventsValidation\].\"

      }

      If the JSON name *asEventActor* exists, the value shall pass the test
      asEventActor Validation \[stdRdapAsEventActorValidation\] defined in
      this document.{

      \"code\": -12312,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass
      asEventActor Validation \[stdRdapAsEventActorValidation\].\"

      }

      If the JSON name *status* exists, the value shall pass the test Status
      validation \[stdRdapStatusValidation\] defined in this document.{

      \"code\": -12313,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Status
      validation \[stdRdapStatusValidation\].\"

      }

      If the JSON name *port43* exists, the value shall pass the test Port
      43 WHOIS Server \[stdRdapPort43WhoisServerValidation\] defined in this
      document.{

      \"code\": -12314,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Port 43
      WHOIS Server \[stdRdapPort43WhoisServerValidation\].\"

      }

      If the JSON name *notices* exists, the value shall pass the test
      Notices and Remarks Validation \[stdRdapNoticesRemarksValidation\]
      defined in this document.{

      \"code\": -12315,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Notices
      and Remarks Validation \[stdRdapNoticesRemarksValidation\].\"

      }

      If the JSON name *notices* exists and the entity object is not the
      topmost JSON object.{

      \"code\": -12316,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name notices exists but entity
      object is not the topmost JSON object.\"

      }

      If the JSON name *rdapConformance* exists, the value shall pass the
      test RDAP Conformance validation \[stdRdapConformanceValidation\]
      defined in this document.{

      \"code\": -12317,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass RDAP
      Conformance validation \[stdRdapConformanceValidation\].\"

      }

      **\
      **

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapNameserverLookupValidation:
    Summary: Nameserver lookup validation
    Description: |
      **The following steps should be used to test that a nameserver data
      structure is valid:**

      The *nameserver* data structure must be a syntactically valid JSON
      object.{

      \"code\": -12399-12400,

      \"value\": \"\<nameserver structure\>\",

      \"message\": \"The nameserver structure is not syntactically valid.\"

      }

      The name of every name/value pairs shall be any of: *objectClassName*,
      *handle*, *ldhName*, *unicodeName*, *ipAddresses*, *entities*,
      *status*, *remarks*, *links*, *port43*, *events*, *notices* or
      *rdapConformance*. {

      \"code\": -12401,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of:
      objectClassName, handle, ldhName, unicodeName, ipAddresses, entities,
      status, remarks, links, port43, events, notices or rdapConformance.\"

      }

      The JSON name/values of *objectClassName*, *handle*, *ldhName*,
      *unicodeName*, *ipAddresses*, *entities*, *status*, *remarks*,
      *links*, *port43*, *events*, *notices* or *rdapConformance* shall
      exist only once. {

      \"code\": -12402,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a link structure was
      found more than once.\"

      }

      For the JSON name *objectClassName*, the value shall be
      \"nameserver\".{

      \"code\": -12403,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not \"nameserver\".\"

      }

      If the JSON name *handle* exists, the value shall be a JSON string
      data type.{

      \"code\": -12404,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The JSON value is not a string.\"

      }

      If the JSON name *ldhName* exists, the value shall pass the test LDH
      name \[stdRdapLdhNameValidation\] defined in this document.{

      \"code\": -12405,

      \"value\": \"\<name/value pair\>\",

      \"message\": \" The value for the JSON name value does not pass LDH
      name \[stdRdapLdhNameValidation\].\"

      }

      If the JSON name *unicodeName* exists, the value shall pass the test
      Unicode name \[stdRdapUnicodeNameValidation\] defined in this
      document.{

      \"code\": -12406,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Unicode
      name \[stdRdapUnicodeNameValidation\].\"

      }

      If the JSON name *ipAddresses* exists, the value shall pass the test
      IP Addresses Validation \[stdRdapIpAddressesValidation\] defined in
      this document.{

      \"code\": -12407,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass IP
      Addresses Validation \[stdRdapIpAddressesValidation\].\"

      }

      If the JSON name *entities* exists, the value shall pass the test
      Entities validation \[stdRdapEntitiesValidation\] defined in this
      document.{

      \"code\": -12408,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass
      Entities validation \[stdRdapEntitiesValidation\].\"

      }

      If the JSON name *status* exists, the value shall pass the test Status
      validation \[stdRdapStatusValidation\] defined in this document.{

      \"code\": -12409,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Status
      validation \[stdRdapStatusValidation\].\"

      }

      If the JSON name *remarks* exists, the value shall pass the test
      Notices and Remarks Validation \[stdRdapNoticesRemarksValidation\]
      defined in this document.{

      \"code\": -12410,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Notices
      and Remarks Validation \[stdRdapNoticesRemarksValidation\].\"

      }

      If the JSON name *links* exists, the value shall pass the test Links
      validation \[stdRdapLinksValidation\] defined in this document.{

      \"code\": -12411,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Links
      validation \[stdRdapLinksValidation\].\"

      }

      If the JSON name *port43* exists, the value shall pass the test Port
      43 WHOIS Server \[stdRdapPort43WhoisServerValidation\] defined in this
      document.{

      \"code\": -12412,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Port 43
      WHOIS Server \[stdRdapPort43WhoisServerValidation\].\"

      }

      If the JSON name *events* exists, the value shall pass the test Events
      Validation \[stdRdapEventsValidation\] defined in this document.{

      \"code\": -12413,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Events
      Validation \[stdRdapEventsValidation\].\"

      }

      If the JSON name *notices* exists, the value shall pass the test
      Notices and Remarks Validation \[stdRdapNoticesRemarksValidation\]
      defined in this document.{

      \"code\": -12414,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Notices
      and Remarks Validation \[stdRdapNoticesRemarksValidation\].\"

      }

      If the JSON name *notices* exists and the entity object is not the
      topmost JSON object.{

      \"code\": -12415,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name notices exists but entity
      object is not the topmost JSON object.\"

      }

      If the JSON name *rdapConformance* exists, the value shall pass the
      test RDAP Conformance validation \[stdRdapConformanceValidation\]
      defined in this document.{

      \"code\": -12416,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass RDAP
      Conformance validation \[stdRdapConformanceValidation\].\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs
    Input-Parameters:
    Dependencies:
  rdap-stdRdapHelpValidation:
    Summary: Help validation
    Description: |
      **The following steps should be used to test that a help data
      structure is valid:**

      The *help* data structure must be a syntactically valid JSON object.{

      \"code\": -12499-12500,

      \"value\": \"\<help structure\>\",

      \"message\": \"The help structure is not syntactically valid.\"

      }

      The name of every name/value pairs shall be *notices* or
      *rdapConformance*. {

      \"code\": -12501,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of: notices or
      rdapConformance.\"

      }

      The JSON name/values of *notices* or *rdapConformance* shall exist
      only once. {

      \"code\": -12502,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a link structure was
      found more than once.\"

      }

      If the JSON name *notices* exists, the value shall pass the test
      Notices and Remarks Validation \[stdRdapNoticesRemarksValidation\]
      defined in this document.{

      \"code\": -12503,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Notices
      and Remarks Validation \[stdRdapNoticesRemarksValidation\].\"

      }

      If the JSON name *notices* exists and the entity object is not the
      topmost JSON object.{

      \"code\": -12504,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name notices exists but entity
      object is not the topmost JSON object.\"

      }

      If the JSON name *rdapConformance* exists, the value shall pass the
      test RDAP Conformance validation \[stdRdapConformanceValidation\]
      defined in this document.{

      \"code\": -12505,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass RDAP
      Conformance validation \[stdRdapConformanceValidation\].\"

      }

      **The following normative references are required to understand this
      test group:**
    Input-Parameters:
    Dependencies:
  rdap-stdRdapNameserversSearchValidation:
    Summary: Nameservers search validation
    Description: |
      **The following steps should be used to test that a
      nameserverSearchResults data structure is valid:**

      The *nameserverSearchResults* data structure must be a syntactically
      valid JSON object.{

      \"code\": -12599-12600,

      \"value\": \"\<nameserver structure\>\",

      \"message\": \"The nameserver structure is not syntactically valid.\"

      }

      The name of every name/value pairs shall be any of:
      *nameserverSearchResults*, *remarks*, *events*, *notices* or
      *rdapConformance*. {

      \"code\": -12601,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair is not of:
      nameserverSearchResults, remarks, events, notices or
      rdapConformance.\"

      }

      The JSON name/values of *nameserverSearchResults*, *remarks*,
      *events*, *notices* or *rdapConformance* shall exist only once. {

      \"code\": -12602,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The name in the name/value pair of a link structure was
      found more than once.\"

      }

      The *nameserverSearchResults* data structure must be a syntactically
      valid JSON array.{

      \"code\": -12603,

      \"value\": \"\<nameserverSearchResults structure\>\",

      \"message\": \"The nameserverSearchResults structure is not
      syntactically valid.\"

      }

      For every object (i.e. nameserver) of the [JSON array]{.underline},
      verify that the *nameserverSearchResults* structure complies with:

      The object (i.e. nameserver) shall pass the Nameserver lookup
      validation \[stdRdapNameserverLookupValidation\] test.{

      \"code\": -12604,

      \"value\": \"\<nameserver object\>\",

      \"message\": \"The nameserver object does not pass Nameserver lookup
      validation \[stdRdapNameserverLookupValidation\].\"

      }

      If the JSON name *remarks* exists, the value shall pass the test
      Notices and Remarks Validation \[stdRdapNoticesRemarksValidation\]
      defined in this document.{

      \"code\": -12605,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Notices
      and Remarks Validation \[stdRdapNoticesRemarksValidation\].\"

      }

      If the JSON name *events* exists, the value shall pass the test Events
      Validation \[stdRdapEventsValidation\] defined in this document.{

      \"code\": -12606,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Events
      Validation \[stdRdapEventsValidation\].\"

      }

      If the JSON name *notices* exists, the value shall pass the test
      Notices and Remarks Validation \[stdRdapNoticesRemarksValidation\]
      defined in this document.{

      \"code\": -12607,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass Notices
      and Remarks Validation \[stdRdapNoticesRemarksValidation\].\"

      }

      If the JSON name *notices* exists and the entity object is not the
      topmost JSON object.{

      \"code\": -12608,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name notices exists but entity
      object is not the topmost JSON object.\"

      }

      If the JSON name *rdapConformance* exists, the value shall pass the
      test RDAP Conformance validation \[stdRdapConformanceValidation\]
      defined in this document.{

      \"code\": -12609,

      \"value\": \"\<name/value pair\>\",

      \"message\": \"The value for the JSON name value does not pass RDAP
      Conformance validation \[stdRdapConformanceValidation\].\"

      }

      **The following normative references are required to understand this
      test group:**

      RFC7159RDAP_RFCs

      # Collection of RDAP Profile February-2019 tests

      ## Technical Implementation Guide -- General
    Input-Parameters:
    Dependencies:
  rdap-tigSection_1_2_Validation:
    Summary: use of HTTPS
    Description: |
      **The following steps should be used to test the RDAP protocol section
      1.2 of the RDAP_Technical_Implementation_Guide_2_1:**

      If the scheme of the URI to be tested is \"http\":{

      \"code\": -20099-20100,

      \"value\": \"\<URI\>\",

      \"message\": \"The URL is HTTP, per section 1.2 of the
      RDAP_Technical_Implementation_Guide_2_1 shall be HTTPS only.\"

      }

      If the scheme of the URI to be tested is \"https\", perform the same
      RDAP query using \"http\". If the RDAP response provided over \"HTTP\"
      and \"HTTPS\" without considering the value of \"last update of RDAP
      database\" is the same: {

      \"code\": -20101,

      \"value\": \"\<RDAP response provided over HTTP\> + \"\\n/\\n\"
      \<RDAP response provided over HTTPS\>\",

      \"message\": \"The RDAP response was provided over HTTP, per section
      1.2 of the RDAP_Technical_Implementation_Guide_2_1 shall be HTTPS
      only.\"

      }

      Note: the test \[tigSection_1_2_Validation\] shall be performed on the
      URL on every HTTP redirect.
    Input-Parameters:
    Dependencies:
  rdap-tigSection_1_3_Validation:
    Summary: use of obsolete SSL/TLS versions
    Description: |
      **The following steps should be used to test the RDAP protocol section
      1.3 of the RDAP_Technical_Implementation_Guide_2_1:**

      If the scheme of the URI to be tested is \"https\", verify that SSLv2
      and SSLv3 are not offered by the RDAP server.{

      \"code\": -20199-20200,

      \"value\": \"\<URI\>\",

      \"message\": \"The RDAP server is offering SSLv2 and/or SSLv3.\"

      }

      Note: the test \[tigSection_1_3_Validation\] shall be performed on the
      URL on every HTTP redirect.
    Input-Parameters:
    Dependencies:
  rdap-tigSection_1_6_Validation:
    Summary: support for HEAD
    Description: |
      **The following steps should be used to test the RDAP protocol section
      1.6 of the RDAP_Technical_Implementation_Guide_2_1:**

      The tool shall use the HTTP HEAD method on the URI to be tested. If
      the HTTP Status code is different from the status code obtained when
      doing the GET method:{

      \"code\": -20299-20300,

      \"value\": \"\<HTTP Status code when using the GET method\>
      \"\\n/\\n\" \"\<HTTP Status code when using the HEAD method\>\",

      \"message\": \"The HTTP Status code obtained when using the HEAD
      method is different from the GET method. See section 1.6 of the
      RDAP_Technical_Implementation_Guide_2_1.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-tigSection_1_8_Validation:
    Summary: IPv4/IPv6 resolvability
    Description: |
      **The following steps should be used to test the RDAP protocol section
      1.8 of the RDAP_Technical_Implementation_Guide_2_1:**

      Obtain the Resource Record for the A QTYPE for the host in the URI.
      Validate that the status of the DNS response is not NOERROR. Validate
      that all IPv4 addresses in the RDATA pass IPv4 address validation
      \[ipv4Validation\]:{

      \"code\": -20399-20400,

      \"value\": \"\<IPv4 addresses\>\",

      \"message\": \"The RDAP service is not provided over IPv4. See section
      1.8 of the RDAP_Technical_Implementation_Guide_2_1.\"

      }

      Obtain the Resource Record for the AAAA QTYPE for the host in the URI.
      Validate that the status of the DNS response is not NOERROR. Validate
      that all IPv6 addresses in the RDATA pass IPv6 address validation
      \[ipv6Validation\]:{

      \"code\": -20401,

      \"value\": \"\<IPv6 addresses\>\",

      \"message\": \"The RDAP service is not provided over IPv6. See section
      1.8 of the RDAP_Technical_Implementation_Guide_2_1.\"

      }

      Note: the test \[tigSection_1_8_Validation\] shall be performed on the
      URL on every HTTP redirect.
    Input-Parameters:
    Dependencies:
  rdap-tigSection_1_13_Validation:
    Summary: Access-Control-Allow-Origin header
    Description: |
      **The following steps should be used to test the RDAP protocol section
      1.13 of the RDAP_Technical_Implementation_Guide_2_1:**

      Validate that the HTTP header \"Access-Control-Allow-Origin: \*\" is
      included in the RDAP response.{

      \"code\": -20499-20500,

      \"value\": \"\<HTTP headers\>\",

      \"message\": \"The HTTP header \"Access-Control-Allow-Origin: \*\" is
      not included in the HTTP headers. See section 1.13 of the
      RDAP_Technical_Implementation_Guide_2_1.\"

      }

      Note: the test \[tigSection_1_13_Validation\] shall be performed on
      the URL on every HTTP redirect.
    Input-Parameters:
    Dependencies:
  rdap-tigSection_1_14_Validation:
    Summary: presence of "icann_rdap_technical_implementation_guide_0" in "rdapConformance"
    Description: |
      **The following steps should be used to test the RDAP protocol section
      1.14 of the RDAP_Technical_Implementation_Guide_2_1:**

      Validate that the JSON string value
      \"icann_rdap_technical_implementation_guide_0\" is included in the
      RDAP Conformance data structure.{

      \"code\": -20599-20600,

      \"value\": \"\<rdapConformance data structure\>\",

      \"message\": \"The RDAP Conformance data structure does not include
      icann_rdap_technical_implementation_guide_0. See section 1.14 of the
      RDAP_Technical_Implementation_Guide_2_1.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-tigSection_3_3_and_3_4_Validation:
    Summary: presence of link object(s) in notice(s)
    Description: |
      **The following steps should be used to test the RDAP protocol section
      3.3 and 3.4 of the RDAP_Technical_Implementation_Guide_2_1:**

      Validate that at least one links data structure exists within the
      notices object in the topmost object.{

      \"code\": -20699-20700,

      \"value\": \"\<notices data structure\>\",

      \"message\": \"A links object was not found in the notices object in
      the topmost object. See section 3.3 and 3.4 of the
      RDAP_Technical_Implementation_Guide_2_1.\"

      }

      [\
      ]{.mark}
    Input-Parameters:
    Dependencies:
  rdap-tigSection_4_1_Validation:
    Summary: structured addresses in entity jCards
    Description: |
      **The following steps should be used to test the RDAP protocol section
      4.1 of the TIG:**

      Validate that all the *entities* in the RDAP Response contain
      structured address. If a street address has more than one line, it
      MUST be structured as an array of strings. {

      \"code\": -20799-20800,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"An entity with a non-structured address was found. See
      section 4.1 of the TIG.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-tigSection_7_1_and_7_2_Validation:
    Summary: voice/fax type for tel nodes in entity jCards
    Description: |
      **The following steps should be used to test the RDAP protocol section
      7.1 and 7.2 of the TIG:**

      Validate that at all the *tel* properties in the *entities* in the
      RDAP Response contain voice or fax as type parameter. {

      \"code\": -20899-20900,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"An entity with a tel property without a voice or fax
      type was found. See section 7.1 and 7.2 of the TIG.\"

      }

      ## Technical Implementation Guide - Registry
    Input-Parameters:
    Dependencies:
  rdap-tigSection_1_11_1_Validation:
    Summary: bootstrap registration
    Description: |
      **The following steps should be used to test the RDAP protocol section
      1.11.1 and 1.2 of the RDAP_Technical_Implementation_Guide_2_1:**

      Verify that the TLD of the domain name is listed in the
      bootstrapDomainNameSpace.{

      \"code\": -23099-23100,

      \"value\": \"\<TLD\> + \"\\n/\\n\" \<bootstrapDomainNameSpace\>\",

      \"message\": \"The TLD is not included in the
      bootstrapDomainNameSpace. See section 1.11.1 of the
      RDAP_Technical_Implementation_Guide_2_1.\"

      }

      Validate that at least one base URL exists in the
      bootstrapDomainNameSpace for the TLD.{

      \"code\": -23101,

      \"value\": \"\<TLD element in bootstrapDomainNameSpace\>\",

      \"message\": \"The TLD entry in bootstrapDomainNameSpace does not
      contain a base URL. See section 1.11.1 of the
      RDAP_Technical_Implementation_Guide_2_1.\"

      }

      For the entry of the TLD in bootstrapDomainNameSpace verify that every
      of the base URLs contain a schema of \"https\".{

      \"code\": -23102,

      \"value\": \"\<TLD entry in bootstrapDomainNameSpace\>\",

      \"message\": \"One or more of the base URLs for the TLD contain a
      schema different from https. See section 1.2 of the
      RDAP_Technical_Implementation_Guide_2_1.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-tigSection_3_2_Validation:
    Summary: rel="related" link in topmost object
    Description: |
      **The following steps should be used to test the RDAP protocol section
      3.2 of the RDAP_Technical_Implementation_Guide_2_1:**

      Validate that a links data structure in the topmost object exists, and
      the links object shall contain the elements *rel*:related and *href*.{

      \"code\": -23199-23200,

      \"value\": \"\<links data structure\>\",

      \"message\": \"A links data structure in the topmost object exists,
      and the links object shall contain the elements rel:related and href,
      but they were not found. See section 3.2 of the
      RDAP_Technical_Implementation_Guide_2_1.\"

      }

      [\
      ]{.mark}
    Input-Parameters:
    Dependencies:
  rdap-tigSection_6_1_Validation:
    Summary: publicIds property of registrar entity
    Description: |
      **The following steps should be used to test the RDAP protocol section
      6.1 of the RDAP_Technical_Implementation_Guide_2_1:**

      For the *entity* with the registrar role within the domain object,
      validate that a *publicIds* member is included. {

      \"code\": -23299-23300,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"A publicIds member is not included in the entity with
      the registrar role.\"

      }

      For the *entity* with the registrar role within the domain object, if
      a *publicIds* member is included, validate that the identifier member
      is a positive integer.{

      \"code\": -23301,

      \"value\": \"\<publicIds data structure\>\",

      \"message\": \"The identifier of the publicIds member of the entity
      with the registrar role is not a positive integer.\"

      }

      ## Technical Implementation Guide -- Registrar
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_1_2_2_Validation:
    Summary: no JavaScript
    Description: |
      **The following steps should be used to test the RDAP protocol section
      1.2.2 of the RDAP_Response_Profile_2_1:**

      Validate that the RDAP response does not contain browser executable
      code (e.g., JavaScript).{

      \"code\": -40099-40100,

      \"value\": \"\<rdap response\>\",

      \"message\": \"The RDAP response contains browser executable code
      (e.g., JavaScript). See section 1.2.2 of the
      RDAP_Response_Profile_2_1.\"\"

      }

      Note: a library for HTML sanitizing
      (<https://en.wikipedia.org/wiki/HTML_sanitization>) may be used for
      this test.
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_1_3_Validation:
    Summary: presence of "icann_rdap_response_profile_0" in "rdapConformance"
    Description: |
      **The following steps should be used to test the RDAP protocol section
      1.3 of the RDAP_Response_Profile_2_1:**

      Validate that the JSON string value \"icann_rdap_response_profile_0\"
      is included in the *RDAP Conformance* data structure.{

      \"code\": -40199-40200,

      \"value\": \"\<rdapConformance data structure\>\",

      \"message\": \"The RDAP Conformance data structure does not include
      icann_rdap_response_profile_0. See section 1.3 of the
      RDAP_Response_Profile_2_1.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_1_4_Validation:
    Summary: empty country name parameter of entity jCards
    Description: |
      **The following steps should be used to test the RDAP protocol section
      1.4 of the RDAP_Response_Profile_2_1:**

      Validate that the country name parameter is empty in the *adr* of all
      the jCard objects in the RDAP response.{

      \"code\": -40399-40400,

      \"value\": \"\<vcard object\>\",

      \"message\": \"A vcard object with a country name parameter with data
      was found. \"

      }

      ## RDAP Response Profile - Miscellaneous
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_3_1_3_and_2_7_6_and_3_3_and_4_4_Validation:
    Summary: presence of "last update of RDAP database" event
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.3.1.3, 2.7.6, 3.3 and 4.4 of the RDAP_Response_Profile_2_1:**

      Validate that an *eventAction* type \"last update of RDAP database\"
      exists in events structure included in the topmost object.{

      \"code\": -43099-43100,

      \"value\": \"\<events data structure\>\",

      \"message\": \"An eventAction type last update of RDAP database does
      not exists in the topmost events data structure. See section 2.3.1.3,
      2.7.6, 3.3 and 4.4 of the RDAP_Response_Profile_2_1.\"

      }

      ## RDAP Response Profile - Domain
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_1_Validation:
    Summary: presence of ldhName/unicodeName property for A-label/U-label domain lookup
      responses, respectively
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.1 of the RDAP_Response_Profile_2_1:**

      If domain/\<domain name\> in the RDAP Query URI contains only A-label
      or NR-LDH labels, the topmost domain object shall contain a
      *ldhName*.{

      \"code\": -46099-46100,

      \"value\": \"\<domain object\>\",

      \"message\": \"The RDAP Query URI contains only A-label or NR-LDH
      labels, the topmost domain object does not contain a ldhName member.
      See section 2.1 of the RDAP_Response_Profile_2_1.\"

      }

      If domain/\<domain name\> in the RDAP Query URI contains one or more
      U-label, the topmost domain object shall contain an *unicodeName*.{

      \"code\": -46101,

      \"value\": \"\<domain object\>\",

      \"message\": \" The RDAP Query URI contains one or more U-label, the
      topmost domain object does not contain a unicodeName member. See
      section 2.1 of the RDAP_Response_Profile_2_1.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_2_Validation:
    Summary: format of handle property
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.2 of the RDAP_Response_Profile_2_1:**

      The handle in the topmost *domain* object shall comply with the
      following format specified in RFC5730: \"(\\w\|\_){1,80}-\\w{1,8}\". {

      \"code\": -46199-46200,

      \"value\": \"\<domain object\>\",

      \"message\": \"The handle in the domain object does not comply with
      the format (\\w\|\_){1,80}-\\w{1,8} specified in RFC5730\".\"

      }

      If the handle in the topmost *domain* object comply with the format:
      \"(\\w\|\_){1,80}-\\w{1,8}\", validate that the string followed by a
      hyphen (\"-\", ASCII value 0x002D) is registered in **EPPROID**.{

      \"code\": -46201,

      \"value\": \"\<domain object\>\",

      \"message\": \"The globally unique identifier in the domain object
      handle is not registered in EPPROID.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_3_1_1_Validation:
    Summary: presence of "registration" event
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.3.1.1 of the RDAP_Response_Profile_2_1:**

      Validate that an *eventAction* of type \"registration\" exists in the
      topmost events structure.{

      \"code\": -46299-46300,

      \"value\": \"\<events data structure\>\",

      \"message\": \"An eventAction of type registration does not exists in
      the topmost events data structure. See section 2.3.1.1 of the
      RDAP_Response_Profile_2_1.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_3_1_2_Validation:
    Summary: presence of "expiration" event
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.3.1.2 of the RDAP_Response_Profile_2_1:**

      Validate that an *eventAction* type \"expiration\" exists in the
      topmost events structure.{

      \"code\": -46399-46400,

      \"value\": \"\<events data structure\>\",

      \"message\": \"An eventAction of type expiration does not exists in
      the topmost events data structure. See section 2.3.1.2 of the
      RDAP_Response_Profile_2_1.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_notices_included_Validation:
    Summary: presence of "notices" property
    Description: |
      **The following steps should be used to test that a notices member
      appear in the RDAP response:**

      Validate that a *notices* member appears in the RDAP response.{

      \"code\": -46499-46500,

      \"value\": \"\<RDAP response\>\",

      \"message\": \"A notices members does not appear in the RDAP
      response.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_6_3_Validation:
    Summary: presence of "Status Codes" notice
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.6.3 of the RDAP_Response_Profile_2_1:**

      Validate that the *notices* member contains an element in the [JSON
      array]{.underline} with a title "Status Codes", a description
      containing the string "For more information on domain status codes,
      please visit https://icann.org/epp" and a links member with an *href*
      containing \"https://icann.org/epp\".{

      \"code\": -46599-46600,

      \"value\": \"\<notices structure\>\",

      \"message\": \"The notice for <https://icann.org/epp> was not found.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_11_Validation:
    Summary: presence of "RDDS Inaccuracy Complaint Form" notice
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.11 of the RDAP_Response_Profile_2_1:**

      Validate that the *notices* member contains an element in the [JSON
      array]{.underline} with a title "RDDS Inaccuracy Complaint Form", a
      description containing the string "URL of the ICANN RDDS Inaccuracy
      Complaint Form: https://icann.org/wicf" and a links member with an
      *href* containing \"https://icann.org/wicf\".{

      \"code\": -46699-46700,

      \"value\": \"\<notices structure\>\",

      \"message\": \"The notice for <https://icann.org/wicf> was not
      found.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_10_Validation:
    Summary: presence of secureDNS property
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.10 of the RDAP_Response_Profile_2_1:**

      Validate that a *secureDNS* member is included in the domain object.{

      \"code\": -46799-46800,

      \"value\": \"\<domain object\>\",

      \"message\": \"A secureDNS member does not appear in the domain
      object.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_rfc5731_Validation:
    Summary: domain status code validation
    Description: "**The following steps should be used to test that the status values\ncomply
      with RFC5731:**\n\n1.  \n\nValidate that the values of the *status* member in
      the topmost object\ncomply with the following:\\\"active\\\" status MUST NOT
      be combined with\nany other status.\\\"pending delete\\\" status MUST NOT be
      combined with\neither \\\"client delete prohibited\\\" or \\\"server delete
      prohibited\\\"\nstatus.\\\"pending renew\\\" status MUST NOT be combined with
      either\n\\\"client renew prohibited\\\" or \\\"server renew prohibited\\\"\nstatus.\\\"pending
      transfer\\\" status MUST NOT be combined with either\n\\\"client transfer prohibited\\\"
      or \\\"server transfer prohibited\\\"\nstatus.\\\"pending update\\\" status
      MUST NOT be combined with either\n\\\"client update prohibited\\\" or \\\"server
      update prohibited\\\"\nstatus.The pending create, pending delete, pending renew,
      pending\ntransfer, and pending update status values MUST NOT be combined with\neach
      other.{\n\n\\\"code\\\": -46899-46900,\n\n\\\"value\\\": \\\"\\<status data
      structure\\>\\\",\n\n\\\"message\\\": \\\"The values of the status data structure
      does not comply\nwith RFC5731.\\\"\n\n}\n"
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_rfc3915_Validation:
    Summary: RGP status code validation
    Description: "**The following steps should be used to test that the status values\ncomply
      with RFC3915:**\n\n1.  \n\nValidate that the values of the *status* member in
      the topmost object\ncomply with the following:\\\"redemption period\\\" status
      MUST only be\ncombined with \\\"pending delete\\\".\\\"pending restore\\\" status
      MUST only\nbe combined with \\\"pending delete\\\".{\n\n\\\"code\\\": -46999-47000,\n\n\\\"value\\\":
      \\\"\\<status data structure\\>\\\",\n\n\\\"message\\\": \\\"The values of the
      status data structure does not comply\nwith RFC3915.\\\"\n\n}\n"
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_6_1_Validation:
    Summary: at least one status code
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.6.1 of the RDAP_Response_Profile_2_1:**

      Validate that a *status* member in the topmost object contain at least
      one value.{

      \"code\": -47099-47100,

      \"value\": \"\<status data structure\>\",

      \"message\": \"The status member does not contain at least one
      value.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_9_1_and_2_9_2_Validation:
    Summary: presence and validity of ldhName, handle, status properties in domain
      nameservers
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.9.1 and 2.9.2 of the RDAP_Response_Profile_2_1:**

      If the *nameservers* member is included within the *domain* object,
      validate that all nameserver objects contain the *ldhName* element.{

      \"code\": -47199-47200,

      \"value\": \"\<nameservers data structure\>\",

      \"message\": \"A nameserver object without ldhName was found.\"

      }

      If the *nameservers* member is included within the *domain* object,
      validate that all handles in the nameserver objects comply with the
      following format specified in RFC5730: \"(\\w\|\_){1,80}-\\w{1,8}\". {

      \"code\": -47201,

      \"value\": \"\<nameserver object\>\",

      \"message\": \"The handle in the nameserver object does not comply
      with the format (\\w\|\_){1,80}-\\w{1,8} specified in RFC5730\".\"

      }

      If the *nameservers* member is included within the *domain* object,
      validate that the string followed by a hyphen (\"-\", ASCII value
      0x002D) is registered in **EPPROID** for all the handles that comply
      with the format \"(\\w\|\_){1,80}-\\w{1,8}\".{

      \"code\": -47202,

      \"value\": \"\<nameserver object\>\",

      \"message\": \"The globally unique identifier in the nameserver object
      handle is not registered in EPPROID.\"

      }

      If the *nameservers* member is included within the *domain* object and
      at least one nameserver object contains a *handle* or a *status*
      element, validate that all nameserver objects include a *handle* and a
      *status* element. {

      \"code\": -47203,

      \"value\": \"\<nameserver object\>\",

      \"message\": \"The handle or status in the nameserver object is not
      included.\"

      }

      If the *nameservers* member is included within the domain object,
      validate that all *status* elements included in the nameserver objects
      comply with the following:\"active\" status MAY only be combined with
      \"associated\" status.\"associated\" status MAY be combined with any
      status.\"pending delete\" status MUST NOT be combined with either
      \"client delete prohibited\" or \"server delete prohibited\"
      status.\"pending update\" status MUST NOT be combined with either
      \"client update prohibited\" or \"server update prohibited\"
      status.The pending create, pending delete, pending renew, pending
      transfer, and pending update status values MUST NOT be combined with
      each other.{

      \"code\": -47204,

      \"value\": \"\<status data structure\>\",

      \"message\": \"The values of the status data structure does not comply
      with RFC5732.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_4_1_Validation:
    Summary: presence and validity of the registrar entity
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.4.1 of the RDAP_Response_Profile_2_1:**

      An *entity* with the registrar role within the topmost domain object
      shall exist. {

      \"code\": -47299-47300,

      \"value\": \"\<domain object data structure\>\",

      \"message\": \"An entity with the registrar role was not found in the
      domain topmost object.\"

      }

      Only one *entity* with the registrar role within the topmost domain
      object shall exist. {

      \"code\": -47301,

      \"value\": \"\<domain object data structure\>\",

      \"message\": \"More than one entities with the registrar role were
      found in the domain topmost object.\"

      }

      For the *entity* with the registrar role within the topmost domain
      object, validate that a *fn* member is included in all of the vcard
      objects. {

      \"code\": -47302,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"An fn member was not found in one or more vcard objects
      of the entity with the registrar role.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_4_2_and_2_4_3_Validation:
    Summary: validation of the publicIds and handle properties of the registrar entity
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.4.2 and 2.4.3 of the RDAP_Response_Profile_2_1:**

      For the *entity* with the registrar role within the topmost object,
      validate that a *publicIds* member is included. {

      \"code\": -47399-47400,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"A publicIds member is not included in the entity with
      the registrar role.\"

      }

      For the *entity* with the registrar role within the domain object, if
      a *publicIds* member is included, validate that the identifier member
      is a positive integer.{

      \"code\": -47401,

      \"value\": \"\<publicIds data structure\>\",

      \"message\": \"The identifier of the publicIds member of the entity
      with the registrar role is not a positive integer.\"

      }

      For the *entity* with the registrar role within the domain object,
      validate that the *handle* member is a positive integer.{

      \"code\": -47402,

      \"value\": \"\<publicIds data structure\>\",

      \"message\": \"The handle of the entity with the registrar role is not
      a positive integer.\"

      }

      For the *entity* with the registrar role within the domain object, if
      a *publicIds* member is included, validate that the *identifier*
      member equals the *handle* member.{

      \"code\": -47403,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"The identifier of the publicIds member of the entity
      with the registrar role is not equal to the handle member.\"

      }

      For the *entity* with the registrar role within the domain object,
      validate that the value of the *handle* member exists in the
      **registrarId**.{

      \"code\": -47404,

      \"value\": \"\<handle\> + \"\\n/\\n\" + \<registrarId\>\",

      \"message\": \"The handle references an IANA Registrar ID that does
      not exist in the **registrarId**.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_4_5_Validation:
    Summary: abuse role for the registrar entity
    Description: |
      For the *entity* with the registrar role within the *domain* object,
      validate that an *entity* with the abuse role is included, and the
      entity with the abuse role includes a *tel* and *email* members in all
      the vcard objects.{

      \"code\": -47499-47500,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"Tel and email members were not found for the entity
      within the entity with the abuse role in the topmost domain object.\"

      }

      ## RDAP Response Profile - Nameserver
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_4_1_Validation:
    Summary: presence of ldhName/unicodeName property for A-label/U-label nameserver
      lookup responses, respectively
    Description: |
      **The following steps should be used to test the RDAP protocol section
      4.1 of the RDAP_Response_Profile_2_1:**

      If nameserver/\<nameserver name\> in the RDAP Query URI contains only
      A-label or NR-LDH labels, the topmost domain object shall contain a
      *ldhName*.{

      \"code\": -49099-49100,

      \"value\": \"\<nameserver object\>\",

      \"message\": \"The RDAP Query URI contains only A-label or NR-LDH
      labels, the topmost nameserver object does not contain a ldhName
      member. See section 2.1 of the RDAP_Response_Profile_2_1.\"

      }

      If nameserver/\<nameserver name\> in the RDAP Query URI contains one
      or more U-label, the topmost domain object shall contain an
      *unicodeName*.{

      \"code\": -49101,

      \"value\": \"\<nameserver object\>\",

      \"message\": \" The RDAP Query URI contains one or more U-label, the
      topmost nameserver object does not contain a unicodeName member. See
      section 2.1 of the RDAP_Response_Profile_2_1.\"

      }

      The handle in the topmost *nameserver* object shall comply with the
      following format specified in RFC5730: \"(\\w\|\_){1,80}-\\w{1,8}\". {

      \"code\": -49102,

      \"value\": \"\<nameserver object\>\",

      \"message\": \"The handle in the nameserver object does not comply
      with the format (\\w\|\_){1,80}-\\w{1,8} specified in RFC5730\".\"

      }

      If the handle in the topmost *nameserver* object comply with the
      format: \"(\\w\|\_){1,80}-\\w{1,8}\", validate that the string
      followed by a hyphen (\"-\", ASCII value 0x002D) is registered in
      **EPPROID**.{

      \"code\": -49103,

      \"value\": \"\<nameserver object\>\",

      \"message\": \"The globally unique identifier in the nameserver object
      handle is not registered in EPPROID.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_4_3_Validation:
    Summary: presence and validity of the registrar entity
    Description: |
      **The following steps should be used to test the RDAP protocol section
      4.3 of the RDAP_Response_Profile_2_1.**

      **The following steps shall only be executed if an entity with the
      registrar role exists within the topmost object, and the handle is
      different from \"not applicable\":**

      For the *entity* with the registrar role within the topmost object,
      validate that a *publicIds* member is included. {

      \"code\": -49199-49200,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"A publicIds member is not included in the entity with
      the registrar role.\"

      }

      For the *entity* with the registrar role within the domain object, if
      a *publicIds* member is included, validate that the identifier member
      is a positive integer.{

      \"code\": -49201,

      \"value\": \"\<publicIds data structure\>\",

      \"message\": \"The identifier of the publicIds member of the entity
      with the registrar role is not a positive integer.\"

      }

      For the *entity* with the registrar role within the domain object,
      validate that the *handle* member is a positive integer.{

      \"code\": -49202,

      \"value\": \"\<publicIds data structure\>\",

      \"message\": \"The handle of the entity with the registrar role is not
      a positive integer.\"

      }

      For the *entity* with the registrar role within the domain object, if
      a *publicIds* member is included, validate that the *identifier*
      member equals the *handle* member.{

      \"code\": -49203,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"The identifier of the publicIds member of the entity
      with the registrar role is not equal to the handle member.\"

      }

      For the *entity* with the registrar role within the domain object,
      validate that the value of the *handle* member exists in the
      **registrarId**.{

      \"code\": -49204,

      \"value\": \"\<handle\> + \"\\n/\\n\" + \<registrarId\>\",

      \"message\": \"The handle references an IANA Registrar ID that does
      not exist in the **registrarId**.\"

      }

      **\
      **

      **The following steps shall only be executed if an entity with the
      registrar role exists within the topmost object, and the handle is
      \"not applicable\":**

      For the *entity* with the registrar role within the topmost object,
      validate that a *publicIds* member is not included. {

      \"code\": -49205,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"A publicIds member is included in the entity with the
      registrar role.\"

      }
    Input-Parameters:
    Dependencies:
  rdap-nameserver_status:
    Summary: validation of nameserver status codes
    Description: |

      If a *status* element is included in the nameserver object, validate
      that it complies with the following:\"active\" status MAY only be
      combined with \"associated\" status.\"associated\" status MAY be
      combined with any status.\"pending delete\" status MUST NOT be
      combined with either \"client delete prohibited\" or \"server delete
      prohibited\" status.\"pending update\" status MUST NOT be combined
      with either \"client update prohibited\" or \"server update
      prohibited\" status.The pending create, pending delete, pending renew,
      pending transfer, and pending update status values MUST NOT be
      combined with each other.{

      \"code\": -49299-49300,

      \"value\": \"\<status data structure\>\",

      \"message\": \"The values of the status data structure does not comply
      with RFC5732.\"

      }

      ## RDAP Response Profile -- Entities within Domain
    Input-Parameters:
    Dependencies:
  rdap-rdapResponseProfile_2_7_5_3_Validation:
    Summary: proper redaction of domain entities
    Description: |
      **The following steps should be used to test the RDAP protocol section
      2.7.5.3 of the RDAP_Response_Profile_2_1:**

      For the *entities* with the registrant, administrative, technical and
      billing role within the domain object, if the *email* property is
      omitted, validate that a remarks element containing a title member
      with a value \"EMAIL REDACTED FOR PRIVACY\" and a type member with a
      value \"object redacted due to authorization\" is included in the
      entity object.{

      \"code\": -54999-55000,

      \"value\": \"\<entity data structure\>\",

      \"message\": \"An entity with the administrative, technical, or
      billing role without a valid \"EMAIL REDACTED FOR PRIVACY\" remark was
      found. See section 2.7.5.3 of the RDAP_Response_Profile_2_1.\"

      }

      Note: this test also includes 2.7.5.1.

      ## RDAP Response Profile - Entities within Domain - Registrar
    Input-Parameters:
    Dependencies:
  rdap-rdaptigSection_1_1_3_redactionExtension:
    Summary: use of Redacted Fields extension, validation of redacted paths
  rdap-rdaptigSection_3_3_3_termsOfService:
    Summary: presence of terms-of-service link
  rdap-rdapResponseProfile_1_6_contactReprestentation:
    Summary: validate use of jCard and presence of alternative format(s)
  rdap-rdapResponseProfile_2_4_6_registrarAboutLink:
    Summary: presence of "about" link in registrar entity

  rde-01:
    Summary: validate filename format
    Description: |
      the deposit filename must conform to the format specified in the RA.
    Input-Parameters:
      - rde.deposit
  rde-02:
    Summary: validate signature(s)
    Description: |
      the signature must be valid for the deposit file and the RSP's key.
    Input-Parameters:
      - rde.deposit
      - rde.signature
  rde-03:
    Summary: decrypt deposit file(s)
    Description: |
      it must be possible to decrypt the deposit file using the RST key.
    Input-Parameters:
      - rde.deposit
  rde-04:
    Summary: validate XML/CSV
    Description: |
      * XML deposit files must be well-formed and validate against the XML
        schema.
      * CSV files must conform to RFC 4180.
    Input-Parameters:
      - rde.deposit
  rde-04:
    Summary: validate object types
    Description: |
      the header object must reference the correct object XML namespace URIs.
    Input-Parameters:
      - rde.deposit
      - general.minimumPublicDataSet
      - epp.objectURIs
  rde-06:
    Summary: validate object counts
    Description: |
      the number of each type of object must match the number of objects
      actually present in the deposit file.
    Input-Parameters:
      - rde.deposit
  rde-07:
    Summary: validate domain objects
    Description: |
      domain objects (whether CSV or XML) must have the required object
      properties, and the values of those object properties must be well-formed.

      Contact and/or host objects which are referenced in domain objects must be
      present in the deposit.
    Input-Parameters:
      - rde.deposit
      - general.minimumPublicDataSet
  rde-08:
    Summary: validate host objects (if applicable)
    Description: |
      host objects (whether CSV or XML) must have the required object
      properties, and the values of those object properties must be well-formed.
    Input-Parameters:
      - rde.deposit
      - epp.hostModel
  rde-09:
    Summary: validate contact objects (if applicable)
    Description: |
      contact objects (whether CSV or XML) must have the required object
      properties, and the values of those object properties must be well-formed.
    Input-Parameters:
      - rde.deposit
      - general.minimumPublicDataSet
  rde-10:
    Summary: validate registrar objects
    Description: |
      registrar objects (whether CSV or XML) must have the required object
      properties, and the values of those object properties must be well-formed.
    Input-Parameters:
      - rde.deposit
  rde-11:
    Summary: validate IDN table objects
    Description: |
      IDN table objects (whether CSV or XML) must have the required object
      properties, and the values of those object properties must be well-formed.

      All IDN table objects present in the deposit must correspond to IDN tables
      approved for the TLD, and all approved tables must have a corresponding
      object in the deposit.
    Input-Parameters:
      - rde.deposit
      - idn.tableIDs
  rde-12:
    Summary: validate NNDN objects
    Description: |
      NNDN table objects (whether CSV or XML) must have the required object
      properties, and the values of those object properties must be well-formed.

      The aName property of NNDN objects must not match the name property of a
      domain object.
    Input-Parameters:
      - rde.deposit
  rde-13:
    Summary: validate EPP parameters object
    Description: |
      The EPP Parameters object must match the `<greeting>` element returned by
      the EPP server.
    Input-Parameters:
      - epp.objectURIs
      - epp.extensionURIs
      - epp.hostModel
      - general.minimumPublicDataSet
  rde-14:
    Summary: validate policy object
    Description: |
      The object policies included in the `<rdePolicy:policy>` object must
      conform to the Registration Data Policy and the applicable data model.
    Input-Parameters:
      - general.minimumPublicDataSet

  epp-01:
    Summary: EPP server must have at least one A record
    Description: |
      At least one `A` record must be published in the DNS for the EPP hostname,
      to allow IPv4-only hosts to connect to the EPP service.
    Input-Parameters:
      - epp.hostname
  epp-02:
    Summary: EPP server must have at least one AAAA record
    Description: |
      At least one `A` record must be published in the DNS for the EPP hostname,
      to allow IPv6-only hosts to connect to the EPP service.
    Input-Parameters:
      - epp.hostname
  epp-03:
    Summary: All IP addresses must accept TCP connections on port 700
    Description: |
      EPP is associated with TCP port 700. All IPv4/IPv6 addresses published
      in the DNS for the EPP hostname must accept TCP connections on this port.

      Since the EPP specification requires IP-based access control, the RSP must
      configure their firewall to allow access from the RST system.
    Dependencies:
      - epp-01
      - epp-02
  epp-04:
    Summary: All service ports support TLSv1.2 or higher
    Description: |
      EPP uses TLS to secure the channel between client and server. The server
      must support TLSv1.2 and optionally any subsequent protocol published by
      the IETF.
    Dependencies:
      - epp-03
  epp-05:
    Summary: All service ports must not support TLSv1.1 or earlier
    Description: |
      TLSv1.1 and all previous versions have known security issues and should
      not be supported by the server.
    Dependencies:
      - epp-03
  epp-06:
    Summary: All service ports must offer a valid certificate issued by a trusted CA
    Description: |
      To ensure that the connection can be trusted, the server must present a
      certificate issued by a trusted CA, such as those supported by major
      browsers.
    Dependencies:
      - epp-03
  epp-07:
    Summary: TLS certificate must be valid
    Description: |
      The TLS certificate must not have expired, and must be presented with any
      additional intermediate certificates.
    Dependencies:
      - epp-03
  epp-08:
    Summary: TLS certificate must be valid for the server name
    Description: |
      The EPP server name must match at least one subjectAltName fields in the
      certificate (either exact match or wildcard).
    Dependencies:
      - epp-03
  epp-09:
    Summary: All service ports must send a <greeting> frame after successful connection
    Description: |
      Once the connection is estanblished the server must send a `<greeting>`
      frame to the client.
    Input-Parameters:
      - epp.hostname
      - epp.port
      - epp.objectURIs
      - epp.extensionURIs
      - epp.hostModel
      - general.minimumPublicDataSet
  epp-10:
    Summary: All server responses must validate against the XML schema
    Description: |
      All response frames received from the server must be well-formed XML
      instances, and validate against all XSD schemas (the base EPP schemas
      in addition to any extensions).
  epp-11:
    Summary: <svID> element in the <greeting> must be valid
    Description: |
      The `<svID>` element in the `<greeting>` must identify the EPP server.
    Dependencies:
      - epp-09
  epp-12:
    Summary: <svDate> element in the <greeting> must be valid
    Description: |
      The `<svDate>` element in the `<greeting>` must specify a time within
      close proximity to the current date and time.
    Dependencies:
      - epp-09
  epp-13:
    Summary: <version> element in the <greeting> must be valid
    Description: |
      The <version> element in the <greeting> must be exactly `1.0`.
    Dependencies:
      - epp-09
  epp-14:
    Summary: <lang> element(s) in the <greeting> must be valid
    Description: |
      All `<lang>` element(s) in the `<greeting>` must contain valid language
      codes.
    Dependencies:
      - epp-09
  epp-15:
    Summary: <objURI> element(s) in the <greeting> must be valid for the registry type
    Description: |
      All `<objURI>` element(s) in the `<greeting>` must contain XML namespace
      URIs TODO
    Dependencies:
      - epp-09
    Input-Parameters:
      - epp.objectURIs
      - epp.hostModel
      - general.minimumPublicDataSet
  epp-16:
    Summary: <extURI> element(s) in the <greeting> must be valid
    Dependencies:
      - epp-09
    Input-Parameters:
      - epp.extensionURIs
      - epp.hostModel
      - general.minimumPublicDataSet
  epp-17:
    Summary: <login> command must return a successful response
    Dependencies:
      - epp-09
    Input-Parameters:
      - epp.clid
      - epp.pwd
      - epp.extensionURIs
  epp-18:
    Summary: <hello> command must return a <greeting>
    Dependencies:
      - epp-09
  epp-19:
    Summary: domain <check> command test
    Input-Parameters:
    Dependencies:
      - epp-17
  epp-20:
    Summary: domain sunrise <check> command test
    Input-Parameters:
    Dependencies:
      - epp-17
  epp-21:
    Summary: domain trademark claims <check> command test
    Input-Parameters:
    Dependencies:
      - epp-17
  epp-22:
    Summary: host <check> command test (if applicable)
    Input-Parameters:
      - epp.hostModel
    Dependencies:
      - epp-17
  epp-23:
    Summary: contact <check> command test (if applicable for the registry type)
    Input-Parameters:
      - general.minimumPublicDataSet
    Dependencies:
      - epp-17
  epp-24:
    Summary: contact <create> command test (if applicable for the registry type)
    Input-Parameters:
      - general.minimumPublicDataSet
    Dependencies:
      - epp-17
  epp-25:
    Summary: contact <info> command test (if applicable for the registry type)
    Input-Parameters:
      - general.minimumPublicDataSet
    Dependencies:
      - epp-17
  epp-26:
    Summary: contact <update> command test (if applicable for the registry type)
    Input-Parameters:
      - general.minimumPublicDataSet
    Dependencies:
      - epp-17
  epp-27:
    Summary: contact <delete> command test (if applicable for the registry type)
    Input-Parameters:
      - general.minimumPublicDataSet
    Dependencies:
      - epp-17
  epp-28:
    Summary: host <create> command test (if applicable)
    Input-Parameters:
      - epp.hostModel
    Dependencies:
      - epp-17
  epp-29:
    Summary: host <info> command test (if applicable)
    Input-Parameters:
      - epp.hostModel
    Dependencies:
      - epp-17
  epp-30:
    Summary: host <update> command test (if applicable)
    Input-Parameters:
      - epp.hostModel
    Dependencies:
      - epp-17
  epp-31:
    Summary: host <delete> command test (if applicable)
    Input-Parameters:
      - epp.hostModel
    Dependencies:
      - epp-17
  epp-32:
    Summary: domain <create> command test (if applicable)
    Input-Parameters:
      - epp.hostModel
    Dependencies:
      - epp-17
  epp-33:
    Summary: domain <info> command test
    Input-Parameters:
    Dependencies:
      - epp-17
  epp-34:
    Summary: domain <update> command test
    Input-Parameters:
    Dependencies:
      - epp-17
  epp-35:
    Summary: domain <renew> command test
    Input-Parameters:
    Dependencies:
      - epp-17
  epp-36:
    Summary: domain <transfer> command test
    Input-Parameters:
    Dependencies:
      - epp-17
  epp-37:
    Summary: domain <delete> command test
    Input-Parameters:
    Dependencies:
      - epp-17
  epp-38:
    Summary: host rename test (if applicable)
    Input-Parameters:
      - epp.hostModel
    Dependencies:
      - epp-17
  epp-39:
    Summary: domain restore test (if applicable)
    Input-Parameters:
      - epp.extensionURIs
    Dependencies:
      - epp-17

  eppLaunch-01:
    Summary: launch application sunrise <info> command test
    Input-Parameters:
      - general.sunriseModel
    Dependencies:
  eppLaunch-02:
    Summary: |
      domain/launch application sunrise <create> command test
    Input-Parameters:
      - general.sunriseModel
    Dependencies:
  eppLaunch-03:
    Summary: domain trademark claims <create> command test
    Input-Parameters:
    Dependencies:
  eppLaunch-04:
    Summary: LORDN submission test
    Input-Parameters:
    Dependencies:

Input-Parameters:
  epp.hostname:
    Description: the fully-qualified domain name of the EPP server.
    Type: string
    Example: epp.rsp.tech
  epp.port:
    Description: the TCP port of the EPP service.
    Type: integer
    Example: 700
  epp.clid:
    Description: the username used to log in to the EPP server.
    Type: string
    Example: clid-01
  epp.pwd:
    Description: the password used to log in to the EPP server.
    Type: string
    Example: foo2bar
  rde.deposit:
    Description: an RDE deposit file.
    Type: file
    Example: example_20231004_FULL_S1_R0.ryde
  rde.signature:
    Description: an RDE deposit signature.
    Type: file
    Example: example_20231004_FULL_S1_R0.sig
  general.minimumPublicDataSet:
    Description: |
      if true, then the registry only supports the minimum public data set, and
      does not collect registrant and/or technical contact information from
      registrars.
    Type: boolean
    Example: true
  idn.tableIDs:
    Description: the list of supported IDN tables.
    Type: array
    Example:
      - latn
      - arab
      - zh
      - fr_FR
  epp.hostModel:
    Description: |
      whether the EPP server supports host `objects` or host `attributes`.
    Type: string
    Example: objects
  epp.objectURIs:
    Description: the list of supported object namespace URIs.
    Type: array
    Example:
      - urn:ietf:params:xml:ns:domain-1.0
      - urn:ietf:params:xml:ns:host-1.0
  epp.extensionURIs:
    Description: the list of supported extension namespace URIs.
    Type: array
    Example:
      - urn:ietf:params:xml:ns:epp:loginSec-1.0
      - urn:ietf:params:xml:ns:epp:fee-1.0
  general.sunriseModel:
    Description: |
      whether the EPP server supports `startDate` or `endDate` sunrises.
    Type: string
    Example: startDate

